Directory structure:
‚îî‚îÄ‚îÄ Compressor/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ readme_progress.md
    ‚îú‚îÄ‚îÄ backend/
    ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
    ‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.dev.yml
    ‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
    ‚îÇ   ‚îú‚îÄ‚îÄ ecosystem.config.js
    ‚îÇ   ‚îú‚îÄ‚îÄ package.json
    ‚îÇ   ‚îú‚îÄ‚îÄ .env.example
    ‚îÇ   ‚îú‚îÄ‚îÄ scripts/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deploy-production.sh
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deploy-staging.sh
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ health-check.sh
    ‚îÇ   ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ download.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ health.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ process.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ upload.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fileService.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ imageService.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jobService.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ processingService.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ queueService.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ redis.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ workers/
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ processor.js
    ‚îÇ   ‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ frontend/
        ‚îú‚îÄ‚îÄ index.html
        ‚îú‚îÄ‚îÄ css/
        ‚îÇ   ‚îî‚îÄ‚îÄ styles.css
        ‚îî‚îÄ‚îÄ js/
            ‚îú‚îÄ‚îÄ api.js
            ‚îú‚îÄ‚îÄ app.js
            ‚îú‚îÄ‚îÄ ui.js
            ‚îú‚îÄ‚îÄ utils.js
            ‚îî‚îÄ‚îÄ websocket.js

================================================
File: README.md
================================================
# üóúÔ∏è Optimiseur de Fichiers Multim√©dia

Une solution self-hosted compl√®te pour compresser et optimiser tous vos fichiers multim√©dia tout en conservant leur format original.

![Version](https://img.shields.io/badge/version-2.0.0-blue.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)
![Node](https://img.shields.io/badge/node-%3E%3D16.0.0-brightgreen.svg)
![Docker](https://img.shields.io/badge/docker-ready-blue.svg)

## üéØ Objectif

R√©duire la taille de vos fichiers multim√©dia sans changer leur format, avec une interface web moderne et un backend performant utilisant FFmpeg.

## ‚ú® Fonctionnalit√©s

### üì∏ Images
- **Formats support√©s** : JPEG, PNG, WebP, AVIF, HEIC, TIFF, BMP
- **Compression intelligente** avec pr√©servation de la qualit√©
- **Redimensionnement automatique** selon vos besoins
- **Conversion de format** optionnelle
- **Optimisation des m√©tadonn√©es** (suppression EXIF)

### üéµ Audio
- **Formats support√©s** : MP3, FLAC, WAV, AAC, OGG, M4A
- **Compression variable** (CBR/VBR)
- **Normalisation du volume** automatique
- **Conversion multi-format** simultan√©e
- **R√©duction de fr√©quence d'√©chantillonnage**

### üé¨ Vid√©o
- **Formats support√©s** : MP4, AVI, MKV, WebM, MOV, FLV
- **Codecs modernes** : H.264, H.265/HEVC, VP9, AV1
- **Compression adaptative** selon le contenu
- **Redimensionnement et recadrage** automatique
- **Optimisation pour le streaming** web

### üìÑ Documents
- **PDF** : Compression des images int√©gr√©es
- **Optimisation de la structure** du document
- **Suppression des m√©tadonn√©es** sensibles

## üèóÔ∏è Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    HTTP/WebSocket    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ                 ‚îÇ
‚îÇ    Frontend     ‚îÇ                     ‚îÇ     Backend     ‚îÇ
‚îÇ   (React/Vue)   ‚îÇ                     ‚îÇ   (Node.js)     ‚îÇ
‚îÇ                 ‚îÇ                     ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                 ‚îÇ
                                                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ   File Upload   ‚îÇ    ‚îÇ  Processing     ‚îÇ    ‚îÇ   FFmpeg        ‚îÇ
‚îÇ   & Settings    ‚îÇ    ‚îÇ     Queue       ‚îÇ    ‚îÇ  ImageMagick    ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ   (Redis)       ‚îÇ    ‚îÇ   PDF-lib       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üöÄ Installation & D√©ploiement

### Option 1 : Docker (Recommand√©)

```bash
# Cloner le repository
git clone https://github.com/votre-username/file-optimizer.git
cd file-optimizer

# Lancer avec Docker Compose
docker-compose up -d

# L'application sera disponible sur http://localhost:3000
```

### Option 2 : Installation manuelle

#### Pr√©requis

- **Node.js** 16+ 
- **FFmpeg** install√© et dans le PATH
- **ImageMagick** (optionnel, pour images avanc√©es)
- **Redis** (pour la queue de traitement)

#### Backend

```bash
cd backend
npm install

# Configuration
cp .env.example .env
# √âditer .env avec vos param√®tres

# Lancer le serveur
npm run dev
```

#### Frontend

```bash
cd frontend
npm install
npm run build
npm start
```

## ‚öôÔ∏è Configuration

### Variables d'environnement

```env
# Backend
PORT=8000
REDIS_URL=redis://localhost:6379
UPLOAD_MAX_SIZE=500MB
TEMP_DIR=/tmp/uploads
CLEANUP_INTERVAL=3600

# FFmpeg
FFMPEG_PATH=/usr/bin/ffmpeg
FFPROBE_PATH=/usr/bin/ffprobe

# Security
CORS_ORIGIN=http://localhost:3000
JWT_SECRET=your-secret-key
RATE_LIMIT=100

# Storage
STORAGE_TYPE=local # ou s3, gcs
S3_BUCKET=your-bucket
S3_REGION=eu-west-1
```

### Param√®tres de compression par d√©faut

```json
{
  "images": {
    "quality": 80,
    "maxWidth": 1920,
    "maxHeight": 1080,
    "format": "auto"
  },
  "videos": {
    "codec": "h264",
    "crf": 23,
    "preset": "medium",
    "maxBitrate": "2M"
  },
  "audio": {
    "codec": "aac",
    "bitrate": "128k",
    "sampleRate": 44100
  }
}
```

## üìä Performances & Limites

### Performances typiques

| Type de fichier | Taille max | Temps de traitement | Compression moyenne |
|-----------------|------------|--------------------|--------------------|
| **Image JPEG**  | 50 MB      | 2-5 secondes       | 30-70%            |
| **Vid√©o HD**    | 2 GB       | 2-10 minutes       | 40-80%            |
| **Audio FLAC**  | 200 MB     | 10-30 secondes     | 50-90%            |
| **PDF**         | 100 MB     | 5-15 secondes      | 10-60%            |

### Limites recommand√©es

- **Fichier unique** : 5 GB max
- **Traitement simultan√©** : 10 fichiers
- **Stockage temporaire** : 50 GB
- **R√©tention** : 24 heures

## üõ†Ô∏è API Documentation

### Upload de fichier

```http
POST /api/upload
Content-Type: multipart/form-data

{
  "file": [binary],
  "settings": {
    "quality": 80,
    "maxWidth": 1920,
    "format": "jpeg"
  }
}
```

### Statut du traitement

```http
GET /api/status/:jobId

Response:
{
  "status": "processing|completed|error",
  "progress": 45,
  "originalSize": 15728640,
  "compressedSize": 4718592,
  "compressionRatio": 70,
  "eta": 120
}
```

### T√©l√©chargement

```http
GET /api/download/:jobId

Response: [binary file]
```

## üîß D√©veloppement

### Structure du projet

```
file-optimizer/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ workers/
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ README.md
```

### Lancer en mode d√©veloppement

```bash
# Terminal 1 - Backend
cd backend && npm run dev

# Terminal 2 - Frontend  
cd frontend && npm run dev

# Terminal 3 - Redis
redis-server

# Terminal 4 - Worker
cd backend && npm run worker
```

### Tests

```bash
# Tests backend
cd backend && npm test

# Tests frontend
cd frontend && npm test

# Tests d'int√©gration
npm run test:e2e
```

## üê≥ Docker

### Dockerfile multi-stage

```dockerfile
# Frontend build
FROM node:18-alpine AS frontend
WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm ci
COPY frontend/ ./
RUN npm run build

# Backend avec FFmpeg
FROM node:18-alpine AS backend
RUN apk add --no-cache ffmpeg imagemagick
WORKDIR /app
COPY backend/package*.json ./
RUN npm ci --only=production
COPY backend/ ./
COPY --from=frontend /app/frontend/dist ./public

EXPOSE 8000
CMD ["npm", "start"]
```

### Docker Compose

```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - uploads:/tmp/uploads
    depends_on:
      - redis

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

  worker:
    build: .
    command: npm run worker
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - uploads:/tmp/uploads
    depends_on:
      - redis

volumes:
  uploads:
  redis_data:
```

## üìà Monitoring & Logs

### M√©triques disponibles

- **D√©bit** : Fichiers trait√©s par heure
- **Temps de traitement** moyen par type
- **Taux de compression** moyen
- **Utilisation CPU/M√©moire**
- **Erreurs** et causes

### Int√©grations

- **Prometheus** + Grafana pour m√©triques
- **Winston** pour logs structur√©s
- **Sentry** pour monitoring erreurs
- **Health checks** Docker

## üîí S√©curit√©

### Mesures impl√©ment√©es

- **Rate limiting** par IP
- **Validation** stricte des fichiers upload√©s
- **Scan antivirus** optionnel (ClamAV)
- **Chiffrement** des fichiers temporaires
- **Nettoyage automatique** des fichiers
- **CORS** configur√© strictement

### Recommandations

- Utiliser HTTPS en production
- Configurer un reverse proxy (Nginx)
- Limiter les tailles d'upload
- Monitorer l'espace disque
- Sauvegardes r√©guli√®res des configurations

## ü§ù Contribution

1. **Fork** le projet
2. **Cr√©er** une branche feature (`git checkout -b feature/amazing-feature`)
3. **Commit** vos changements (`git commit -m 'Add amazing feature'`)
4. **Push** vers la branche (`git push origin feature/amazing-feature`)
5. **Ouvrir** une Pull Request

### Guidelines

- Code format√© avec Prettier
- Tests unitaires pour nouvelles fonctionnalit√©s
- Documentation mise √† jour
- Commits conventionnels

## üìù Roadmap

### Version 2.1
- [ ] Support WebAssembly pour compression c√¥t√© client
- [ ] Interface mobile d√©di√©e
- [ ] Compression batch programm√©e
- [ ] Int√©gration cloud storage (S3, GCS)

### Version 2.2
- [ ] Machine Learning pour compression optimale
- [ ] API GraphQL
- [ ] Plugin WordPress/Drupal
- [ ] Support formats RAW photo

### Version 3.0
- [ ] Clustering multi-serveurs
- [ ] CDN int√©gr√©
- [ ] Compression temps r√©el streaming
- [ ] Interface admin avanc√©e

## üÜò Support

### Documentation
- [Wiki complet](https://github.com/votre-username/file-optimizer/wiki)
- [FAQ](https://github.com/votre-username/file-optimizer/wiki/FAQ)
- [Troubleshooting](https://github.com/votre-username/file-optimizer/wiki/Troubleshooting)

### Communaut√©
- [Discord](https://discord.gg/file-optimizer)
- [Forum](https://forum.file-optimizer.com)
- [Issues GitHub](https://github.com/votre-username/file-optimizer/issues)

### Support commercial
- Email : support@file-optimizer.com
- Consulting : consulting@file-optimizer.com

## üìÑ License

Ce projet est sous licence MIT. Voir le fichier [LICENSE](LICENSE) pour plus de d√©tails.

## üôè Remerciements

- **FFmpeg** pour le moteur de traitement multim√©dia
- **ImageMagick** pour le traitement d'images avanc√©
- **Redis** pour la gestion des queues
- La communaut√© **open source** pour les contributions

---

**Made with ‚ù§Ô∏è by [Votre Nom]**

> üí° **Astuce** : Commencez par la version Docker pour un d√©ploiement rapide, puis personnalisez selon vos besoins !


================================================
File: readme_progress.md
================================================
# üóúÔ∏è Optimiseur de Fichiers Multim√©dia

## üìã √âtat d'avancement du projet

### ‚úÖ **Compl√©t√© (√âtape 1/7) - Backend Services**

**Services Backend (backend/src/services/)**
- ‚úÖ `jobService.js` - Gestion compl√®te des jobs Redis
- ‚úÖ `queueService.js` - Queue Bull/Redis avec √©v√©nements
- ‚úÖ `fileService.js` - Utilitaires de gestion de fichiers
- ‚úÖ `imageService.js` - Traitement d'images avec Sharp
- ‚úÖ `processingService.js` - Orchestrateur principal

### ‚úÖ **Compl√©t√© (√âtape 2/7) - Backend Utils & Configuration**

**Utilitaires Backend (backend/src/utils/)**
- ‚úÖ `logger.js` - Syst√®me de logging Winston complet
- ‚úÖ `redis.js` - Client Redis avec reconnexion automatique
- ‚úÖ `validation.js` - Validation Joi compl√®te + s√©curit√©

**Configuration**
- ‚úÖ `.env.example` - Variables d'environnement document√©es
- ‚úÖ `package.json` - D√©pendances et scripts NPM

### ‚úÖ **Compl√©t√© (√âtape 3/7) - Routes API**

**Routes Express (backend/src/routes/)**
- ‚úÖ `upload.js` - Upload multipart avec validation s√©curis√©e
- ‚úÖ `status.js` - Statut jobs avec pagination et filtres
- ‚úÖ `download.js` - T√©l√©chargement avec Range support
- ‚úÖ `process.js` - Gestion traitement et queue
- ‚úÖ `health.js` - Health checks syst√®me complets
- ‚úÖ `index.js` - Routeur principal avec middleware

### ‚úÖ **Compl√©t√© (√âtape 4/7) - Serveur Principal & Worker**

**Serveur & Worker (backend/src/)**
- ‚úÖ `server.js` - Serveur Express complet avec WebSocket
- ‚úÖ `workers/processor.js` - Worker Bull pour traitement asynchrone

**Configuration Docker & D√©ploiement**
- ‚úÖ `docker-compose.yml` - Configuration production + d√©veloppement
- ‚úÖ `Dockerfile` - Multi-stage build optimis√©
- ‚úÖ `ecosystem.config.js` - Configuration PM2
- ‚úÖ Scripts de d√©ploiement automatis√©s

### ‚úÖ **Compl√©t√© (√âtape 5/7) - Frontend Moderne**

**Interface Frontend (frontend/)**
- ‚úÖ `index.html` - Page principale responsive avec WebSocket
- ‚úÖ `css/styles.css` - Design system moderne et adaptatif
- ‚úÖ `js/app.js` - Application principale orchestratrice
- ‚úÖ `js/api.js` - Client API REST avec retry/cache
- ‚úÖ `js/websocket.js` - Client WebSocket temps r√©el
- ‚úÖ `js/ui.js` - Gestionnaire interface utilisateur
- ‚úÖ `js/utils.js` - Utilitaires g√©n√©raux et formatage

**Fonctionnalit√©s Frontend compl√®tes :**
- üì§ **Upload drag & drop** : Multi-fichiers avec validation temps r√©el
- üìä **Dashboard temps r√©el** : WebSocket pour progression jobs
- üé® **Interface moderne** : Responsive mobile-first avec animations
- üîÑ **Gestion d'√©tat robuste** : Cache intelligent, retry automatique
- üîî **Notifications** : Toast contextuel avec auto-masquage
- ‚å®Ô∏è **Raccourcis clavier** : Navigation optimis√©e d√©veloppeur
- üéØ **Actions contextuelles** : Download, retry, delete selon statut

---

## üéØ **Prochaines √©tapes**

### üîÑ **√âtape 6/7 - Tests & Monitoring**
- Tests unitaires et d'int√©gration
- Configuration Prometheus/Grafana
- Documentation API compl√®te

### üîÑ **√âtape 7/7 - Finalisation**
- Guide d'installation
- Documentation utilisateur
- Scripts de maintenance

---

## üèóÔ∏è **Architecture finale actuelle**

```
backend/src/                  ‚úÖ TERMIN√â
‚îú‚îÄ‚îÄ services/                 ‚úÖ Services m√©tier complets
‚îÇ   ‚îú‚îÄ‚îÄ jobService.js         ‚úÖ Gestion jobs Redis
‚îÇ   ‚îú‚îÄ‚îÄ queueService.js       ‚úÖ Queue Bull/Redis
‚îÇ   ‚îú‚îÄ‚îÄ fileService.js        ‚úÖ Utilitaires fichiers
‚îÇ   ‚îú‚îÄ‚îÄ imageService.js       ‚úÖ Traitement images Sharp
‚îÇ   ‚îî‚îÄ‚îÄ processingService.js  ‚úÖ Orchestrateur principal
‚îú‚îÄ‚îÄ utils/                    ‚úÖ Utilitaires robustes
‚îÇ   ‚îú‚îÄ‚îÄ logger.js            ‚úÖ Winston logging complet
‚îÇ   ‚îú‚îÄ‚îÄ redis.js             ‚úÖ Client Redis robuste
‚îÇ   ‚îî‚îÄ‚îÄ validation.js        ‚úÖ Validation Joi + s√©curit√©
‚îú‚îÄ‚îÄ routes/                   ‚úÖ API REST compl√®te
‚îÇ   ‚îú‚îÄ‚îÄ upload.js            ‚úÖ Upload multipart s√©curis√©
‚îÇ   ‚îú‚îÄ‚îÄ status.js            ‚úÖ Statut avec pagination
‚îÇ   ‚îú‚îÄ‚îÄ download.js          ‚úÖ Download avec streaming
‚îÇ   ‚îú‚îÄ‚îÄ process.js           ‚úÖ Gestion traitement
‚îÇ   ‚îú‚îÄ‚îÄ health.js            ‚úÖ Health checks complets
‚îÇ   ‚îî‚îÄ‚îÄ index.js             ‚úÖ Routeur principal
‚îú‚îÄ‚îÄ workers/                  ‚úÖ Worker de traitement
‚îÇ   ‚îî‚îÄ‚îÄ processor.js         ‚úÖ Worker Bull avec monitoring
‚îî‚îÄ‚îÄ server.js                ‚úÖ Serveur Express + WebSocket

backend/                      ‚úÖ Configuration compl√®te
‚îú‚îÄ‚îÄ .env.example             ‚úÖ Variables d'environnement
‚îú‚îÄ‚îÄ package.json             ‚úÖ D√©pendances + scripts
‚îú‚îÄ‚îÄ docker-compose.yml       ‚úÖ Docker production/dev
‚îú‚îÄ‚îÄ Dockerfile               ‚úÖ Multi-stage optimis√©
‚îú‚îÄ‚îÄ ecosystem.config.js      ‚úÖ Configuration PM2
‚îî‚îÄ‚îÄ scripts/                 ‚úÖ Scripts d√©ploiement
    ‚îú‚îÄ‚îÄ deploy-production.sh ‚úÖ D√©ploiement production
    ‚îú‚îÄ‚îÄ deploy-staging.sh    ‚úÖ D√©ploiement staging
    ‚îî‚îÄ‚îÄ health-check.sh      ‚úÖ V√©rification sant√©

frontend/                     ‚úÖ TERMIN√â
‚îú‚îÄ‚îÄ index.html               ‚úÖ Interface principale responsive
‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ styles.css          ‚úÖ Design system moderne
‚îú‚îÄ‚îÄ js/                      ‚úÖ Architecture modulaire
‚îÇ   ‚îú‚îÄ‚îÄ app.js              ‚úÖ Application orchestratrice
‚îÇ   ‚îú‚îÄ‚îÄ api.js              ‚úÖ Client API avec retry/cache
‚îÇ   ‚îú‚îÄ‚îÄ websocket.js        ‚úÖ Client WebSocket temps r√©el
‚îÇ   ‚îú‚îÄ‚îÄ ui.js               ‚úÖ Gestionnaire interface
‚îÇ   ‚îî‚îÄ‚îÄ utils.js            ‚úÖ Utilitaires g√©n√©raux
‚îî‚îÄ‚îÄ assets/                  ‚è≥ Ic√¥nes et images (optionnel)
```

---

## üöÄ **Nouvelles fonctionnalit√©s √âtape 5 : Frontend**

### üé® **Interface Utilisateur Moderne**

#### **Design System Coh√©rent**
- **Variables CSS** personnalisables pour th√©matisation
- **Responsive breakpoints** mobile/tablet/desktop optimis√©s
- **Dark mode** automatique selon pr√©f√©rences syst√®me
- **Animations fluides** avec hardware acceleration
- **Accessibilit√©** ARIA labels et navigation clavier

#### **Upload Drag & Drop Avanc√©**
```javascript
// Fonctionnalit√©s upload
- Multi-fichiers simultan√©s avec validation
- Feedback visuel temps r√©el (dragover, errors)
- Validation c√¥t√© client (type, taille, magic bytes)
- Progression upload avec indicateur pourcentage
- Gestion d'erreurs granulaire par fichier
```

#### **Dashboard Jobs Temps R√©el**
- **Statuts visuels** avec couleurs contextuelles
- **Barres de progression** anim√©es pour jobs actifs
- **Actions contextuelles** selon statut (download, retry, delete)
- **Informations d√©taill√©es** taille, compression, temps
- **Tri et filtrage** par statut, type, date

### üîå **Int√©gration WebSocket Robuste**

#### **Client WebSocket Intelligent**
```javascript
class WebSocketManager {
    // Reconnexion automatique avec backoff exponentiel
    // Gestion des rooms de jobs pour updates cibl√©es
    // Ping/pong pour monitoring latence
    // Queue d'√©v√©nements pour offline/online
    // Retry automatique pour √©v√©nements critiques
}
```

#### **√âv√©nements Temps R√©el**
- **job-progress** : Mise √† jour progression 0-100%
- **job-completed** : Notification completion avec m√©triques
- **job-error** : Gestion erreurs avec d√©tails et retry
- **server-shutdown** : Notification arr√™t serveur gracieux
- **connection-status** : Indicateur visuel connexion

### üíæ **Architecture Frontend Modulaire**

#### **5 Modules Sp√©cialis√©s**

**1. app.js - Orchestrateur Principal**
```javascript
class FileOptimizer {
    // Gestion lifecycle application
    // Coordination entre modules
    // √âtat global des jobs
    // Configuration centralis√©e
}
```

**2. api.js - Client API REST**
```javascript
class ApiClient {
    // Requ√™tes HTTP avec timeout/retry
    // Upload avec progression
    // Cache intelligent pour GET
    // Batch requests avec concurrence limit√©e
}
```

**3. websocket.js - Client WebSocket**
```javascript
class WebSocketManager {
    // Connexion robuste avec reconnexion
    // Gestion √©v√©nements m√©tier
    // Rooms de jobs pour updates cibl√©es
    // Monitoring latence et sant√© connexion
}
```

**4. ui.js - Gestionnaire Interface**
```javascript
class UIManager {
    // Rendu dynamique des composants
    // Animations et transitions fluides
    // Notifications toast intelligentes
    // Gestion formulaires et validations
}
```

**5. utils.js - Utilitaires G√©n√©raux**
```javascript
class Utils {
    // Formatage donn√©es (taille, dur√©e, dates)
    // Helpers DOM et manipulation
    // Logger configurable par niveau
    // Patterns performance (debounce, throttle)
}
```

### üéØ **Exp√©rience Utilisateur Optimis√©e**

#### **Workflow Intuitif**
1. **Drag & Drop** ‚Üí Validation ‚Üí Upload automatique
2. **Progression temps r√©el** via WebSocket
3. **Notification completion** avec m√©triques compression
4. **Download one-click** avec nom optimis√©

#### **Gestion d'Erreurs Intelligente**
- **Retry automatique** pour requ√™tes r√©seau
- **Fallback gracieux** si WebSocket indisponible
- **Messages contextuels** selon type d'erreur
- **Recovery suggestions** pour actions utilisateur

#### **Performance Frontend**
- **Cache API** intelligent avec expiration
- **Debounce** √©v√©nements fr√©quents (scroll, resize)
- **Lazy loading** pour listes longues
- **Memory management** avec cleanup automatique

### üì± **Support Mobile Complet**

#### **Responsive Design**
```css
/* Breakpoints adaptatifs */
@media (max-width: 768px) {
    /* Optimisations mobile */
    .job-header { flex-direction: column; }
    .job-actions { width: 100%; }
}
```

#### **Touch Optimizations**
- **Touch targets** 44px minimum pour accessibilit√©
- **Gestures** drag & drop tactiles optimis√©s
- **Swipe actions** pour actions rapides
- **Vibration feedback** si support√©e

### ‚ö° **Optimisations Performance**

#### **Client-Side Caching**
```javascript
// Cache intelligent API avec TTL
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// Retry automatique avec backoff
const retry = async (fn, maxAttempts = 3, baseDelay = 1000) => {
    // Backoff exponentiel pour requ√™tes √©chou√©es
};
```

#### **WebSocket Optimizations**
- **Connection pooling** pour √©viter reconnexions fr√©quentes
- **Event batching** pour updates multiples
- **Heartbeat monitoring** avec latence tracking
- **Graceful degradation** si WebSocket indisponible

### üîí **S√©curit√© Frontend**

#### **Validation Multi-niveaux**
- **Magic bytes** v√©rification signatures fichiers
- **MIME types** validation coh√©rence extension/contenu
- **File size** limites configurables
- **XSS protection** √©chappement HTML automatique

#### **Rate Limiting Client**
- **Upload throttling** pour √©viter spam
- **Request debouncing** pour actions fr√©quentes
- **Circuit breaker** pattern pour API instable

---

## üìä **M√©triques et Monitoring Frontend**

### **M√©triques Collect√©es**
```javascript
const metrics = {
    uploadCount: 0,           // Nombre total uploads
    totalSize: 0,             // Taille totale upload√©e
    averageTime: 0,           // Temps moyen traitement
    compressionRatio: 0,      // Ratio compression moyen
    errorRate: 0,             // Taux d'erreur
    websocketLatency: 0       // Latence WebSocket moyenne
};
```

### **Monitoring Temps R√©el**
- **Connection status** : Indicateur visuel connectivit√©
- **Performance tracking** : Temps r√©ponse API
- **Error tracking** : Logs d√©taill√©s par composant
- **Usage analytics** : Patterns utilisation

---

## üéØ **Workflow Utilisateur Complet**

### **1. Upload Multi-fichiers avec Progression**
```javascript
// 1. S√©lection fichiers (drag & drop ou clic)
const files = Array.from(e.dataTransfer.files);

// 2. Validation temps r√©el
const validFiles = files.filter(file => validateFile(file));

// 3. Upload parall√®le avec progression
for (const file of validFiles) {
    await uploadFile(file); // Progression WebSocket automatique
}

// 4. Notification completion
socket.on('job-completed', (result) => {
    showNotification(`${result.filename} optimis√©!`);
    showDownloadButton(result.jobId);
});
```

### **2. Dashboard Temps R√©el**
```javascript
// Synchronisation automatique √©tat local/serveur
socket.on('job-progress', (data) => {
    updateJobProgress(data.jobId, data.progress);
    updateProgressBar(data.progress);
});

// Actions contextuelles selon statut
const actions = {
    completed: ['download', 'delete'],
    error: ['retry', 'delete'],
    processing: ['cancel'],
    queued: ['cancel']
};
```

### **3. Gestion d'Erreurs et Recovery**
```javascript
// Retry automatique avec backoff
const retryUpload = async (file, maxAttempts = 3) => {
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            return await uploadFile(file);
        } catch (error) {
            if (attempt === maxAttempts) throw error;
            await delay(1000 * Math.pow(2, attempt));
        }
    }
};

// Fallback gracieux WebSocket
if (!websocket.isConnected) {
    // Polling fallback pour statuts jobs
    setInterval(() => refreshJobStatuses(), 5000);
}
```

---

## üîß **D√©ploiement et Configuration**

### **Serveur Frontend**
```bash
# D√©veloppement
npx http-server frontend/ -p 3000 -c-1

# Production avec Nginx
server {
    listen 80;
    root /var/www/file-optimizer/frontend;
    index index.html;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    location /api/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    location /socket.io/ {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

### **Configuration Frontend**
```javascript
// Configuration centralis√©e dans app.js
const config = {
    apiEndpoint: window.location.origin + '/api',
    maxFileSize: 5 * 1024 * 1024 * 1024, // 5GB
    supportedTypes: ['image', 'video', 'audio', 'document'],
    websocketTimeout: 20000,
    reconnectMaxAttempts: 10,
    cacheTimeout: 5 * 60 * 1000 // 5 minutes
};
```

### **Variables CSS Personnalisables**
```css
:root {
    --primary: #2563eb;        /* Couleur principale */
    --success: #10b981;        /* Couleur succ√®s */
    --error: #ef4444;          /* Couleur erreur */
    --radius: 8px;             /* Rayons courbure */
    --shadow: 0 4px 6px rgba(0,0,0,0.1); /* Ombres */
}
```

---

## ‚úÖ **Frontend Complet et Production-Ready**

### **üéâ Achievements √âtape 5**
- ‚úÖ **Architecture modulaire** : 5 modules JavaScript sp√©cialis√©s
- ‚úÖ **Interface moderne** : Responsive, accessible, anim√©e
- ‚úÖ **WebSocket temps r√©el** : Progression jobs, reconnexion auto
- ‚úÖ **Upload robuste** : Drag & drop multi-fichiers, validation
- ‚úÖ **Dashboard intuitif** : Actions contextuelles, statuts visuels
- ‚úÖ **Performance optimis√©e** : Cache, retry, debounce patterns
- ‚úÖ **Mobile-first** : Touch optimizations, responsive design

### **üöÄ Backend + Frontend = Application Compl√®te**

L'application **File Optimizer** dispose maintenant d'une stack compl√®te :

#### **üèóÔ∏è Architecture Full-Stack**
- **Backend** : API REST + WebSocket + Worker + Redis + Docker
- **Frontend** : SPA moderne + WebSocket + Cache + Mobile
- **Communication** : REST pour actions, WebSocket pour temps r√©el
- **D√©ploiement** : Docker Compose + Nginx + PM2

#### **üí™ Fonctionnalit√©s End-to-End**
- Upload drag & drop ‚Üí Traitement asynchrone ‚Üí Download optimis√©
- Progression temps r√©el via WebSocket 
- Gestion d'erreurs robuste avec retry automatique
- Interface responsive mobile-first
- Monitoring et health checks complets

#### **üéØ Pr√™t pour Tests d'Int√©gration**

L'application compl√®te peut maintenant √™tre test√©e :

1. **D√©marrer Backend** : API + Worker + Redis
2. **Servir Frontend** : HTTP server sur port 3000
3. **Tester workflow** : Upload ‚Üí Progression ‚Üí Download
4. **Valider WebSocket** : Temps r√©el, reconnexion
5. **Tester responsive** : Mobile, tablet, desktop

### **üîú Prochaine √âtape : Tests & Finition**
- **Tests d'int√©gration** frontend/backend
- **Documentation utilisateur** compl√®te
- **Optimisations finales** performance
- **Packaging** pour distribution

**L'application File Optimizer est pr√™te pour utilisation ! üéâ**


================================================
File: backend/Dockerfile
================================================
# Dockerfile
# Multi-stage build pour optimiser la taille et s√©curit√©

# ===========================================
# Stage 1: Base image avec d√©pendances syst√®me
# ===========================================
FROM node:18-alpine AS base

# Installer les d√©pendances syst√®me requises
RUN apk add --no-cache \
    ffmpeg \
    imagemagick \
    curl \
    dumb-init \
    && rm -rf /var/cache/apk/*

# Cr√©er l'utilisateur non-root pour la s√©curit√©
RUN addgroup -g 1001 -S nodejs \
    && adduser -S fileoptimizer -u 1001 -G nodejs

# D√©finir le r√©pertoire de travail
WORKDIR /app

# Copier les fichiers de configuration des d√©pendances
COPY package*.json ./

# ===========================================
# Stage 2: D√©veloppement
# ===========================================
FROM base AS development

# Installer toutes les d√©pendances (dev + prod)
RUN npm ci --include=dev

# Copier le code source
COPY . .

# Changer la propri√©t√© des fichiers
RUN chown -R fileoptimizer:nodejs /app

# Cr√©er les r√©pertoires n√©cessaires
RUN mkdir -p /app/uploads /app/logs \
    && chown -R fileoptimizer:nodejs /app/uploads /app/logs

USER fileoptimizer

# Port d'exposition
EXPOSE 8000 9229

# Point d'entr√©e avec dumb-init pour un arr√™t propre
ENTRYPOINT ["dumb-init", "--"]

# Commande par d√©faut
CMD ["npm", "run", "dev"]

# ===========================================
# Stage 3: Build de production
# ===========================================
FROM base AS builder

# Installer seulement les d√©pendances de production
RUN npm ci --only=production && npm cache clean --force

# Copier le code source
COPY . .

# Supprimer les fichiers non n√©cessaires en production
RUN rm -rf \
    tests/ \
    docs/ \
    .git/ \
    .github/ \
    *.md \
    .eslintrc.js \
    .prettierrc \
    docker-compose*.yml \
    Dockerfile*

# ===========================================
# Stage 4: Production finale
# ===========================================
FROM node:18-alpine AS production

# Installer seulement les d√©pendances syst√®me essentielles
RUN apk add --no-cache \
    ffmpeg \
    imagemagick \
    curl \
    dumb-init \
    && rm -rf /var/cache/apk/*

# Cr√©er l'utilisateur non-root
RUN addgroup -g 1001 -S nodejs \
    && adduser -S fileoptimizer -u 1001 -G nodejs

WORKDIR /app

# Copier les fichiers depuis le stage builder
COPY --from=builder --chown=fileoptimizer:nodejs /app ./

# Cr√©er les r√©pertoires avec permissions appropri√©es
RUN mkdir -p /app/uploads /app/logs /app/tmp \
    && chown -R fileoptimizer:nodejs /app/uploads /app/logs /app/tmp \
    && chmod 755 /app/uploads /app/logs /app/tmp

# Variables d'environnement par d√©faut
ENV NODE_ENV=production \
    PORT=8000 \
    TEMP_DIR=/app/uploads \
    LOG_DIR=/app/logs \
    NPM_CONFIG_CACHE=/app/tmp/.npm

# Passer √† l'utilisateur non-root
USER fileoptimizer

# Port d'exposition
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8000/api/health || exit 1

# Labels pour la m√©tadonn√©es
LABEL maintainer="File Optimizer Team" \
    version="2.0.0" \
    description="Optimiseur de fichiers multim√©dia" \
    org.opencontainers.image.source="https://github.com/your-username/file-optimizer"

# Point d'entr√©e avec dumb-init
ENTRYPOINT ["dumb-init", "--"]

# Commande par d√©faut
CMD ["npm", "start"]

# ===========================================
# Stage 5: Worker sp√©cialis√©
# ===========================================
FROM production AS worker

# Le worker utilise la m√™me base mais une commande diff√©rente
CMD ["npm", "run", "worker"]

# ===========================================
# .dockerignore suggestions
# ===========================================
# Cr√©er aussi un fichier .dockerignore avec:
#
# node_modules
# npm-debug.log*
# yarn-debug.log*
# yarn-error.log*
# .git
# .gitignore
# .github
# README.md
# docker-compose*.yml
# Dockerfile*
# .env
# .env.local
# .env.*.local
# coverage/
# .nyc_output
# .cache
# uploads/
# logs/
# tmp/
# *.log
# .DS_Store
# Thumbs.db
# tests/
# docs/
# monitoring/
# nginx/


================================================
File: backend/docker-compose.dev.yml
================================================
# docker-compose.dev.yml - Configuration D√âVELOPPEMENT
version: '3.8'

services:
  # Application en mode d√©veloppement
  app-dev:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: file-optimizer-dev
    ports:
      - "8000:8000"
      - "9229:9229" # Debug port Node.js
    environment:
      - NODE_ENV=development
      - PORT=8000
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=debug
      - CORS_ORIGIN=http://localhost:3000,http://localhost:8080
      - SKIP_RATE_LIMIT=true
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
      - JWT_SECRET=dev-secret-key
      - CLEANUP_INTERVAL=1800  # 30min en dev
      - FILE_RETENTION=3600    # 1h en dev
      - UPLOAD_MAX_SIZE=1073741824  # 1GB en dev
    volumes:
      # Montage du code source pour hot reload
      - ./backend:/app:cached
      - uploads_dev:/app/uploads
      - logs_dev:/app/logs
      - node_modules:/app/node_modules
    depends_on:
      - redis
    networks:
      - file-optimizer-dev
    command: npm run dev
    # Pas de restart policy en dev
    stdin_open: true
    tty: true

  # Worker en mode d√©veloppement
  worker-dev:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: file-optimizer-worker-dev
    environment:
      - NODE_ENV=development
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=debug
      - WORKER_CONCURRENCY=1  # Un seul worker en dev
      - JOB_TIMEOUT=900       # 15min timeout en dev
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
    volumes:
      - ./backend:/app:cached
      - uploads_dev:/app/uploads
      - logs_dev:/app/logs
      - node_modules:/app/node_modules
    depends_on:
      - redis
    networks:
      - file-optimizer-dev
    command: npm run worker
    stdin_open: true
    tty: true

  # Redis pour le d√©veloppement
  redis:
    image: redis:7-alpine
    container_name: file-optimizer-redis-dev
    ports:
      - "6379:6379"  # Port expos√© en dev pour debug
    command: redis-server --appendonly yes --loglevel debug
    volumes:
      - redis_data_dev:/data
    networks:
      - file-optimizer-dev

  # Frontend en mode d√©veloppement
  frontend-dev:
    image: nginx:alpine
    container_name: file-optimizer-frontend-dev
    ports:
      - "3000:80"
    volumes:
      # Montage direct du frontend pour hot reload
      - ./frontend:/usr/share/nginx/html:cached
      - ./nginx/nginx.dev.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app-dev
    networks:
      - file-optimizer-dev

  # Outil de d√©veloppement : Adminer pour Redis (optionnel)
  redis-gui:
    image: redislabs/redisinsight:latest
    container_name: redis-insight-dev
    ports:
      - "8001:8001"
    volumes:
      - redis_insight_data:/db
    networks:
      - file-optimizer-dev
    profiles:
      - debug

  # MailHog pour capturer emails en dev (optionnel)
  mailhog:
    image: mailhog/mailhog:latest
    container_name: file-optimizer-mailhog-dev
    ports:
      - "1025:1025"  # SMTP port
      - "8025:8025"  # Web UI port
    networks:
      - file-optimizer-dev
    profiles:
      - debug

volumes:
  uploads_dev:
    driver: local
  
  logs_dev:
    driver: local
  
  redis_data_dev:
    driver: local
  
  redis_insight_data:
    driver: local
  
  # Volume pour node_modules (√©vite conflits avec l'h√¥te)
  node_modules:
    driver: local

networks:
  file-optimizer-dev:
    driver: bridge
    name: file-optimizer-dev


================================================
File: backend/docker-compose.yml
================================================
# docker-compose.yml - Configuration PRODUCTION
version: '3.8'

services:
  # Application principale
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: file-optimizer-app
    restart: unless-stopped
    ports:
      - "${PORT:-8000}:8000"
    environment:
      - NODE_ENV=production
      - PORT=8000
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=info
      - CORS_ORIGIN=${CORS_ORIGIN:-http://localhost:3000}
      - UPLOAD_MAX_SIZE=${UPLOAD_MAX_SIZE:-5368709120}
      - WORKER_CONCURRENCY=${WORKER_CONCURRENCY:-2}
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
      - JWT_SECRET=${JWT_SECRET:-change-this-in-production}
      - CLEANUP_INTERVAL=3600
      - FILE_RETENTION=86400
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - file-optimizer
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Worker de traitement
  worker:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: file-optimizer-worker
    restart: unless-stopped
    command: npm run worker
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=info
      - WORKER_CONCURRENCY=${WORKER_CONCURRENCY:-2}
      - JOB_TIMEOUT=${JOB_TIMEOUT:-1800}
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - file-optimizer
    deploy:
      replicas: ${WORKER_REPLICAS:-1}
      resources:
        limits:
          memory: 2G
        reservations:
          memory: 512M

  # Redis pour la queue et le cache
  redis:
    image: redis:7-alpine
    container_name: file-optimizer-redis
    restart: unless-stopped
    command: >
      redis-server 
      --appendonly yes 
      --appendfsync everysec
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --save 900 1 300 10 60 10000
    volumes:
      - redis_data:/data
    networks:
      - file-optimizer
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 10s

  # Frontend (Nginx serving static files)
  frontend:
    image: nginx:alpine
    container_name: file-optimizer-frontend
    restart: unless-stopped
    ports:
      - "${FRONTEND_PORT:-3000}:80"
    volumes:
      - ./frontend:/usr/share/nginx/html:ro
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - file-optimizer

  # Monitoring avec Prometheus (optionnel)
  prometheus:
    image: prom/prometheus:latest
    container_name: file-optimizer-prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - file-optimizer
    profiles:
      - monitoring

  # Grafana pour la visualisation (optionnel)
  grafana:
    image: grafana/grafana:latest
    container_name: file-optimizer-grafana
    restart: unless-stopped
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning:ro
    networks:
      - file-optimizer
    profiles:
      - monitoring

volumes:
  uploads:
    driver: local
    driver_opts:
      type: none
      device: ${UPLOADS_PATH:-./uploads}
      o: bind
  
  logs:
    driver: local
    driver_opts:
      type: none
      device: ${LOGS_PATH:-./logs}
      o: bind
  
  redis_data:
    driver: local
  
  prometheus_data:
    driver: local
  
  grafana_data:
    driver: local

networks:
  file-optimizer:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16


================================================
File: backend/ecosystem.config.js
================================================
// ecosystem.config.js
// Configuration PM2 pour production et d√©ploiement

module.exports = {
  apps: [
    {
      name: 'file-optimizer-api',
      script: 'src/server.js',
      cwd: '/opt/file-optimizer/backend',
      instances: 'max',
      exec_mode: 'cluster',
      env: {
        NODE_ENV: 'production',
        PORT: 8000
      },
      env_production: {
        NODE_ENV: 'production',
        PORT: 8000,
        LOG_LEVEL: 'info',
        REDIS_URL: 'redis://localhost:6379',
        TEMP_DIR: '/opt/file-optimizer/uploads',
        LOG_DIR: '/opt/file-optimizer/logs'
      },
      env_staging: {
        NODE_ENV: 'staging',
        PORT: 8001,
        LOG_LEVEL: 'debug',
        REDIS_URL: 'redis://localhost:6379',
        TEMP_DIR: '/opt/file-optimizer-staging/uploads'
      },
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      error_file: '/opt/file-optimizer/logs/pm2-api-error.log',
      out_file: '/opt/file-optimizer/logs/pm2-api-out.log',
      log_file: '/opt/file-optimizer/logs/pm2-api-combined.log',
      merge_logs: true,
      max_memory_restart: '1G',
      node_args: '--max-old-space-size=1024',
      restart_delay: 5000,
      max_restarts: 10,
      min_uptime: '10s',
      listen_timeout: 8000,
      kill_timeout: 5000,
      wait_ready: true,
      autorestart: true,
      watch: false,
      ignore_watch: ['logs', 'uploads', 'tmp', 'node_modules'],
      source_map_support: false,
      instance_var: 'INSTANCE_ID'
    },
    {
      name: 'file-optimizer-worker',
      script: 'src/workers/processor.js',
      cwd: '/opt/file-optimizer/backend',
      instances: 2,
      exec_mode: 'fork',
      env: {
        NODE_ENV: 'production',
        WORKER_CONCURRENCY: 2
      },
      env_production: {
        NODE_ENV: 'production',
        LOG_LEVEL: 'info',
        WORKER_CONCURRENCY: 2,
        JOB_TIMEOUT: 1800,
        REDIS_URL: 'redis://localhost:6379',
        TEMP_DIR: '/opt/file-optimizer/uploads'
      },
      env_staging: {
        NODE_ENV: 'staging',
        LOG_LEVEL: 'debug',
        WORKER_CONCURRENCY: 1,
        REDIS_URL: 'redis://localhost:6379'
      },
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      error_file: '/opt/file-optimizer/logs/pm2-worker-error.log',
      out_file: '/opt/file-optimizer/logs/pm2-worker-out.log',
      log_file: '/opt/file-optimizer/logs/pm2-worker-combined.log',
      merge_logs: true,
      max_memory_restart: '2G',
      node_args: '--max-old-space-size=2048',
      restart_delay: 10000,
      max_restarts: 5,
      min_uptime: '30s',
      kill_timeout: 30000,
      autorestart: true,
      watch: false,
      ignore_watch: ['logs', 'uploads', 'tmp', 'node_modules']
    }
  ],

  deploy: {
    production: {
      user: 'deploy',
      host: ['server1.example.com', 'server2.example.com'],
      ref: 'origin/main',
      repo: 'https://github.com/your-username/file-optimizer.git',
      path: '/opt/file-optimizer',
      'pre-deploy-local': '',
      'post-deploy': 'cd backend && npm ci --only=production && pm2 reload ecosystem.config.js --env production',
      'pre-setup': 'mkdir -p /opt/file-optimizer/logs /opt/file-optimizer/uploads',
      'ssh_options': 'ForwardAgent=yes',
      env: {
        NODE_ENV: 'production'
      }
    },
    staging: {
      user: 'deploy',
      host: 'staging.example.com',
      ref: 'origin/develop',
      repo: 'https://github.com/your-username/file-optimizer.git',
      path: '/opt/file-optimizer-staging',
      'post-deploy': 'cd backend && npm ci && pm2 reload ecosystem.config.js --env staging',
      'pre-setup': 'mkdir -p /opt/file-optimizer-staging/logs /opt/file-optimizer-staging/uploads',
      env: {
        NODE_ENV: 'staging'
      }
    }
  }
};


================================================
File: backend/package.json
================================================
{
  "name": "file-optimizer-backend",
  "version": "2.0.0",
  "description": "Backend pour l'optimiseur de fichiers multim√©dia",
  "main": "src/server.js",
  "keywords": [
    "file-optimization",
    "image-compression",
    "video-compression",
    "multimedia",
    "ffmpeg",
    "sharp"
  ],
  "author": "File Optimizer Team",
  "license": "MIT",
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "worker": "node src/workers/processor.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    "format": "prettier --write src/**/*.js",
    "build": "echo 'No build step required for Node.js'",
    "clean": "rm -rf node_modules package-lock.json",
    "setup": "npm install && cp .env.example .env",
    "docker:build": "docker build -t file-optimizer-backend .",
    "docker:run": "docker run -p 8000:8000 file-optimizer-backend",
    "health": "node scripts/health-check.js",
    "migrate": "node scripts/migrate.js",
    "seed": "node scripts/seed.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "compression": "^1.7.4",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "socket.io": "^4.7.4",
    "redis": "^4.6.12",
    "bull": "^4.12.2",
    "sharp": "^0.33.1",
    "fluent-ffmpeg": "^2.1.2",
    "pdf-lib": "^1.17.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "uuid": "^9.0.1",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "dotenv": "^16.3.1",
    "mime-types": "^2.1.35",
    "file-type": "^18.7.0",
    "crypto": "^1.0.1",
    "fs-extra": "^11.2.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0",
    "supertest": "^6.3.3",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-node": "^11.1.0",
    "prettier": "^3.1.1",
    "@types/jest": "^29.5.8",
    "redis-mock": "^0.56.3"
  },
  "optionalDependencies": {
    "aws-sdk": "^2.1509.0",
    "@google-cloud/storage": "^7.7.0",
    "@sentry/node": "^7.85.0",
    "prom-client": "^15.1.0",
    "nodemailer": "^6.9.7"
  },
  "jest": {
    "testEnvironment": "node",
    "collectCoverageFrom": [
      "src/**/*.js",
      "!src/server.js",
      "!src/workers/**/*.js"
    ],
    "coverageDirectory": "coverage",
    "coverageReporters": [
      "text",
      "lcov",
      "html"
    ],
    "testMatch": [
      "**/tests/**/*.test.js",
      "**/src/**/__tests__/**/*.js"
    ]
  },
  "eslintConfig": {
    "env": {
      "node": true,
      "es2021": true,
      "jest": true
    },
    "extends": [
      "eslint:recommended",
      "plugin:node/recommended",
      "prettier"
    ],
    "parserOptions": {
      "ecmaVersion": 12,
      "sourceType": "module"
    },
    "rules": {
      "no-console": "warn",
      "no-unused-vars": "error",
      "prefer-const": "error",
      "no-var": "error"
    }
  },
  "prettier": {
    "singleQuote": true,
    "trailingComma": "es5",
    "tabWidth": 4,
    "semi": true,
    "printWidth": 100
  },
  "nodemonConfig": {
    "watch": [
      "src"
    ],
    "ext": "js,json",
    "ignore": [
      "src/**/*.test.js",
      "node_modules"
    ],
    "env": {
      "NODE_ENV": "development"
    }
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/your-username/file-optimizer.git"
  },
  "bugs": {
    "url": "https://github.com/your-username/file-optimizer/issues"
  },
  "homepage": "https://github.com/your-username/file-optimizer#readme"
}


================================================
File: backend/.env.example
================================================
# ===========================================
# üóúÔ∏è Optimiseur de Fichiers Multim√©dia
# Configuration des variables d'environnement
# ===========================================

# =================== SERVEUR ===================
# Port d'√©coute du serveur
PORT=8000

# Environnement (development, production, test)
NODE_ENV=development

# URL de base de l'application
APP_URL=http://localhost:8000

# Secret pour JWT et sessions
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production

# =================== REDIS ===================
# URL compl√®te Redis (prioritaire si d√©finie)
REDIS_URL=redis://localhost:6379

# Ou configuration d√©taill√©e
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DATABASE=0

# =================== STOCKAGE ===================
# R√©pertoire temporaire pour les uploads
TEMP_DIR=/tmp/uploads

# Taille maximale des uploads (en bytes)
UPLOAD_MAX_SIZE=5368709120

# Dur√©e de r√©tention des fichiers temporaires (en secondes)
FILE_RETENTION=86400

# Intervalle de nettoyage automatique (en secondes)
CLEANUP_INTERVAL=3600

# Type de stockage (local, s3, gcs)
STORAGE_TYPE=local

# =================== AWS S3 (si STORAGE_TYPE=s3) ===================
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=eu-west-1
S3_BUCKET=your-bucket-name
S3_ENDPOINT=

# =================== GOOGLE CLOUD (si STORAGE_TYPE=gcs) ===================
GOOGLE_CLOUD_PROJECT_ID=your-project-id
GOOGLE_CLOUD_KEY_FILE=path/to/service-account.json
GCS_BUCKET=your-bucket-name

# =================== FFMPEG ===================
# Chemin vers l'ex√©cutable FFmpeg
FFMPEG_PATH=/usr/bin/ffmpeg

# Chemin vers l'ex√©cutable FFprobe
FFPROBE_PATH=/usr/bin/ffprobe

# Nombre de threads FFmpeg (-1 = auto)
FFMPEG_THREADS=-1

# =================== IMAGEMAGICK ===================
# Chemin vers l'ex√©cutable ImageMagick (optionnel)
IMAGEMAGICK_PATH=/usr/bin/convert

# =================== LOGGING ===================
# Niveau de log (error, warn, info, http, debug)
LOG_LEVEL=info

# R√©pertoire des logs (production uniquement)
LOG_DIR=./logs

# =================== S√âCURIT√â ===================
# Origines CORS autoris√©es (s√©par√©es par des virgules)
CORS_ORIGIN=http://localhost:3000,http://localhost:8080

# Limite de requ√™tes par minute par IP
RATE_LIMIT=100

# Taille maximale du body des requ√™tes
BODY_LIMIT=10mb

# Activer HTTPS en production
HTTPS_ENABLED=false

# Chemins des certificats SSL (si HTTPS_ENABLED=true)
SSL_CERT_PATH=
SSL_KEY_PATH=

# =================== AUTHENTIFICATION ===================
# Activer l'authentification (false pour usage libre)
AUTH_ENABLED=false

# Cl√© API pour l'acc√®s (si AUTH_ENABLED=true)
API_KEY=your-api-key

# Dur√©e de validit√© des tokens JWT (en secondes)
JWT_EXPIRES_IN=86400

# =================== MONITORING ===================
# Activer les m√©triques Prometheus
METRICS_ENABLED=false

# Port pour les m√©triques (si diff√©rent du port principal)
METRICS_PORT=9090

# Activer Sentry pour le monitoring des erreurs
SENTRY_DSN=

# =================== WORKERS ===================
# Nombre de workers pour le traitement
WORKER_CONCURRENCY=2

# D√©lai maximum pour un job (en secondes)
JOB_TIMEOUT=1800

# Nombre de tentatives en cas d'√©chec
JOB_ATTEMPTS=3

# =================== COMPRESSION ===================
# ===== Images =====
# Qualit√© par d√©faut pour les images (1-100)
DEFAULT_IMAGE_QUALITY=80

# R√©solution maximale par d√©faut
DEFAULT_MAX_WIDTH=1920
DEFAULT_MAX_HEIGHT=1080

# Format par d√©faut ('auto' pour conserver l'original)
DEFAULT_IMAGE_FORMAT=auto

# ===== Vid√©os =====
# Codec vid√©o par d√©faut
DEFAULT_VIDEO_CODEC=h264

# CRF par d√©faut (18-51, plus bas = meilleure qualit√©)
DEFAULT_VIDEO_CRF=23

# Preset FFmpeg par d√©faut
DEFAULT_VIDEO_PRESET=medium

# Bitrate maximum par d√©faut
DEFAULT_VIDEO_BITRATE=2M

# ===== Audio =====
# Codec audio par d√©faut
DEFAULT_AUDIO_CODEC=aac

# Bitrate audio par d√©faut
DEFAULT_AUDIO_BITRATE=128k

# Fr√©quence d'√©chantillonnage par d√©faut
DEFAULT_AUDIO_SAMPLE_RATE=44100

# ===== Documents =====
# Qualit√© par d√©faut pour les PDFs (1-100)
DEFAULT_PDF_QUALITY=80

# =================== D√âVELOPPEMENT ===================
# Activer le mode debug
DEBUG=false

# Conserver les fichiers temporaires (utile pour debug)
KEEP_TEMP_FILES=false

# Activer les logs d√©taill√©s
VERBOSE_LOGS=false

# Port pour le hot reload (d√©veloppement)
DEV_PORT=3000

# =================== DOCKER ===================
# Configuration pour Docker Compose
COMPOSE_PROJECT_NAME=file-optimizer

# Version de l'image Docker
DOCKER_TAG=latest

# =================== BACKUP ===================
# Activer les sauvegardes automatiques
BACKUP_ENABLED=false

# R√©pertoire de sauvegarde
BACKUP_DIR=./backups

# Intervalle de sauvegarde (en secondes)
BACKUP_INTERVAL=86400

# Nombre de sauvegardes √† conserver
BACKUP_RETENTION=7

# =================== HEALTH CHECK ===================
# Intervalle de v√©rification de sant√© (en secondes)
HEALTH_CHECK_INTERVAL=30

# Timeout pour les v√©rifications (en secondes)
HEALTH_CHECK_TIMEOUT=5

# =================== PERFORMANCE ===================
# Limite m√©moire pour Sharp (en MB)
SHARP_MEMORY_LIMIT=512

# Cache Sharp (true/false)
SHARP_CACHE=true

# Limite de concurrence Sharp
SHARP_CONCURRENCY=4

# =================== WEBHOOKS ===================
# URL de webhook pour notifications (optionnel)
WEBHOOK_URL=

# Secret pour signer les webhooks
WEBHOOK_SECRET=

# =================== NOTIFICATIONS ===================
# Configuration email (pour notifications d'erreurs)
SMTP_HOST=
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
SMTP_FROM=noreply@file-optimizer.local

# Configuration Slack (pour notifications)
SLACK_WEBHOOK_URL=
SLACK_CHANNEL=#file-optimizer

# =================== ANALYTICS ===================
# Google Analytics ID (optionnel)
GA_TRACKING_ID=

# Activer la collecte de statistiques anonymes
ANALYTICS_ENABLED=false

# =================== EXEMPLES DE VALEURS ===================
# Exemple pour un environnement de d√©veloppement local :
# PORT=8000
# NODE_ENV=development
# REDIS_URL=redis://localhost:6379
# TEMP_DIR=/tmp/uploads
# LOG_LEVEL=debug
# CORS_ORIGIN=http://localhost:3000

# Exemple pour un environnement de production :
# PORT=8000
# NODE_ENV=production
# REDIS_URL=redis://prod-redis:6379
# TEMP_DIR=/app/uploads
# LOG_LEVEL=info
# CORS_ORIGIN=https://your-domain.com
# HTTPS_ENABLED=true
# SSL_CERT_PATH=/etc/ssl/certs/cert.pem
# SSL_KEY_PATH=/etc/ssl/private/key.pem


================================================
File: backend/scripts/deploy-production.sh
================================================
#!/bin/bash
# scripts/deploy-production.sh
# Script de d√©ploiement en production

set -e

echo "üöÄ D√©ploiement File Optimizer en production"

# Configuration
REPO_URL="https://github.com/your-username/file-optimizer.git"
DEPLOY_DIR="/opt/file-optimizer"
BACKUP_DIR="/opt/backups/file-optimizer"
SERVICE_NAME="file-optimizer"
BRANCH="main"

# Couleurs pour les logs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# V√©rifier les pr√©requis
check_prerequisites() {
    log_info "V√©rification des pr√©requis..."
    
    # Node.js
    if ! command -v node &> /dev/null; then
        log_error "Node.js n'est pas install√©"
        exit 1
    fi
    
    local node_version=$(node --version | cut -d'v' -f2)
    local major_version=$(echo $node_version | cut -d'.' -f1)
    if [ "$major_version" -lt 16 ]; then
        log_error "Node.js version >= 16 requise (actuelle: $node_version)"
        exit 1
    fi
    
    # Docker
    if ! command -v docker &> /dev/null; then
        log_error "Docker n'est pas install√©"
        exit 1
    fi
    
    # Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose n'est pas install√©"
        exit 1
    fi
    
    # Git
    if ! command -v git &> /dev/null; then
        log_error "Git n'est pas install√©"
        exit 1
    fi
    
    # V√©rifier l'espace disque (minimum 5GB)
    local available_space=$(df /opt 2>/dev/null | awk 'NR==2 {print $4}' || echo "0")
    if [ "$available_space" -lt 5242880 ]; then # 5GB en KB
        log_warn "Espace disque faible (moins de 5GB disponible)"
    fi
    
    log_success "Pr√©requis v√©rifi√©s"
}

# Cr√©er sauvegarde
create_backup() {
    log_info "Cr√©ation de la sauvegarde..."
    
    if [ -d "$DEPLOY_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
        BACKUP_FILE="$BACKUP_DIR/backup-$(date +%Y%m%d-%H%M%S).tar.gz"
        
        # Cr√©er la sauvegarde en excluant les gros r√©pertoires
        tar -czf "$BACKUP_FILE" -C "$DEPLOY_DIR" . \
            --exclude=node_modules \
            --exclude=uploads \
            --exclude=logs \
            --exclude=.git \
            --exclude=tmp \
            2>/dev/null || true
        
        if [ -f "$BACKUP_FILE" ]; then
            log_success "Sauvegarde cr√©√©e: $BACKUP_FILE"
        else
            log_warn "√âchec cr√©ation sauvegarde"
        fi
    else
        log_warn "Aucun d√©ploiement existant √† sauvegarder"
    fi
}

# Arr√™ter les services en cours
stop_services() {
    log_info "Arr√™t des services existants..."
    
    # Arr√™ter Docker Compose si en cours
    if [ -f "$DEPLOY_DIR/docker-compose.yml" ]; then
        cd "$DEPLOY_DIR"
        docker-compose down 2>/dev/null || true
        log_info "Services Docker arr√™t√©s"
    fi
    
    # Arr√™ter PM2 si en cours
    if command -v pm2 &> /dev/null; then
        pm2 stop ecosystem.config.js 2>/dev/null || true
        log_info "Services PM2 arr√™t√©s"
    fi
}

# Cloner ou mettre √† jour le repository
update_code() {
    log_info "Mise √† jour du code..."
    
    if [ -d "$DEPLOY_DIR/.git" ]; then
        cd "$DEPLOY_DIR"
        git fetch origin --quiet
        git checkout "$BRANCH" --quiet
        git reset --hard "origin/$BRANCH" --quiet
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Code mis √† jour depuis Git (commit: $commit_hash)"
    else
        # Cr√©er le r√©pertoire parent si n√©cessaire
        mkdir -p "$(dirname "$DEPLOY_DIR")"
        git clone --branch "$BRANCH" "$REPO_URL" "$DEPLOY_DIR" --quiet
        cd "$DEPLOY_DIR"
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Repository clon√© (commit: $commit_hash)"
    fi
}

# Installer les d√©pendances
install_dependencies() {
    log_info "Installation des d√©pendances..."
    cd "$DEPLOY_DIR/backend"
    
    # Nettoyer node_modules existants
    if [ -d "node_modules" ]; then
        rm -rf node_modules package-lock.json
        log_info "Anciens node_modules supprim√©s"
    fi
    
    # Installation propre
    npm ci --only=production --silent
    
    log_success "D√©pendances install√©es"
}

# Configuration de l'environnement
setup_environment() {
    log_info "Configuration de l'environnement..."
    cd "$DEPLOY_DIR/backend"
    
    # Copier la configuration si elle n'existe pas
    if [ ! -f ".env" ]; then
        cp .env.example .env
        log_warn "Fichier .env cr√©√© depuis .env.example"
        log_warn "‚ö†Ô∏è  Configurer manuellement les variables dans .env"
    fi
    
    # Cr√©er les r√©pertoires n√©cessaires
    mkdir -p uploads logs tmp
    chmod 755 uploads logs tmp
    
    # Cr√©er les r√©pertoires au niveau syst√®me si n√©cessaire
    sudo mkdir -p /opt/file-optimizer/uploads /opt/file-optimizer/logs 2>/dev/null || true
    sudo chown -R $USER:$USER /opt/file-optimizer 2>/dev/null || true
    
    log_success "Environnement configur√©"
}

# D√©marrer les services
start_services() {
    log_info "D√©marrage des services..."
    cd "$DEPLOY_DIR"
    
    # Choisir la m√©thode de d√©ploiement
    if [ "$DEPLOY_METHOD" = "pm2" ] && command -v pm2 &> /dev/null; then
        start_pm2_services
    else
        start_docker_services
    fi
}

# D√©marrer avec Docker Compose
start_docker_services() {
    log_info "D√©marrage avec Docker Compose..."
    
    # Pull des derni√®res images
    docker-compose pull --quiet
    
    # D√©marrer les services
    docker-compose up -d
    
    # Attendre que les services soient pr√™ts
    log_info "Attente du d√©marrage des services..."
    sleep 15
    
    # V√©rifier que les conteneurs sont en cours d'ex√©cution
    if docker-compose ps | grep -q "Up"; then
        log_success "Services Docker d√©marr√©s"
    else
        log_error "√âchec du d√©marrage des services Docker"
        docker-compose logs
        exit 1
    fi
}

# D√©marrer avec PM2
start_pm2_services() {
    log_info "D√©marrage avec PM2..."
    cd "$DEPLOY_DIR/backend"
    
    # D√©marrer avec PM2
    pm2 start ecosystem.config.js --env production
    
    # Sauvegarder la configuration PM2
    pm2 save
    
    log_success "Services PM2 d√©marr√©s"
}

# Tests post-d√©ploiement
run_health_checks() {
    log_info "Tests de sant√© post-d√©ploiement..."
    
    # Attendre un peu plus pour s'assurer que tout est pr√™t
    sleep 10
    
    # D√©terminer le port selon la m√©thode de d√©ploiement
    local port=8000
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f "http://localhost:$port/api/health" >/dev/null 2>&1; then
            log_success "API op√©rationnelle sur le port $port"
            break
        else
            if [ $attempt -eq $max_attempts ]; then
                log_error "API non accessible apr√®s $max_attempts tentatives"
                # Afficher les logs pour diagnostic
                if [ "$DEPLOY_METHOD" = "pm2" ]; then
                    pm2 logs --lines 20
                else
                    docker-compose logs --tail=20
                fi
                exit 1
            fi
            log_info "Tentative $attempt/$max_attempts - Attente de l'API..."
            sleep 2
            attempt=$((attempt + 1))
        fi
    done
    
    # Test de sant√© d√©taill√©
    local health_response=$(curl -s "http://localhost:$port/api/health" 2>/dev/null || echo "")
    if echo "$health_response" | grep -q '"status":"ok"'; then
        log_success "Health check d√©taill√© r√©ussi"
    else
        log_warn "Health check d√©taill√© partiel"
    fi
    
    # Test Redis si Docker
    if [ "$DEPLOY_METHOD" != "pm2" ]; then
        if docker exec file-optimizer-redis redis-cli ping 2>/dev/null | grep -q "PONG"; then
            log_success "Redis op√©rationnel"
        else
            log_warn "Redis non accessible (peut √™tre normal si externe)"
        fi
    fi
    
    log_success "Tous les tests de sant√© essentiels pass√©s"
}

# Nettoyage post-d√©ploiement
cleanup() {
    log_info "Nettoyage post-d√©ploiement..."
    
    # Nettoyer les anciennes images Docker
    if [ "$DEPLOY_METHOD" != "pm2" ]; then
        docker image prune -f >/dev/null 2>&1 || true
    fi
    
    # Nettoyer les anciennes sauvegardes (garder les 5 derni√®res)
    if [ -d "$BACKUP_DIR" ]; then
        ls -t "$BACKUP_DIR"/backup-*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm
    fi
    
    log_success "Nettoyage termin√©"
}

# Afficher les informations finales
show_deployment_info() {
    log_success "üéâ D√©ploiement production termin√© avec succ√®s!"
    echo ""
    echo "üìç Informations de d√©ploiement:"
    echo "   Application: http://localhost:8000"
    echo "   Health check: http://localhost:8000/api/health"
    echo "   API Documentation: http://localhost:8000/docs"
    echo ""
    echo "üìã Commandes utiles:"
    if [ "$DEPLOY_METHOD" = "pm2" ]; then
        echo "   Logs: pm2 logs"
        echo "   Status: pm2 status"
        echo "   Restart: pm2 restart ecosystem.config.js"
    else
        echo "   Logs: docker-compose logs -f"
        echo "   Status: docker-compose ps"
        echo "   Restart: docker-compose restart"
    fi
    echo "   Health: curl http://localhost:8000/api/health"
    echo ""
}

# Fonction de rollback en cas d'erreur
rollback() {
    log_error "Erreur d√©tect√©e, tentative de rollback..."
    
    # Trouver la derni√®re sauvegarde
    if [ -d "$BACKUP_DIR" ]; then
        local latest_backup=$(ls -t "$BACKUP_DIR"/backup-*.tar.gz 2>/dev/null | head -n1)
        if [ -n "$latest_backup" ]; then
            log_info "Restauration depuis: $latest_backup"
            cd "$DEPLOY_DIR"
            tar -xzf "$latest_backup" 2>/dev/null || true
            start_services
            log_warn "Rollback effectu√©, v√©rifiez l'√©tat du service"
        fi
    fi
}

# Fonction principale
main() {
    log_info "D√©but du d√©ploiement production"
    echo "========================================"
    
    # D√©terminer la m√©thode de d√©ploiement
    DEPLOY_METHOD=${DEPLOY_METHOD:-docker}
    log_info "M√©thode de d√©ploiement: $DEPLOY_METHOD"
    
    check_prerequisites
    create_backup
    stop_services
    update_code
    install_dependencies
    setup_environment
    start_services
    run_health_checks
    cleanup
    show_deployment_info
}

# Gestion des erreurs avec rollback
trap 'rollback; exit 1' ERR

# Parse des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --method)
            DEPLOY_METHOD="$2"
            shift 2
            ;;
        --branch)
            BRANCH="$2"
            shift 2
            ;;
        --help)
            echo "Usage: $0 [--method docker|pm2] [--branch main|develop]"
            echo "  --method: M√©thode de d√©ploiement (default: docker)"
            echo "  --branch: Branche Git √† d√©ployer (default: main)"
            exit 0
            ;;
        *)
            log_warn "Option inconnue: $1"
            shift
            ;;
    esac
done

# Ex√©cution
main "$@"


================================================
File: backend/scripts/deploy-staging.sh
================================================
#!/bin/bash
# scripts/deploy-staging.sh
# Script de d√©ploiement en staging pour tests

set -e

echo "üîß D√©ploiement File Optimizer en staging"

# Configuration staging
REPO_URL="https://github.com/your-username/file-optimizer.git"
DEPLOY_DIR="/opt/file-optimizer-staging"
BRANCH="develop"
PORT="8001"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() {
    echo -e "${BLUE}[STAGING]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# V√©rification des pr√©requis simplifi√©e
check_prerequisites() {
    log_info "V√©rification des pr√©requis staging..."
    
    if ! command -v node &> /dev/null; then
        log_error "Node.js non install√©"
        exit 1
    fi
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker non install√©"
        exit 1
    fi
    
    if ! command -v git &> /dev/null; then
        log_error "Git non install√©"
        exit 1
    fi
    
    log_success "Pr√©requis OK"
}

# Nettoyer l'environnement staging pr√©c√©dent
cleanup_previous() {
    log_info "Nettoyage environnement staging pr√©c√©dent..."
    
    if [ -d "$DEPLOY_DIR" ]; then
        cd "$DEPLOY_DIR"
        
        # Arr√™ter les conteneurs staging
        docker-compose -f docker-compose.dev.yml down 2>/dev/null || true
        
        # Nettoyer les volumes staging (optionnel)
        docker volume rm file-optimizer-staging_uploads_dev 2>/dev/null || true
        docker volume rm file-optimizer-staging_redis_data_dev 2>/dev/null || true
        
        log_info "Environnement pr√©c√©dent nettoy√©"
    fi
}

# Mettre √† jour le code
update_code() {
    log_info "Mise √† jour du code depuis la branche $BRANCH..."
    
    if [ -d "$DEPLOY_DIR/.git" ]; then
        cd "$DEPLOY_DIR"
        git fetch origin --quiet
        git checkout "$BRANCH" --quiet
        git reset --hard "origin/$BRANCH" --quiet
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Code mis √† jour (commit: $commit_hash)"
    else
        mkdir -p "$(dirname "$DEPLOY_DIR")"
        git clone -b "$BRANCH" "$REPO_URL" "$DEPLOY_DIR" --quiet
        cd "$DEPLOY_DIR"
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Repository clon√© (commit: $commit_hash)"
    fi
}

# Configuration de l'environnement staging
setup_staging_environment() {
    log_info "Configuration environnement staging..."
    cd "$DEPLOY_DIR/backend"
    
    # Cr√©er un .env sp√©cifique au staging
    cat > .env << EOF
# Configuration Staging
NODE_ENV=staging
PORT=$PORT
LOG_LEVEL=debug

# Redis
REDIS_URL=redis://redis:6379

# Stockage
TEMP_DIR=/app/uploads
UPLOAD_MAX_SIZE=1073741824

# CORS permissif pour staging
CORS_ORIGIN=*

# Rate limiting d√©sactiv√© en staging
SKIP_RATE_LIMIT=true

# Nettoyage plus fr√©quent
CLEANUP_INTERVAL=1800
FILE_RETENTION=3600

# Worker
WORKER_CONCURRENCY=1
JOB_TIMEOUT=900
EOF
    
    # Cr√©er les r√©pertoires
    mkdir -p uploads logs tmp
    chmod 755 uploads logs tmp
    
    log_success "Environnement staging configur√©"
}

# D√©marrer les services staging
start_staging_services() {
    log_info "D√©marrage des services staging..."
    cd "$DEPLOY_DIR"
    
    # Modifier le docker-compose.dev.yml pour staging
    export COMPOSE_PROJECT_NAME=file-optimizer-staging
    export PORT=$PORT
    
    # D√©marrer avec Docker Compose d√©veloppement
    docker-compose -f docker-compose.dev.yml up -d
    
    log_info "Attente du d√©marrage des services..."
    sleep 20
}

# Tests de sant√© staging
run_staging_tests() {
    log_info "Tests de sant√© staging..."
    
    local max_attempts=20
    local attempt=1
    
    # Test de l'API
    while [ $attempt -le $max_attempts ]; do
        if curl -f "http://localhost:$PORT/api/health" >/dev/null 2>&1; then
            log_success "API staging op√©rationnelle sur le port $PORT"
            break
        else
            if [ $attempt -eq $max_attempts ]; then
                log_error "API staging non accessible apr√®s $max_attempts tentatives"
                
                # Afficher les logs pour diagnostic
                log_info "Logs des conteneurs staging:"
                docker-compose -f docker-compose.dev.yml logs --tail=20
                exit 1
            fi
            log_info "Tentative $attempt/$max_attempts..."
            sleep 3
            attempt=$((attempt + 1))
        fi
    done
    
    # Test de sant√© d√©taill√©
    local health_response=$(curl -s "http://localhost:$PORT/api/health" 2>/dev/null)
    if echo "$health_response" | grep -q '"status":"ok"'; then
        log_success "Health check d√©taill√© r√©ussi"
        
        # Afficher quelques infos de la r√©ponse
        echo "$health_response" | jq -r '.checks | to_entries[] | "\(.key): \(.value.status)"' 2>/dev/null || true
    else
        log_warn "Health check partiel"
    fi
    
    # Test d'upload simple
    test_upload_functionality
}

# Test d'upload simple pour validation
test_upload_functionality() {
    log_info "Test de fonctionnalit√© upload..."
    
    # Cr√©er un fichier de test temporaire
    local test_file="/tmp/test-staging-$(date +%s).txt"
    echo "Test file for staging deployment" > "$test_file"
    
    # Tester l'upload
    local upload_response=$(curl -s -X POST \
        -F "file=@$test_file" \
        -F 'settings={"quality":80}' \
        "http://localhost:$PORT/api/upload" 2>/dev/null || echo "")
    
    if echo "$upload_response" | grep -q '"success":true'; then
        local job_id=$(echo "$upload_response" | jq -r '.jobId' 2>/dev/null || echo "")
        log_success "Upload test r√©ussi (jobId: ${job_id:0:8}...)"
        
        # Test de r√©cup√©ration du statut
        if [ -n "$job_id" ]; then
            sleep 2
            local status_response=$(curl -s "http://localhost:$PORT/api/status/$job_id" 2>/dev/null || echo "")
            if echo "$status_response" | grep -q '"success":true'; then
                log_success "API status op√©rationnelle"
            fi
        fi
    else
        log_warn "Test upload √©chou√© (peut √™tre normal selon la configuration)"
    fi
    
    # Nettoyer
    rm -f "$test_file"
}

# Afficher les informations de staging
show_staging_info() {
    log_success "üéâ D√©ploiement staging termin√©!"
    echo ""
    echo "üìç Informations staging:"
    echo "   Application: http://localhost:$PORT"
    echo "   Health check: http://localhost:$PORT/api/health"
    echo "   API Upload: http://localhost:$PORT/api/upload"
    echo "   Branche: $BRANCH"
    echo ""
    echo "üìã Commandes utiles staging:"
    echo "   Logs: docker-compose -f docker-compose.dev.yml logs -f"
    echo "   Status: docker-compose -f docker-compose.dev.yml ps"
    echo "   Stop: docker-compose -f docker-compose.dev.yml down"
    echo "   Restart: docker-compose -f docker-compose.dev.yml restart"
    echo ""
    echo "üß™ Tests rapides:"
    echo "   curl http://localhost:$PORT/api/health"
    echo "   curl http://localhost:$PORT/api/upload/info"
    echo ""
}

# Fonction principale
main() {
    log_info "D√©but du d√©ploiement staging"
    echo "========================================"
    
    check_prerequisites
    cleanup_previous
    update_code
    setup_staging_environment
    start_staging_services
    run_staging_tests
    show_staging_info
    
    log_success "‚ú® Staging pr√™t pour les tests!"
}

# Gestion des erreurs
trap 'log_error "Erreur lors du d√©ploiement staging ligne $LINENO"; exit 1' ERR

# Parse des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --branch)
            BRANCH="$2"
            shift 2
            ;;
        --port)
            PORT="$2"
            shift 2
            ;;
        --clean)
            log_info "Nettoyage complet demand√©"
            docker-compose -f docker-compose.dev.yml down -v 2>/dev/null || true
            docker system prune -f >/dev/null 2>&1 || true
            shift
            ;;
        --help)
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  --branch BRANCH    Branche √† d√©ployer (default: develop)"
            echo "  --port PORT        Port d'√©coute (default: 8001)" 
            echo "  --clean            Nettoyage complet avant d√©ploiement"
            echo "  --help             Afficher cette aide"
            exit 0
            ;;
        *)
            log_warn "Option inconnue: $1"
            shift
            ;;
    esac
done

# Ex√©cution
main "$@"


================================================
File: backend/scripts/health-check.sh
================================================
#!/bin/bash
# scripts/health-check.sh
# Script de v√©rification de sant√© compl√®te du syst√®me

set -e

# Configuration
API_URL="${API_URL:-http://localhost:8000}"
VERBOSE="${1:-false}"
TIMEOUT=10
REDIS_HOST="${REDIS_HOST:-localhost}"
REDIS_PORT="${REDIS_PORT:-6379}"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Variables globales pour le r√©sultat
OVERALL_STATUS=0
CHECKS_PERFORMED=0
CHECKS_PASSED=0

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[‚úì]${NC} $1"
    CHECKS_PASSED=$((CHECKS_PASSED + 1))
}

log_warn() {
    echo -e "${YELLOW}[‚ö†]${NC} $1"
}

log_error() {
    echo -e "${RED}[‚úó]${NC} $1"
    OVERALL_STATUS=1
}

log_check() {
    echo -e "${PURPLE}[CHECK]${NC} $1"
    CHECKS_PERFORMED=$((CHECKS_PERFORMED + 1))
}

# V√©rifier l'API principale
check_api() {
    log_check "API principale"
    
    local response
    local http_code
    local response_time
    
    # Mesurer le temps de r√©ponse
    local start_time=$(date +%s%N)
    response=$(curl -s -w "%{http_code}" --max-time $TIMEOUT "$API_URL/api/health" 2>/dev/null || echo "000")
    local end_time=$(date +%s%N)
    response_time=$(( (end_time - start_time) / 1000000 )) # en millisecondes
    
    http_code="${response: -3}"
    local body="${response%???}"
    
    if [ "$http_code" = "200" ]; then
        log_success "API op√©rationnelle (${response_time}ms)"
        
        # Analyser la r√©ponse si verbose
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Response body:"
            echo "$body" | jq . 2>/dev/null || echo "   $body"
            
            # Extraire des m√©triques de la r√©ponse
            local status=$(echo "$body" | jq -r '.status' 2>/dev/null || echo "unknown")
            local uptime=$(echo "$body" | jq -r '.uptime' 2>/dev/null || echo "unknown")
            echo "   Status: $status, Uptime: ${uptime}s"
        fi
        
        # V√©rifier que le statut est "ok"
        if echo "$body" | grep -q '"status":"ok"'; then
            log_success "Health check interne: OK"
        else
            log_warn "Health check interne: √âtat d√©grad√©"
        fi
        
        return 0
    else
        log_error "API non op√©rationnelle (HTTP $http_code)"
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   URL test√©e: $API_URL/api/health"
            echo "   R√©ponse: $response"
        fi
        return 1
    fi
}

# V√©rifier Redis
check_redis() {
    log_check "Redis"
    
    # Essayer avec redis-cli local d'abord
    if command -v redis-cli &> /dev/null; then
        if timeout $TIMEOUT redis-cli -h $REDIS_HOST -p $REDIS_PORT ping 2>/dev/null | grep -q "PONG"; then
            log_success "Redis op√©rationnel (redis-cli)"
            
            if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
                local redis_info=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT info server 2>/dev/null | head -5)
                echo "   Redis info:"
                echo "$redis_info" | sed 's/^/   /'
            fi
            return 0
        fi
    fi
    
    # Essayer avec Docker si redis-cli non disponible
    if command -v docker &> /dev/null; then
        if docker exec file-optimizer-redis redis-cli ping 2>/dev/null | grep -q "PONG"; then
            log_success "Redis op√©rationnel (Docker)"
            return 0
        fi
    fi
    
    # Essayer avec netcat pour tester la connectivit√©
    if command -v nc &> /dev/null; then
        if timeout $TIMEOUT nc -z $REDIS_HOST $REDIS_PORT 2>/dev/null; then
            log_warn "Redis port accessible mais ping √©chou√©"
            return 1
        fi
    fi
    
    log_error "Redis non op√©rationnel"
    return 1
}

# V√©rifier Docker
check_docker() {
    log_check "Services Docker"
    
    if ! command -v docker &> /dev/null; then
        log_warn "Docker non install√© (normal si d√©ploiement PM2)"
        return 0
    fi
    
    # V√©rifier que Docker est en cours d'ex√©cution
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker daemon non accessible"
        return 1
    fi
    
    # V√©rifier les conteneurs file-optimizer
    local containers=$(docker ps --filter "name=file-optimizer" --format "{{.Names}}" 2>/dev/null || echo "")
    
    if [ -n "$containers" ]; then
        log_success "Conteneurs Docker actifs"
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Conteneurs trouv√©s:"
            echo "$containers" | sed 's/^/   - /'
            
            # Status d√©taill√© des conteneurs
            docker ps --filter "name=file-optimizer" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | sed 's/^/   /'
        fi
        
        # V√©rifier que les conteneurs sont "healthy" si health check configur√©
        local unhealthy=$(docker ps --filter "name=file-optimizer" --filter "health=unhealthy" --format "{{.Names}}" 2>/dev/null || echo "")
        if [ -n "$unhealthy" ]; then
            log_warn "Conteneurs en mauvaise sant√©: $unhealthy"
            return 1
        fi
        
        return 0
    else
        log_warn "Aucun conteneur file-optimizer actif"
        return 1
    fi
}

# V√©rifier l'espace disque
check_disk_space() {
    log_check "Espace disque"
    
    # V√©rifier le r√©pertoire de d√©ploiement
    local deploy_paths=("/opt/file-optimizer" "/opt/file-optimizer-staging" ".")
    
    for path in "${deploy_paths[@]}"; do
        if [ -d "$path" ]; then
            local usage=$(df "$path" 2>/dev/null | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
            local available=$(df -h "$path" 2>/dev/null | awk 'NR==2 {print $4}' || echo "unknown")
            
            if [ "$usage" -lt 80 ]; then
                log_success "Espace disque OK: ${usage}% utilis√© ($available disponible) - $path"
            elif [ "$usage" -lt 90 ]; then
                log_warn "Espace disque √©lev√©: ${usage}% utilis√© ($available disponible) - $path"
            else
                log_error "Espace disque critique: ${usage}% utilis√© ($available disponible) - $path"
                return 1
            fi
            
            if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
                echo "   D√©tails $path:"
                df -h "$path" | sed 's/^/   /'
            fi
            break
        fi
    done
    
    return 0
}

# V√©rifier la m√©moire syst√®me
check_memory() {
    log_check "Utilisation m√©moire"
    
    if [ -f /proc/meminfo ]; then
        local total_mem=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        local available_mem=$(grep MemAvailable /proc/meminfo | awk '{print $2}' 2>/dev/null || grep MemFree /proc/meminfo | awk '{print $2}')
        local used_mem=$((total_mem - available_mem))
        local usage_percent=$((used_mem * 100 / total_mem))
        
        # Convertir en GB pour affichage
        local total_gb=$((total_mem / 1024 / 1024))
        local used_gb=$((used_mem / 1024 / 1024))
        local available_gb=$((available_mem / 1024 / 1024))
        
        if [ "$usage_percent" -lt 80 ]; then
            log_success "M√©moire OK: ${usage_percent}% utilis√© (${used_gb}G/${total_gb}G)"
        elif [ "$usage_percent" -lt 90 ]; then
            log_warn "M√©moire √©lev√©e: ${usage_percent}% utilis√© (${used_gb}G/${total_gb}G)"
        else
            log_error "M√©moire critique: ${usage_percent}% utilis√© (${used_gb}G/${total_gb}G)"
            return 1
        fi
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Total: ${total_gb}G, Utilis√©: ${used_gb}G, Disponible: ${available_gb}G"
        fi
    else
        log_warn "Impossible de lire /proc/meminfo"
    fi
    
    return 0
}

# V√©rifier les processus PM2
check_pm2() {
    log_check "Processus PM2"
    
    if ! command -v pm2 &> /dev/null; then
        log_warn "PM2 non install√© (normal si d√©ploiement Docker)"
        return 0
    fi
    
    local pm2_list=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name | test("file-optimizer")) | "\(.name): \(.pm2_env.status)"' 2>/dev/null || echo "")
    
    if [ -n "$pm2_list" ]; then
        local all_online=true
        while IFS= read -r line; do
            if echo "$line" | grep -q ": online"; then
                log_success "PM2 process: $line"
            else
                log_error "PM2 process: $line"
                all_online=false
            fi
        done <<< "$pm2_list"
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   PM2 status d√©taill√©:"
            pm2 status | grep -E "(file-optimizer|Process)" | sed 's/^/   /'
        fi
        
        if $all_online; then
            return 0
        else
            return 1
        fi
    else
        log_warn "Aucun processus file-optimizer dans PM2"
        return 1
    fi
}

# V√©rifier les endpoints critiques
check_endpoints() {
    log_check "Endpoints critiques"
    
    local endpoints=(
        "/api/health"
        "/api/upload/info"
        "/"
    )
    
    local failed_endpoints=()
    
    for endpoint in "${endpoints[@]}"; do
        local url="$API_URL$endpoint"
        local http_code=$(curl -s -w "%{http_code}" --max-time $TIMEOUT "$url" -o /dev/null 2>/dev/null || echo "000")
        
        if [ "$http_code" = "200" ]; then
            log_success "Endpoint OK: $endpoint (HTTP $http_code)"
        else
            log_error "Endpoint KO: $endpoint (HTTP $http_code)"
            failed_endpoints+=("$endpoint")
        fi
    done
    
    if [ ${#failed_endpoints[@]} -eq 0 ]; then
        return 0
    else
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Endpoints en √©chec: ${failed_endpoints[*]}"
        fi
        return 1
    fi
}

# Test de performance simple
check_performance() {
    log_check "Performance API"
    
    local total_time=0
    local requests=5
    local failed=0
    
    for i in $(seq 1 $requests); do
        local start_time=$(date +%s%N)
        local http_code=$(curl -s -w "%{http_code}" --max-time $TIMEOUT "$API_URL/api/health" -o /dev/null 2>/dev/null || echo "000")
        local end_time=$(date +%s%N)
        local response_time=$(( (end_time - start_time) / 1000000 ))
        
        if [ "$http_code" = "200" ]; then
            total_time=$((total_time + response_time))
        else
            failed=$((failed + 1))
        fi
    done
    
    if [ $failed -lt $((requests / 2)) ]; then
        local avg_time=$((total_time / (requests - failed)))
        if [ $avg_time -lt 1000 ]; then
            log_success "Performance OK: ${avg_time}ms moyenne ($failed √©checs sur $requests)"
        elif [ $avg_time -lt 3000 ]; then
            log_warn "Performance lente: ${avg_time}ms moyenne ($failed √©checs sur $requests)"
        else
            log_error "Performance critique: ${avg_time}ms moyenne ($failed √©checs sur $requests)"
            return 1
        fi
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Tests: $requests, √âchecs: $failed, Temps moyen: ${avg_time}ms"
        fi
        return 0
    else
        log_error "Performance critique: trop d'√©checs ($failed sur $requests)"
        return 1
    fi
}

# Afficher le r√©sum√© final
show_summary() {
    echo ""
    echo "========================================"
    echo "üìä R√âSUM√â DU HEALTH CHECK"
    echo "========================================"
    echo "Checks effectu√©s: $CHECKS_PERFORMED"
    echo "Checks r√©ussis: $CHECKS_PASSED"
    echo "Checks √©chou√©s: $((CHECKS_PERFORMED - CHECKS_PASSED))"
    echo ""
    
    if [ $OVERALL_STATUS -eq 0 ]; then
        log_success "üéâ Tous les services sont op√©rationnels"
        echo ""
        echo "‚úÖ Le syst√®me File Optimizer fonctionne correctement"
        echo "üìç Application accessible sur: $API_URL"
    else
        log_error "‚ö†Ô∏è  Certains services ont des probl√®mes"
        echo ""
        echo "‚ùå Des probl√®mes ont √©t√© d√©tect√©s"
        echo "üîß V√©rifiez les logs et corrigez les erreurs signal√©es"
        echo ""
        echo "üÜò Commandes de diagnostic utiles:"
        echo "   - Logs Docker: docker-compose logs -f"
        echo "   - Logs PM2: pm2 logs"
        echo "   - Status conteneurs: docker ps"
        echo "   - Test manuel API: curl $API_URL/api/health"
    fi
    
    echo "========================================"
}

# Fonction principale
main() {
    echo "üè• File Optimizer Health Check"
    echo "======================================="
    echo "URL test√©e: $API_URL"
    echo "Mode: $([ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ] && echo "Verbose" || echo "Standard")"
    echo "======================================="
    echo ""
    
    # Ex√©cuter tous les checks
    check_api || true
    check_redis || true
    check_docker || true
    check_disk_space || true
    check_memory || true
    check_pm2 || true
    check_endpoints || true
    check_performance || true
    
    # Afficher le r√©sum√©
    show_summary
    
    # Retourner le code d'erreur global
    exit $OVERALL_STATUS
}

# Parse des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose|-v)
            VERBOSE="--verbose"
            shift
            ;;
        --url)
            API_URL="$2"
            shift 2
            ;;
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --redis-host)
            REDIS_HOST="$2"
            shift 2
            ;;
        --redis-port)
            REDIS_PORT="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --verbose, -v         Mode verbeux avec d√©tails"
            echo "  --url URL             URL de l'API (default: http://localhost:8000)"
            echo "  --timeout SECONDS     Timeout des requ√™tes (default: 10)"
            echo "  --redis-host HOST     Host Redis (default: localhost)"
            echo "  --redis-port PORT     Port Redis (default: 6379)"
            echo "  --help, -h            Afficher cette aide"
            echo ""
            echo "Exemples:"
            echo "  $0                    Health check standard"
            echo "  $0 --verbose          Health check d√©taill√©"
            echo "  $0 --url http://localhost:8001  Test staging"
            echo ""
            exit 0
            ;;
        *)
            log_warn "Option inconnue: $1"
            shift
            ;;
    esac
done

# Ex√©cution
main "$@"


================================================
File: backend/src/server.js
================================================
// backend/src/server.js
require('dotenv').config();

const express = require('express');
const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const compression = require('compression');
const morgan = require('morgan');
const { Server } = require('socket.io');

// Services et utilitaires
const logger = require('./utils/logger');
const { getRedisClient } = require('./utils/redis');
const { cleanQueue } = require('./services/queueService');
const FileService = require('./services/fileService');

// Routes
const apiRoutes = require('./routes');

/**
 * Classe principale du serveur
 */
class FileOptimizerServer {
    constructor() {
        this.app = express();
        this.server = null;
        this.io = null;
        this.redis = null;
        this.isShuttingDown = false;
        this.connections = new Set();
        this.startTime = Date.now();
    }

    /**
     * Initialiser le serveur
     */
    async init() {
        try {
            logger.info('üöÄ Initialisation du serveur File Optimizer');

            // V√©rifier les pr√©requis
            await this.checkPrerequisites();

            // Configuration de l'application Express
            await this.configureApp();

            // Configuration des routes
            this.configureRoutes();

            // Cr√©ation du serveur HTTP/HTTPS
            await this.createServer();

            // Configuration WebSocket
            this.configureWebSocket();

            // Gestion gracieuse de l'arr√™t
            this.setupGracefulShutdown();

            // Nettoyage p√©riodique
            this.setupPeriodicCleanup();

            logger.info('‚úÖ Serveur initialis√© avec succ√®s');
        } catch (error) {
            logger.error('‚ùå Erreur initialisation serveur:', error);
            throw error;
        }
    }

    /**
     * V√©rifier les pr√©requis syst√®me
     */
    async checkPrerequisites() {
        logger.info('üîç V√©rification des pr√©requis...');

        try {
            // V√©rifier Redis
            this.redis = await getRedisClient();
            await this.redis.ping();
            logger.info('‚úÖ Redis connect√©');

            // V√©rifier les r√©pertoires
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            await FileService.ensureDirectoryExists(tempDir);
            await FileService.ensureDirectoryExists(path.join(tempDir, 'output'));
            logger.info('‚úÖ R√©pertoires cr√©√©s');

            // V√©rifier Sharp
            const sharp = require('sharp');
            const sharpVersion = sharp.versions;
            logger.info(`‚úÖ Sharp v${sharpVersion.sharp} disponible`);

            // V√©rifier FFmpeg (optionnel)
            if (process.env.FFMPEG_PATH) {
                const { exec } = require('child_process');
                const { promisify } = require('util');
                const execAsync = promisify(exec);
                
                try {
                    await execAsync(`${process.env.FFMPEG_PATH} -version`);
                    logger.info('‚úÖ FFmpeg disponible');
                } catch (error) {
                    logger.warn('‚ö†Ô∏è FFmpeg non disponible (traitement vid√©o/audio limit√©)');
                }
            }

        } catch (error) {
            logger.error('‚ùå Pr√©requis non satisfaits:', error);
            throw new Error(`Pr√©requis manquants: ${error.message}`);
        }
    }

    /**
     * Configuration de l'application Express
     */
    async configureApp() {
        logger.info('‚öôÔ∏è Configuration Express...');

        // Middleware de base
        this.app.use(compression({
            threshold: 1024,
            level: 6,
            filter: (req, res) => {
                // Ne pas compresser les streams de fichiers
                if (req.path.includes('/download/')) return false;
                return compression.filter(req, res);
            }
        }));

        // Body parsing avec limites
        this.app.use(express.json({ 
            limit: process.env.BODY_LIMIT || '10mb',
            verify: (req, res, buf) => {
                // V√©rification int√©grit√© JSON
                req.rawBody = buf;
            }
        }));

        this.app.use(express.urlencoded({ 
            extended: true, 
            limit: process.env.BODY_LIMIT || '10mb' 
        }));

        // Trust proxy si n√©cessaire (pour rate limiting)
        if (process.env.TRUST_PROXY === 'true') {
            this.app.set('trust proxy', true);
        }

        // Logging HTTP avec Morgan
        const morganFormat = process.env.NODE_ENV === 'production' 
            ? 'combined' 
            : 'dev';
        
        this.app.use(morgan(morganFormat, { 
            stream: logger.stream(),
            skip: (req) => {
                // Skip health checks pour √©viter spam
                return req.path.startsWith('/api/health');
            }
        }));

        // Middleware pour injecter Socket.IO dans les requ√™tes
        this.app.use((req, res, next) => {
            req.io = this.io;
            req.startTime = Date.now();
            next();
        });

        // Gestion des connexions pour graceful shutdown
        this.app.use((req, res, next) => {
            this.connections.add(res);
            res.on('close', () => this.connections.delete(res));
            next();
        });

        // Headers de s√©curit√© suppl√©mentaires
        this.app.use((req, res, next) => {
            res.setHeader('X-Powered-By', 'File Optimizer v2.0.0');
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.setHeader('X-Frame-Options', 'DENY');
            res.setHeader('X-XSS-Protection', '1; mode=block');
            
            if (process.env.HTTPS_ENABLED === 'true') {
                res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
            }
            
            next();
        });

        logger.info('‚úÖ Express configur√©');
    }

    /**
     * Configuration des routes
     */
    configureRoutes() {
        logger.info('üõ£Ô∏è Configuration des routes...');

        // Route racine avec informations serveur
        this.app.get('/', (req, res) => {
            const uptime = Math.floor((Date.now() - this.startTime) / 1000);
            
            res.json({
                success: true,
                service: 'File Optimizer API',
                version: process.env.npm_package_version || '2.0.0',
                environment: process.env.NODE_ENV || 'development',
                uptime: uptime,
                uptimeFormatted: this.formatUptime(uptime),
                timestamp: new Date().toISOString(),
                endpoints: {
                    api: '/api',
                    health: '/api/health',
                    docs: '/docs',
                    metrics: '/api/health/metrics'
                },
                features: {
                    upload: true,
                    websockets: true,
                    compression: true,
                    monitoring: true,
                    authentication: process.env.AUTH_ENABLED === 'true'
                }
            });
        });

        // Routes API
        this.app.use('/api', apiRoutes);

        // Servir la documentation statique (si elle existe)
        const docsPath = path.join(__dirname, '../docs');
        if (fs.existsSync(docsPath)) {
            this.app.use('/docs', express.static(docsPath));
        }

        // Servir le frontend (si il existe)
        const frontendPath = path.join(__dirname, '../public');
        if (fs.existsSync(frontendPath)) {
            this.app.use('/app', express.static(frontendPath));
            
            // SPA fallback
            this.app.get('/app/*', (req, res) => {
                res.sendFile(path.join(frontendPath, 'index.html'));
            });
        }

        // Route pour les t√©l√©chargements directs (alias)
        this.app.get('/download/:jobId', (req, res) => {
            res.redirect(307, `/api/download/${req.params.jobId}`);
        });

        // Middleware 404 pour toutes les routes non trouv√©es
        this.app.use('*', (req, res) => {
            logger.warn('Route non trouv√©e', {
                method: req.method,
                path: req.originalUrl,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });

            res.status(404).json({
                success: false,
                error: 'Route non trouv√©e',
                path: req.originalUrl,
                suggestion: 'Consultez /api pour les endpoints disponibles'
            });
        });

        // Gestionnaire d'erreurs global
        this.app.use((error, req, res, next) => {
            const duration = Date.now() - req.startTime;
            
            logger.error('Erreur non g√©r√©e:', error, {
                method: req.method,
                path: req.path,
                ip: req.ip,
                userAgent: req.get('User-Agent'),
                duration: `${duration}ms`
            });

            // Ne pas exposer les d√©tails d'erreur en production
            const isDev = process.env.NODE_ENV === 'development';
            
            res.status(error.status || 500).json({
                success: false,
                error: 'Erreur interne du serveur',
                message: isDev ? error.message : undefined,
                stack: isDev ? error.stack : undefined,
                timestamp: new Date().toISOString()
            });
        });

        logger.info('‚úÖ Routes configur√©es');
    }

    /**
     * Cr√©er le serveur HTTP ou HTTPS
     */
    async createServer() {
        logger.info('üåê Cr√©ation du serveur...');

        const port = parseInt(process.env.PORT) || 8000;
        const host = process.env.HOST || '0.0.0.0';

        if (process.env.HTTPS_ENABLED === 'true') {
            // Serveur HTTPS
            const sslOptions = {
                key: fs.readFileSync(process.env.SSL_KEY_PATH),
                cert: fs.readFileSync(process.env.SSL_CERT_PATH)
            };
            
            this.server = https.createServer(sslOptions, this.app);
            logger.info(`üîí Serveur HTTPS configur√©`);
        } else {
            // Serveur HTTP
            this.server = http.createServer(this.app);
        }

        // Gestion des connexions pour graceful shutdown
        this.server.on('connection', (connection) => {
            this.connections.add(connection);
            connection.on('close', () => this.connections.delete(connection));
        });

        // D√©marrer l'√©coute
        await new Promise((resolve, reject) => {
            this.server.listen(port, host, (error) => {
                if (error) {
                    reject(error);
                } else {
                    const protocol = process.env.HTTPS_ENABLED === 'true' ? 'https' : 'http';
                    logger.info(`üöÄ Serveur d√©marr√© sur ${protocol}://${host}:${port}`);
                    resolve();
                }
            });
        });
    }

    /**
     * Configuration WebSocket avec Socket.IO
     */
    configureWebSocket() {
        logger.info('üîå Configuration WebSocket...');

        this.io = new Server(this.server, {
            cors: {
                origin: (process.env.CORS_ORIGIN || 'http://localhost:3000').split(','),
                methods: ['GET', 'POST'],
                credentials: true
            },
            transports: ['websocket', 'polling'],
            pingTimeout: 60000,
            pingInterval: 25000
        });

        // Middleware d'authentification WebSocket (optionnel)
        if (process.env.AUTH_ENABLED === 'true') {
            this.io.use((socket, next) => {
                const token = socket.handshake.auth.token || socket.handshake.query.token;
                
                if (!token || token !== process.env.API_KEY) {
                    logger.security('WebSocket connexion non autoris√©e', {
                        socketId: socket.id,
                        ip: socket.handshake.address
                    });
                    return next(new Error('Authentication failed'));
                }
                
                next();
            });
        }

        // Gestion des connexions WebSocket
        this.io.on('connection', (socket) => {
            logger.info('WebSocket connect√©', {
                socketId: socket.id,
                ip: socket.handshake.address,
                userAgent: socket.handshake.headers['user-agent']
            });

            // Rejoindre une room pour un job sp√©cifique
            socket.on('join-job', (jobId) => {
                if (this.isValidJobId(jobId)) {
                    socket.join(`job-${jobId}`);
                    socket.emit('joined-job', { jobId });
                    logger.debug(`Socket ${socket.id} rejoint job ${jobId}`);
                } else {
                    socket.emit('error', { message: 'Job ID invalide' });
                }
            });

            // Quitter une room de job
            socket.on('leave-job', (jobId) => {
                socket.leave(`job-${jobId}`);
                socket.emit('left-job', { jobId });
                logger.debug(`Socket ${socket.id} quitte job ${jobId}`);
            });

            // Demander le statut d'un job
            socket.on('get-status', async (jobId) => {
                try {
                    const JobService = require('./services/jobService');
                    const job = await JobService.getJob(jobId);
                    
                    if (job) {
                        socket.emit('job-status', {
                            jobId,
                            status: job.status,
                            progress: job.progress || 0,
                            timestamp: new Date().toISOString()
                        });
                    } else {
                        socket.emit('error', { 
                            message: 'Job non trouv√©',
                            jobId 
                        });
                    }
                } catch (error) {
                    logger.error('Erreur get-status WebSocket:', error);
                    socket.emit('error', { 
                        message: 'Erreur r√©cup√©ration statut' 
                    });
                }
            });

            // Gestion d√©connexion
            socket.on('disconnect', (reason) => {
                logger.info('WebSocket d√©connect√©', {
                    socketId: socket.id,
                    reason,
                    ip: socket.handshake.address
                });
            });

            // Gestion des erreurs
            socket.on('error', (error) => {
                logger.error('Erreur WebSocket:', error, {
                    socketId: socket.id,
                    ip: socket.handshake.address
                });
            });
        });

        // M√©thodes utilitaires pour √©mettre des √©v√©nements
        this.io.emitJobUpdate = (jobId, data) => {
            this.io.to(`job-${jobId}`).emit('job-update', {
                jobId,
                ...data,
                timestamp: new Date().toISOString()
            });
        };

        this.io.emitJobProgress = (jobId, progress) => {
            this.io.to(`job-${jobId}`).emit('job-progress', {
                jobId,
                progress,
                timestamp: new Date().toISOString()
            });
        };

        this.io.emitJobCompleted = (jobId, result) => {
            this.io.to(`job-${jobId}`).emit('job-completed', {
                jobId,
                ...result,
                timestamp: new Date().toISOString()
            });
        };

        this.io.emitJobError = (jobId, error) => {
            this.io.to(`job-${jobId}`).emit('job-error', {
                jobId,
                error: error.message || error,
                timestamp: new Date().toISOString()
            });
        };

        logger.info('‚úÖ WebSocket configur√©');
    }

    /**
     * Configuration de l'arr√™t gracieux
     */
    setupGracefulShutdown() {
        logger.info('üõ°Ô∏è Configuration arr√™t gracieux...');

        const shutdown = async (signal) => {
            if (this.isShuttingDown) return;
            this.isShuttingDown = true;

            logger.info(`üõë Arr√™t gracieux d√©marr√© (${signal})`);

            try {
                // 1. Arr√™ter d'accepter de nouvelles connexions
                this.server.close();

                // 2. Notifier les clients WebSocket
                if (this.io) {
                    this.io.emit('server-shutdown', {
                        message: 'Serveur en cours d\'arr√™t',
                        timestamp: new Date().toISOString()
                    });

                    // Fermer les connexions WebSocket
                    setTimeout(() => {
                        this.io.close();
                    }, 1000);
                }

                // 3. Attendre la fin des requ√™tes en cours (max 30s)
                await this.waitForConnectionsToClose(30000);

                // 4. Nettoyer la queue
                await cleanQueue();

                // 5. Fermer Redis
                if (this.redis) {
                    await this.redis.quit();
                }

                logger.info('‚úÖ Arr√™t gracieux termin√©');
                process.exit(0);

            } catch (error) {
                logger.error('‚ùå Erreur arr√™t gracieux:', error);
                process.exit(1);
            }
        };

        // Signaux d'arr√™t
        process.on('SIGTERM', () => shutdown('SIGTERM'));
        process.on('SIGINT', () => shutdown('SIGINT'));
        process.on('SIGUSR2', () => shutdown('SIGUSR2')); // Nodemon

        // Erreurs non g√©r√©es
        process.on('uncaughtException', (error) => {
            logger.error('Exception non g√©r√©e:', error);
            shutdown('uncaughtException');
        });

        process.on('unhandledRejection', (reason, promise) => {
            logger.error('Rejection non g√©r√©e:', reason, { promise });
            shutdown('unhandledRejection');
        });

        logger.info('‚úÖ Arr√™t gracieux configur√©');
    }

    /**
     * Configuration du nettoyage p√©riodique
     */
    setupPeriodicCleanup() {
        logger.info('üßπ Configuration nettoyage p√©riodique...');

        const cleanupInterval = parseInt(process.env.CLEANUP_INTERVAL) || 3600; // 1h par d√©faut

        setInterval(async () => {
            try {
                logger.info('üßπ Nettoyage p√©riodique d√©marr√©');

                // Nettoyer les fichiers temporaires
                const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
                const maxAge = parseInt(process.env.FILE_RETENTION) || 86400; // 24h par d√©faut
                
                const cleaned = await FileService.cleanupTempFiles(tempDir, maxAge * 1000);
                if (cleaned.count > 0) {
                    logger.info(`üßπ ${cleaned.count} fichiers nettoy√©s (${FileService.formatFileSize(cleaned.size)} lib√©r√©s)`);
                }

                // Nettoyer les jobs expir√©s
                const JobService = require('./services/jobService');
                const jobsCleaned = await JobService.cleanupExpiredJobs();
                if (jobsCleaned > 0) {
                    logger.info(`üßπ ${jobsCleaned} jobs expir√©s supprim√©s`);
                }

                // Nettoyer la queue
                await cleanQueue();

                logger.info('‚úÖ Nettoyage p√©riodique termin√©');

            } catch (error) {
                logger.error('‚ùå Erreur nettoyage p√©riodique:', error);
            }
        }, cleanupInterval * 1000);

        logger.info(`‚úÖ Nettoyage configur√© (intervalle: ${cleanupInterval}s)`);
    }

    /**
     * Attendre la fermeture des connexions
     */
    async waitForConnectionsToClose(timeout = 30000) {
        return new Promise((resolve) => {
            const startTime = Date.now();

            const checkConnections = () => {
                if (this.connections.size === 0) {
                    logger.info('‚úÖ Toutes les connexions ferm√©es');
                    resolve();
                } else if (Date.now() - startTime >= timeout) {
                    logger.warn(`‚ö†Ô∏è Timeout atteint, fermeture forc√©e (${this.connections.size} connexions restantes)`);
                    // Fermer les connexions restantes
                    for (const connection of this.connections) {
                        connection.destroy();
                    }
                    resolve();
                } else {
                    setTimeout(checkConnections, 100);
                }
            };

            checkConnections();
        });
    }

    /**
     * Valider un ID de job
     */
    isValidJobId(jobId) {
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(jobId);
    }

    /**
     * Formater la dur√©e d'uptime
     */
    formatUptime(seconds) {
        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (days > 0) {
            return `${days}j ${hours}h ${minutes}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes}m ${secs}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${secs}s`;
        } else {
            return `${secs}s`;
        }
    }

    /**
     * Obtenir les statistiques du serveur
     */
    getServerStats() {
        const uptime = Math.floor((Date.now() - this.startTime) / 1000);
        const memUsage = process.memoryUsage();

        return {
            uptime,
            uptimeFormatted: this.formatUptime(uptime),
            connections: this.connections.size,
            memory: {
                rss: memUsage.rss,
                heapTotal: memUsage.heapTotal,
                heapUsed: memUsage.heapUsed,
                external: memUsage.external
            },
            websocket: {
                connected: this.io ? this.io.engine.clientsCount : 0
            },
            process: {
                pid: process.pid,
                platform: process.platform,
                nodeVersion: process.version
            }
        };
    }
}

/**
 * Fonction principale de d√©marrage
 */
async function main() {
    try {
        logger.info('üéØ File Optimizer Server v2.0.0');
        logger.info(`üìç Environnement: ${process.env.NODE_ENV || 'development'}`);
        logger.info(`üîß Node.js: ${process.version}`);
        logger.info(`üìÇ R√©pertoire: ${process.cwd()}`);

        const server = new FileOptimizerServer();
        await server.init();

        // Exposer les stats serveur
        global.getServerStats = () => server.getServerStats();

        logger.info('üéâ File Optimizer Server d√©marr√© avec succ√®s !');
        logger.info('üìñ Documentation API: http://localhost:8000/docs');
        logger.info('üè• Health check: http://localhost:8000/api/health');

    } catch (error) {
        logger.error('üí• √âchec d√©marrage serveur:', error);
        process.exit(1);
    }
}

// D√©marrer le serveur si ce fichier est ex√©cut√© directement
if (require.main === module) {
    main();
}

module.exports = { FileOptimizerServer, main };



================================================
File: backend/src/routes/download.js
================================================
// backend/src/routes/download.js
const express = require('express');
const fs = require('fs');
const path = require('path');
const rateLimit = require('express-rate-limit');

const JobService = require('../services/jobService');
const FileService = require('../services/fileService');
const { ValidationService, validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * Rate limiting pour les t√©l√©chargements
 */
const downloadRateLimit = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: parseInt(process.env.DOWNLOAD_RATE_LIMIT) || 20, // 20 t√©l√©chargements par minute
    message: {
        success: false,
        error: 'Trop de t√©l√©chargements, veuillez attendre'
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Rate limit par IP
        return req.ip;
    },
    skip: (req) => {
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    },
    onLimitReached: (req) => {
        logger.security('Rate limit download atteint', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            jobId: req.params.jobId
        });
    }
});

/**
 * Middleware de validation d'acc√®s au t√©l√©chargement
 */
const validateDownloadAccess = async (req, res, next) => {
    try {
        const { jobId } = req.params;
        
        // V√©rifier que le job existe
        const job = await JobService.getJob(jobId);
        if (!job) {
            return res.status(404).json({
                success: false,
                error: 'Job non trouv√©'
            });
        }

        // V√©rifier que le job est termin√©
        if (job.status !== 'completed') {
            return res.status(400).json({
                success: false,
                error: 'Le fichier n\'est pas encore pr√™t',
                status: job.status,
                progress: job.progress || 0
            });
        }

        // V√©rifier que le fichier de sortie existe
        if (!job.outputPath) {
            return res.status(500).json({
                success: false,
                error: 'Chemin de fichier manquant'
            });
        }

        const fileStats = await FileService.getFileStats(job.outputPath);
        if (!fileStats) {
            logger.error(`Fichier de sortie introuvable: ${job.outputPath}`, { jobId });
            return res.status(404).json({
                success: false,
                error: 'Fichier non trouv√© sur le serveur'
            });
        }

        // Ajouter les informations √† la requ√™te
        req.job = job;
        req.fileStats = fileStats;
        
        next();

    } catch (error) {
        logger.error('Erreur validation acc√®s download:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
};

/**
 * GET /api/download/:jobId
 * T√©l√©charger le fichier trait√©
 */
router.get('/:jobId',
    downloadRateLimit,
    validateRequest.jobId,
    validateDownloadAccess,
    async (req, res) => {
        const { jobId } = req.params;
        const { job, fileStats } = req;
        
        const downloadLogger = logger.withContext({
            jobId,
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });

        try {
            downloadLogger.info('T√©l√©chargement d√©marr√©', {
                filename: job.originalName,
                outputPath: job.outputPath,
                size: fileStats.size
            });

            // D√©terminer le nom de fichier pour le t√©l√©chargement
            const originalExt = path.extname(job.originalName);
            const baseName = path.basename(job.originalName, originalExt);
            
            // Ajouter un suffixe pour indiquer la compression
            let downloadFilename;
            if (job.compressionRatio && job.compressionRatio > 0) {
                downloadFilename = `${baseName}_optimized${originalExt}`;
            } else {
                downloadFilename = job.originalName;
            }

            // Nettoyer le nom de fichier pour le t√©l√©chargement
            downloadFilename = ValidationService.sanitizeFilename(downloadFilename) || 'file';

            // D√©terminer le type MIME
            const mimeType = require('mime-types').lookup(job.outputPath) || 'application/octet-stream';

            // Configurer les headers de r√©ponse
            res.setHeader('Content-Type', mimeType);
            res.setHeader('Content-Length', fileStats.size);
            res.setHeader('Content-Disposition', `attachment; filename="${downloadFilename}"`);
            res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
            res.setHeader('Pragma', 'no-cache');
            res.setHeader('Expires', '0');
            
            // Headers personnalis√©s avec informations sur le traitement
            res.setHeader('X-Original-Size', job.size);
            res.setHeader('X-Compressed-Size', job.compressedSize || job.size);
            res.setHeader('X-Compression-Ratio', job.compressionRatio || 0);
            res.setHeader('X-File-Type', job.type);
            res.setHeader('X-Processing-Time', new Date(job.updatedAt) - new Date(job.createdAt));

            // Support du Range (t√©l√©chargement partiel)
            const range = req.headers.range;
            
            if (range) {
                const ranges = parseRange(fileStats.size, range);
                
                if (ranges && ranges.length === 1 && ranges[0].start < fileStats.size) {
                    const { start, end } = ranges[0];
                    const contentLength = (end - start) + 1;
                    
                    res.status(206); // Partial Content
                    res.setHeader('Content-Range', `bytes ${start}-${end}/${fileStats.size}`);
                    res.setHeader('Content-Length', contentLength);
                    res.setHeader('Accept-Ranges', 'bytes');
                    
                    // Stream partiel
                    const stream = fs.createReadStream(job.outputPath, { start, end });
                    streamFile(stream, res, downloadLogger, job, true);
                } else {
                    // Range invalide
                    res.status(416); // Range Not Satisfiable
                    res.setHeader('Content-Range', `bytes */${fileStats.size}`);
                    res.end();
                }
            } else {
                // T√©l√©chargement complet
                res.setHeader('Accept-Ranges', 'bytes');
                const stream = fs.createReadStream(job.outputPath);
                streamFile(stream, res, downloadLogger, job, false);
            }

        } catch (error) {
            downloadLogger.error('Erreur t√©l√©chargement:', error);
            
            if (!res.headersSent) {
                res.status(500).json({
                    success: false,
                    error: 'Erreur t√©l√©chargement fichier'
                });
            }
        }
    }
);

/**
 * GET /api/download/:jobId/info
 * Informations sur le fichier √† t√©l√©charger
 */
router.get('/:jobId/info',
    downloadRateLimit,
    validateRequest.jobId,
    validateDownloadAccess,
    async (req, res) => {
        try {
            const { job, fileStats } = req;
            
            // Calculer les m√©triques
            const compressionRatio = parseInt(job.compressionRatio) || 0;
            const savedBytes = parseInt(job.size) - parseInt(job.compressedSize || job.size);
            const processingTime = new Date(job.updatedAt) - new Date(job.createdAt);

            res.json({
                success: true,
                file: {
                    jobId: job.id,
                    originalName: job.originalName,
                    type: job.type,
                    originalSize: parseInt(job.size),
                    originalSizeFormatted: FileService.formatFileSize(parseInt(job.size)),
                    compressedSize: parseInt(job.compressedSize || job.size),
                    compressedSizeFormatted: FileService.formatFileSize(parseInt(job.compressedSize || job.size)),
                    compressionRatio,
                    savedBytes,
                    savedBytesFormatted: FileService.formatFileSize(savedBytes),
                    processingTime: Math.floor(processingTime / 1000), // en secondes
                    mimeType: require('mime-types').lookup(job.outputPath) || 'application/octet-stream',
                    settings: job.settings,
                    createdAt: job.createdAt,
                    completedAt: job.updatedAt
                }
            });

        } catch (error) {
            logger.error('Erreur info download:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur r√©cup√©ration informations'
            });
        }
    }
);

/**
 * GET /api/download/:jobId/preview
 * Pr√©visualisation du fichier (pour les images)
 */
router.get('/:jobId/preview',
    downloadRateLimit,
    validateRequest.jobId,
    validateDownloadAccess,
    async (req, res) => {
        try {
            const { job } = req;
            
            // V√©rifier que c'est une image
            if (job.type !== 'image') {
                return res.status(400).json({
                    success: false,
                    error: 'Pr√©visualisation disponible uniquement pour les images'
                });
            }

            const { size = 'medium' } = req.query;
            const maxSizes = {
                small: 150,
                medium: 300,
                large: 600
            };

            const maxSize = maxSizes[size] || 300;

            // G√©n√©rer une vignette temporaire
            const ImageService = require('../services/imageService');
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            const thumbnailPath = path.join(tempDir, `preview_${job.id}_${maxSize}.jpg`);

            // V√©rifier si la vignette existe d√©j√†
            let thumbExists = await FileService.getFileStats(thumbnailPath);
            
            if (!thumbExists) {
                // Cr√©er la vignette
                await ImageService.createThumbnail(job.outputPath, thumbnailPath, maxSize);
                thumbExists = await FileService.getFileStats(thumbnailPath);
            }

            if (!thumbExists) {
                return res.status(500).json({
                    success: false,
                    error: 'Impossible de g√©n√©rer la pr√©visualisation'
                });
            }

            // Servir la vignette
            res.setHeader('Content-Type', 'image/jpeg');
            res.setHeader('Content-Length', thumbExists.size);
            res.setHeader('Cache-Control', 'public, max-age=3600'); // Cache 1h
            
            const stream = fs.createReadStream(thumbnailPath);
            stream.pipe(res);

            // Nettoyer la vignette apr√®s envoi (optionnel)
            stream.on('end', () => {
                setTimeout(() => {
                    FileService.deleteFile(thumbnailPath).catch(() => {});
                }, 5000); // Attendre 5s avant suppression
            });

        } catch (error) {
            logger.error('Erreur preview:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur g√©n√©ration pr√©visualisation'
            });
        }
    }
);

/**
 * Fonction pour streamer un fichier avec gestion d'erreurs
 */
function streamFile(stream, res, downloadLogger, job, isPartial = false) {
    let bytesStreamed = 0;
    const startTime = Date.now();

    stream.on('data', (chunk) => {
        bytesStreamed += chunk.length;
    });

    stream.on('end', () => {
        const duration = Date.now() - startTime;
        const speed = bytesStreamed / (duration / 1000); // bytes/sec
        
        downloadLogger.info('T√©l√©chargement termin√©', {
            bytesStreamed,
            duration,
            speedBps: Math.round(speed),
            speedFormatted: FileService.formatFileSize(speed) + '/s',
            isPartial
        });

        downloadLogger.metric('download_completed', 1, 'count', {
            jobId: job.id,
            fileType: job.type,
            size: bytesStreamed
        });
    });

    stream.on('error', (error) => {
        downloadLogger.error('Erreur stream fichier:', error);
        
        if (!res.headersSent) {
            res.status(500).json({
                success: false,
                error: 'Erreur lecture fichier'
            });
        }
    });

    res.on('close', () => {
        // Client a ferm√© la connexion
        downloadLogger.info('Connexion ferm√©e par le client', {
            bytesStreamed,
            isComplete: res.writableEnded
        });
        
        // Nettoyer le stream
        if (stream.readable) {
            stream.destroy();
        }
    });

    // Pipe le stream vers la r√©ponse
    stream.pipe(res);
}

/**
 * Parser les headers Range pour le download partiel
 */
function parseRange(size, rangeHeader) {
    if (!rangeHeader || !rangeHeader.startsWith('bytes=')) {
        return null;
    }

    const ranges = [];
    const rangeSpecs = rangeHeader.substring(6).split(',');

    for (const rangeSpec of rangeSpecs) {
        const rangeParts = rangeSpec.trim().split('-');
        
        if (rangeParts.length !== 2) continue;

        let start = parseInt(rangeParts[0]) || 0;
        let end = parseInt(rangeParts[1]) || (size - 1);

        // Validation
        if (start < 0) start = 0;
        if (end >= size) end = size - 1;
        if (start > end) continue;

        ranges.push({ start, end });
    }

    return ranges.length > 0 ? ranges : null;
}

module.exports = router;


================================================
File: backend/src/routes/health.js
================================================
// backend/src/routes/health.js
const express = require('express');
const os = require('os');
const fs = require('fs').promises;
const path = require('path');

const { healthCheck: redisHealthCheck, getMetrics: getRedisMetrics } = require('../utils/redis');
const { getQueueStats } = require('../services/queueService');
const JobService = require('../services/jobService');
const FileService = require('../services/fileService');
const { validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * GET /api/health
 * V√©rification de sant√© basique
 */
router.get('/', async (req, res) => {
    try {
        const startTime = Date.now();
        
        // Tests de base
        const checks = {
            server: await checkServer(),
            redis: await checkRedis(),
            filesystem: await checkFilesystem(),
            memory: await checkMemory()
        };

        // D√©terminer le statut global
        const allHealthy = Object.values(checks).every(check => check.status === 'ok');
        const responseTime = Date.now() - startTime;

        const response = {
            status: allHealthy ? 'ok' : 'error',
            timestamp: new Date().toISOString(),
            responseTime: `${responseTime}ms`,
            checks,
            version: process.env.npm_package_version || '2.0.0',
            uptime: Math.floor(process.uptime()),
            environment: process.env.NODE_ENV || 'development'
        };

        // Log si probl√®me d√©tect√©
        if (!allHealthy) {
            logger.warn('Health check failed', { checks, responseTime });
        }

        res.status(allHealthy ? 200 : 503).json(response);

    } catch (error) {
        logger.error('Erreur health check:', error);
        res.status(503).json({
            status: 'error',
            timestamp: new Date().toISOString(),
            error: 'Health check failed',
            message: error.message
        });
    }
});

/**
 * GET /api/health/detailed
 * V√©rification de sant√© d√©taill√©e
 */
router.get('/detailed',
    validateRequest.healthCheck,
    async (req, res) => {
        try {
            const { includeMetrics, includeRedis, includeQueue } = req.query;
            const startTime = Date.now();

            // Tests d√©taill√©s
            const checks = {
                server: await checkServerDetailed(),
                redis: includeRedis ? await checkRedisDetailed() : await checkRedis(),
                filesystem: await checkFilesystemDetailed(),
                memory: await checkMemoryDetailed(),
                queue: includeQueue ? await checkQueue() : null,
                dependencies: await checkDependencies()
            };

            // M√©triques optionnelles
            let metrics = null;
            if (includeMetrics) {
                metrics = await collectMetrics();
            }

            // Supprimer les checks null
            Object.keys(checks).forEach(key => {
                if (checks[key] === null) delete checks[key];
            });

            const allHealthy = Object.values(checks).every(check => check.status === 'ok');
            const responseTime = Date.now() - startTime;

            const response = {
                status: allHealthy ? 'ok' : 'error',
                timestamp: new Date().toISOString(),
                responseTime: `${responseTime}ms`,
                checks,
                system: {
                    platform: os.platform(),
                    arch: os.arch(),
                    nodeVersion: process.version,
                    uptime: Math.floor(process.uptime()),
                    pid: process.pid
                }
            };

            if (metrics) {
                response.metrics = metrics;
            }

            res.status(allHealthy ? 200 : 503).json(response);

        } catch (error) {
            logger.error('Erreur health check d√©taill√©:', error);
            res.status(503).json({
                status: 'error',
                timestamp: new Date().toISOString(),
                error: 'Detailed health check failed',
                message: error.message
            });
        }
    }
);

/**
 * GET /api/health/readiness
 * V√©rification de disponibilit√© (pour Kubernetes)
 */
router.get('/readiness', async (req, res) => {
    try {
        const checks = {
            redis: await checkRedis(),
            filesystem: await checkFilesystem()
        };

        const isReady = Object.values(checks).every(check => check.status === 'ok');

        res.status(isReady ? 200 : 503).json({
            status: isReady ? 'ready' : 'not ready',
            timestamp: new Date().toISOString(),
            checks
        });

    } catch (error) {
        res.status(503).json({
            status: 'not ready',
            timestamp: new Date().toISOString(),
            error: error.message
        });
    }
});

/**
 * GET /api/health/liveness
 * V√©rification de vivacit√© (pour Kubernetes)
 */
router.get('/liveness', (req, res) => {
    // Test simple : le serveur r√©pond
    res.status(200).json({
        status: 'alive',
        timestamp: new Date().toISOString(),
        uptime: Math.floor(process.uptime())
    });
});

/**
 * V√©rifications de sant√© individuelles
 */

async function checkServer() {
    try {
        return {
            status: 'ok',
            uptime: Math.floor(process.uptime()),
            pid: process.pid,
            nodeVersion: process.version
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkServerDetailed() {
    try {
        const loadAvg = os.loadavg();
        const cpuCount = os.cpus().length;
        
        return {
            status: 'ok',
            uptime: Math.floor(process.uptime()),
            pid: process.pid,
            nodeVersion: process.version,
            platform: os.platform(),
            arch: os.arch(),
            cpuCount,
            loadAverage: {
                '1min': loadAvg[0].toFixed(2),
                '5min': loadAvg[1].toFixed(2),
                '15min': loadAvg[2].toFixed(2)
            },
            hostname: os.hostname()
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkRedis() {
    try {
        const health = await redisHealthCheck();
        return health;
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkRedisDetailed() {
    try {
        const health = await redisHealthCheck();
        
        if (health.status === 'ok') {
            const metrics = await getRedisMetrics();
            return {
                ...health,
                metrics
            };
        }
        
        return health;
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkFilesystem() {
    try {
        const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
        
        // Tester l'√©criture
        const testFile = path.join(tempDir, `health-check-${Date.now()}.tmp`);
        await fs.writeFile(testFile, 'health check');
        await fs.unlink(testFile);
        
        return {
            status: 'ok',
            tempDir,
            writable: true
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message,
            writable: false
        };
    }
}

async function checkFilesystemDetailed() {
    try {
        const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
        
        // Tester l'√©criture
        const testFile = path.join(tempDir, `health-check-${Date.now()}.tmp`);
        const testData = 'health check test data';
        
        const writeStart = Date.now();
        await fs.writeFile(testFile, testData);
        const writeTime = Date.now() - writeStart;
        
        const readStart = Date.now();
        const readData = await fs.readFile(testFile, 'utf8');
        const readTime = Date.now() - readStart;
        
        await fs.unlink(testFile);
        
        // Obtenir l'usage disque
        const dirStats = await FileService.getDirectorySize(tempDir);
        
        return {
            status: 'ok',
            tempDir,
            writable: true,
            readable: true,
            writeTime: `${writeTime}ms`,
            readTime: `${readTime}ms`,
            dataIntegrity: readData === testData,
            diskUsage: {
                files: dirStats.fileCount,
                size: dirStats.size,
                sizeFormatted: dirStats.sizeFormatted
            }
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message,
            writable: false
        };
    }
}

async function checkMemory() {
    try {
        const memUsage = process.memoryUsage();
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        const usedMem = totalMem - freeMem;
        
        // Seuils d'alerte (configurable)
        const memoryThreshold = 0.9; // 90%
        const heapThreshold = 0.8; // 80%
        
        const memoryUsagePercent = usedMem / totalMem;
        const heapUsagePercent = memUsage.heapUsed / memUsage.heapTotal;
        
        let status = 'ok';
        const warnings = [];
        
        if (memoryUsagePercent > memoryThreshold) {
            status = 'warning';
            warnings.push('High system memory usage');
        }
        
        if (heapUsagePercent > heapThreshold) {
            status = 'warning';
            warnings.push('High heap usage');
        }
        
        return {
            status,
            warnings: warnings.length > 0 ? warnings : undefined,
            system: {
                total: FileService.formatFileSize(totalMem),
                free: FileService.formatFileSize(freeMem),
                used: FileService.formatFileSize(usedMem),
                usagePercent: Math.round(memoryUsagePercent * 100)
            }
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkMemoryDetailed() {
    try {
        const memUsage = process.memoryUsage();
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        const usedMem = totalMem - freeMem;
        
        const memoryUsagePercent = usedMem / totalMem;
        const heapUsagePercent = memUsage.heapUsed / memUsage.heapTotal;
        
        let status = 'ok';
        const warnings = [];
        
        if (memoryUsagePercent > 0.9) {
            status = 'warning';
            warnings.push('High system memory usage');
        }
        
        if (heapUsagePercent > 0.8) {
            status = 'warning';
            warnings.push('High heap usage');
        }
        
        return {
            status,
            warnings: warnings.length > 0 ? warnings : undefined,
            system: {
                total: FileService.formatFileSize(totalMem),
                free: FileService.formatFileSize(freeMem),
                used: FileService.formatFileSize(usedMem),
                usagePercent: Math.round(memoryUsagePercent * 100)
            },
            process: {
                heapTotal: FileService.formatFileSize(memUsage.heapTotal),
                heapUsed: FileService.formatFileSize(memUsage.heapUsed),
                heapUsagePercent: Math.round(heapUsagePercent * 100),
                external: FileService.formatFileSize(memUsage.external),
                arrayBuffers: FileService.formatFileSize(memUsage.arrayBuffers || 0),
                rss: FileService.formatFileSize(memUsage.rss)
            }
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkQueue() {
    try {
        const queueStats = await getQueueStats();
        
        if (!queueStats) {
            return {
                status: 'error',
                error: 'Unable to get queue stats'
            };
        }
        
        // V√©rifier s'il y a trop de jobs en √©chec
        const failureRate = queueStats.total > 0 ? 
            (queueStats.failed / queueStats.total) * 100 : 0;
        
        let status = 'ok';
        const warnings = [];
        
        if (failureRate > 20) { // Plus de 20% d'√©checs
            status = 'warning';
            warnings.push('High job failure rate');
        }
        
        if (queueStats.waiting > 100) { // Plus de 100 jobs en attente
            status = 'warning';
            warnings.push('High number of waiting jobs');
        }
        
        return {
            status,
            warnings: warnings.length > 0 ? warnings : undefined,
            stats: queueStats,
            failureRate: Math.round(failureRate)
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkDependencies() {
    try {
        const dependencies = {};
        
        // V√©rifier Sharp
        try {
            const sharp = require('sharp');
            const sharpVersion = sharp.versions;
            dependencies.sharp = {
                status: 'ok',
                version: sharpVersion
            };
        } catch (error) {
            dependencies.sharp = {
                status: 'error',
                error: 'Sharp not available'
            };
        }
        
        // V√©rifier FFmpeg (si configur√©)
        const ffmpegPath = process.env.FFMPEG_PATH;
        if (ffmpegPath) {
            try {
                const { exec } = require('child_process');
                const { promisify } = require('util');
                const execAsync = promisify(exec);
                
                const { stdout } = await execAsync(`${ffmpegPath} -version`);
                const versionMatch = stdout.match(/ffmpeg version ([^\s]+)/);
                
                dependencies.ffmpeg = {
                    status: 'ok',
                    path: ffmpegPath,
                    version: versionMatch ? versionMatch[1] : 'unknown'
                };
            } catch (error) {
                dependencies.ffmpeg = {
                    status: 'error',
                    path: ffmpegPath,
                    error: 'FFmpeg not available or invalid path'
                };
            }
        }
        
        // D√©terminer le statut global
        const allOk = Object.values(dependencies).every(dep => dep.status === 'ok');
        
        return {
            status: allOk ? 'ok' : 'warning',
            dependencies
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function collectMetrics() {
    try {
        // M√©triques des jobs
        const jobStats = await JobService.getJobStats();
        
        // M√©triques de la queue
        const queueStats = await getQueueStats();
        
        // M√©triques syst√®me
        const memUsage = process.memoryUsage();
        const cpuUsage = process.cpuUsage();
        
        // M√©triques de performance r√©centes
        const recentJobs = await JobService.getAllJobs(100);
        const last24h = new Date(Date.now() - 24 * 60 * 60 * 1000);
        const jobs24h = recentJobs.filter(job => 
            new Date(job.createdAt) >= last24h
        );
        
        const completedJobs24h = jobs24h.filter(job => job.status === 'completed');
        
        // Calculs de performance
        const totalProcessed24h = completedJobs24h.reduce((sum, job) => 
            sum + (parseInt(job.size) || 0), 0
        );
        
        const avgProcessingTime = completedJobs24h.length > 0 ?
            completedJobs24h.reduce((sum, job) => {
                const processingTime = new Date(job.updatedAt) - new Date(job.createdAt);
                return sum + processingTime;
            }, 0) / completedJobs24h.length : 0;
        
        return {
            jobs: jobStats,
            queue: queueStats,
            performance: {
                jobs24h: jobs24h.length,
                completed24h: completedJobs24h.length,
                totalProcessed24h,
                totalProcessed24hFormatted: FileService.formatFileSize(totalProcessed24h),
                avgProcessingTime: Math.round(avgProcessingTime / 1000), // en secondes
                throughput: Math.round(completedJobs24h.length / 24 * 100) / 100 // jobs/heure
            },
            system: {
                memory: {
                    heapUsed: memUsage.heapUsed,
                    heapTotal: memUsage.heapTotal,
                    external: memUsage.external,
                    rss: memUsage.rss
                },
                cpu: {
                    user: cpuUsage.user,
                    system: cpuUsage.system
                },
                uptime: process.uptime(),
                loadAverage: os.loadavg()
            }
        };
    } catch (error) {
        logger.error('Erreur collecte m√©triques:', error);
        return {
            error: 'Unable to collect metrics',
            message: error.message
        };
    }
}

/**
 * GET /api/health/metrics
 * M√©triques syst√®me pour monitoring externe (Prometheus, etc.)
 */
router.get('/metrics', async (req, res) => {
    try {
        const metrics = await collectMetrics();
        
        // Format Prometheus (optionnel)
        if (req.get('Accept') === 'text/plain') {
            const prometheusMetrics = convertToPrometheusFormat(metrics);
            res.setHeader('Content-Type', 'text/plain; version=0.0.4');
            res.send(prometheusMetrics);
        } else {
            res.json({
                success: true,
                timestamp: new Date().toISOString(),
                metrics
            });
        }
    } catch (error) {
        logger.error('Erreur m√©triques:', error);
        res.status(500).json({
            success: false,
            error: 'Unable to collect metrics'
        });
    }
});

/**
 * Convertir les m√©triques au format Prometheus
 */
function convertToPrometheusFormat(metrics) {
    let output = '';
    
    // M√©triques des jobs
    if (metrics.jobs) {
        output += `# HELP file_optimizer_jobs_total Total number of jobs by status\n`;
        output += `# TYPE file_optimizer_jobs_total counter\n`;
        Object.entries(metrics.jobs).forEach(([status, count]) => {
            if (typeof count === 'number') {
                output += `file_optimizer_jobs_total{status="${status}"} ${count}\n`;
            }
        });
    }
    
    // M√©triques de performance
    if (metrics.performance) {
        output += `# HELP file_optimizer_throughput_jobs_per_hour Jobs processed per hour\n`;
        output += `# TYPE file_optimizer_throughput_jobs_per_hour gauge\n`;
        output += `file_optimizer_throughput_jobs_per_hour ${metrics.performance.throughput || 0}\n`;
        
        output += `# HELP file_optimizer_avg_processing_time_seconds Average processing time in seconds\n`;
        output += `# TYPE file_optimizer_avg_processing_time_seconds gauge\n`;
        output += `file_optimizer_avg_processing_time_seconds ${metrics.performance.avgProcessingTime || 0}\n`;
    }
    
    // M√©triques syst√®me
    if (metrics.system && metrics.system.memory) {
        output += `# HELP process_resident_memory_bytes Resident memory size in bytes\n`;
        output += `# TYPE process_resident_memory_bytes gauge\n`;
        output += `process_resident_memory_bytes ${metrics.system.memory.rss}\n`;
        
        output += `# HELP nodejs_heap_size_used_bytes Process heap space used in bytes\n`;
        output += `# TYPE nodejs_heap_size_used_bytes gauge\n`;
        output += `nodejs_heap_size_used_bytes ${metrics.system.memory.heapUsed}\n`;
    }
    
    return output;
}

module.exports = router;


================================================
File: backend/src/routes/index.js
================================================
// backend/src/routes/index.js
const express = require('express');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const cors = require('cors');

const uploadRoutes = require('./upload');
const statusRoutes = require('./status');
const downloadRoutes = require('./download');
const processRoutes = require('./process');
const healthRoutes = require('./health');

const logger = require('../utils/logger');

const router = express.Router();

/**
 * Configuration CORS
 */
const corsOptions = {
    origin: function (origin, callback) {
        // Permettre les requ√™tes sans origin (apps mobiles, Postman, etc.)
        if (!origin) return callback(null, true);
        
        const allowedOrigins = (process.env.CORS_ORIGIN || 'http://localhost:3000').split(',');
        
        if (allowedOrigins.indexOf(origin) !== -1 || allowedOrigins.includes('*')) {
            callback(null, true);
        } else {
            logger.security('CORS origin bloqu√©', { origin, allowedOrigins });
            callback(new Error('Non autoris√© par CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
    exposedHeaders: ['X-Total-Count', 'X-Original-Size', 'X-Compressed-Size', 'X-Compression-Ratio']
};

/**
 * Rate limiting global
 */
const globalRateLimit = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: parseInt(process.env.RATE_LIMIT) || 100, // 100 requ√™tes par 15min
    message: {
        success: false,
        error: 'Trop de requ√™tes, veuillez ralentir',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Utiliser l'IP comme cl√©
        return req.ip;
    },
    skip: (req) => {
        // Skip rate limiting pour les health checks
        if (req.path.startsWith('/api/health')) return true;
        
        // Skip en d√©veloppement si configur√©
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    },
    onLimitReached: (req) => {
        logger.security('Rate limit global atteint', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            path: req.path,
            method: req.method
        });
    }
});

/**
 * Middleware de logging des requ√™tes
 */
const requestLogger = (req, res, next) => {
    const start = Date.now();
    
    // Log de la requ√™te entrante
    logger.http('Requ√™te entrante', {
        method: req.method,
        path: req.path,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        contentLength: req.get('Content-Length'),
        contentType: req.get('Content-Type')
    });

    // Override de res.end pour logger la r√©ponse
    const originalEnd = res.end;
    res.end = function(...args) {
        const duration = Date.now() - start;
        
        logger.http('R√©ponse envoy√©e', {
            method: req.method,
            path: req.path,
            statusCode: res.statusCode,
            duration: `${duration}ms`,
            contentLength: res.get('Content-Length'),
            ip: req.ip
        });

        // M√©triques de performance
        if (duration > 5000) { // Plus de 5 secondes
            logger.performance('Requ√™te lente d√©tect√©e', duration, {
                method: req.method,
                path: req.path,
                statusCode: res.statusCode
            });
        }

        originalEnd.apply(this, args);
    };

    next();
};

/**
 * Middleware de validation des headers
 */
const validateHeaders = (req, res, next) => {
    // V√©rifier Content-Type pour les requ√™tes POST/PUT
    if (['POST', 'PUT'].includes(req.method)) {
        const contentType = req.get('Content-Type');
        
        if (req.path.includes('/upload')) {
            // Les uploads doivent √™tre multipart/form-data
            if (!contentType || !contentType.includes('multipart/form-data')) {
                logger.security('Content-Type invalide pour upload', {
                    contentType,
                    path: req.path,
                    ip: req.ip
                });
                return res.status(400).json({
                    success: false,
                    error: 'Content-Type multipart/form-data requis pour les uploads'
                });
            }
        } else if (!req.path.includes('/upload')) {
            // Les autres requ√™tes doivent √™tre JSON
            if (contentType && !contentType.includes('application/json')) {
                logger.security('Content-Type invalide', {
                    contentType,
                    path: req.path,
                    ip: req.ip
                });
                return res.status(400).json({
                    success: false,
                    error: 'Content-Type application/json requis'
                });
            }
        }
    }

    next();
};

/**
 * Middleware d'authentification (optionnel)
 */
const authenticate = (req, res, next) => {
    // Si l'authentification est d√©sactiv√©e, passer
    if (process.env.AUTH_ENABLED !== 'true') {
        return next();
    }

    const apiKey = req.get('Authorization') || req.query.api_key;
    const expectedKey = process.env.API_KEY;

    if (!expectedKey) {
        logger.error('API_KEY non configur√©e mais AUTH_ENABLED=true');
        return res.status(500).json({
            success: false,
            error: 'Configuration d\'authentification incorrecte'
        });
    }

    if (!apiKey || apiKey.replace('Bearer ', '') !== expectedKey) {
        logger.security('Tentative d\'acc√®s non autoris√©', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            path: req.path,
            providedKey: apiKey ? 'pr√©sente' : 'absente'
        });
        
        return res.status(401).json({
            success: false,
            error: 'Cl√© API invalide ou manquante'
        });
    }

    next();
};

/**
 * Middleware de gestion d'erreurs
 */
const errorHandler = (error, req, res, next) => {
    logger.error('Erreur non g√©r√©e dans les routes:', error, {
        method: req.method,
        path: req.path,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });

    // Erreurs sp√©cifiques
    if (error.code === 'LIMIT_FILE_SIZE') {
        return res.status(413).json({
            success: false,
            error: 'Fichier trop volumineux'
        });
    }

    if (error.message === 'Non autoris√© par CORS') {
        return res.status(403).json({
            success: false,
            error: 'Origine non autoris√©e'
        });
    }

    // Erreur g√©n√©rique
    res.status(500).json({
        success: false,
        error: 'Erreur interne du serveur',
        message: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
};

/**
 * Configuration des middlewares globaux
 */
router.use(helmet({
    crossOriginEmbedderPolicy: false, // N√©cessaire pour les uploads
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "blob:"],
            connectSrc: ["'self'", "ws:", "wss:"]
        }
    }
}));

router.use(cors(corsOptions));
router.use(globalRateLimit);
router.use(requestLogger);
router.use(validateHeaders);
router.use(authenticate);

/**
 * Routes principales
 */

// Health checks (sans authentification pour les load balancers)
router.use('/health', healthRoutes);

// API v1
router.use('/upload', uploadRoutes);
router.use('/status', statusRoutes);
router.use('/download', downloadRoutes);
router.use('/process', processRoutes);

/**
 * Route d'information g√©n√©rale
 */
router.get('/', (req, res) => {
    res.json({
        success: true,
        message: 'API Optimiseur de Fichiers Multim√©dia',
        version: process.env.npm_package_version || '2.0.0',
        endpoints: {
            upload: '/api/upload',
            status: '/api/status',
            download: '/api/download',
            process: '/api/process',
            health: '/api/health'
        },
        documentation: 'https://github.com/your-username/file-optimizer/wiki/API',
        support: 'https://github.com/your-username/file-optimizer/issues',
        timestamp: new Date().toISOString()
    });
});

/**
 * Route 404 pour les endpoints non trouv√©s
 */
router.use('*', (req, res) => {
    logger.warn('Endpoint non trouv√©', {
        method: req.method,
        path: req.originalUrl,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });

    res.status(404).json({
        success: false,
        error: 'Endpoint non trouv√©',
        path: req.originalUrl,
        availableEndpoints: [
            '/api/upload',
            '/api/status',
            '/api/download',
            '/api/process',
            '/api/health'
        ]
    });
});

/**
 * Gestionnaire d'erreurs global
 */
router.use(errorHandler);

module.exports = router;


================================================
File: backend/src/routes/process.js
================================================
// backend/src/routes/process.js
const express = require('express');
const rateLimit = require('express-rate-limit');

const JobService = require('../services/jobService');
const ProcessingService = require('../services/processingService');
const { addJobToQueue, getQueueStats } = require('../services/queueService');
const { ValidationService, validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * Rate limiting pour les routes de traitement
 */
const processRateLimit = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: parseInt(process.env.PROCESS_RATE_LIMIT) || 30, // 30 requ√™tes par minute
    message: {
        success: false,
        error: 'Trop de requ√™tes de traitement'
    },
    standardHeaders: true,
    legacyHeaders: false,
    skip: (req) => {
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    }
});

/**
 * POST /api/process/:jobId
 * D√©marrer le traitement d'un job sp√©cifique
 */
router.post('/:jobId',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            const { priority = 'normal', settings = {} } = req.body;
            
            const requestLogger = logger.withContext({ 
                jobId, 
                ip: req.ip,
                action: 'manual_process'
            });

            requestLogger.info('Demande traitement manuel', { priority, settings });

            // R√©cup√©rer le job
            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouv√©'
                });
            }

            // V√©rifier l'√©tat du job
            if (job.status === 'processing') {
                return res.status(400).json({
                    success: false,
                    error: 'Job d√©j√† en cours de traitement',
                    status: job.status,
                    progress: job.progress
                });
            }

            if (job.status === 'completed') {
                return res.status(400).json({
                    success: false,
                    error: 'Job d√©j√† termin√©',
                    status: job.status
                });
            }

            // Valider les nouveaux param√®tres si fournis
            if (Object.keys(settings).length > 0) {
                const fileType = job.type;
                const currentSettings = { ...job.settings, ...settings };
                
                const validation = ValidationService.validateSettings(fileType, currentSettings);
                if (!validation.isValid) {
                    return res.status(400).json({
                        success: false,
                        error: 'Param√®tres invalides',
                        details: validation.errors
                    });
                }

                // Mettre √† jour les param√®tres du job
                await JobService.updateJob(jobId, {
                    settings: validation.validatedSettings,
                    status: 'uploaded',
                    progress: 0,
                    error: null,
                    updatedAt: new Date().toISOString()
                });
                
                job.settings = validation.validatedSettings;
            }

            // Calculer la priorit√©
            let queuePriority = 5; // Normal
            switch (priority) {
                case 'low':
                    queuePriority = 1;
                    break;
                case 'high':
                    queuePriority = 10;
                    break;
                case 'urgent':
                    queuePriority = 15;
                    break;
            }

            // Ajouter √† la queue avec priorit√©
            await addJobToQueue(job, { priority: queuePriority });
            await JobService.updateJob(jobId, { status: 'queued' });

            requestLogger.job(jobId, 'Job ajout√© √† la queue manuellement', { priority });

            // Estimer le temps de traitement
            const estimatedTime = ProcessingService.estimateProcessingTime(job.type, job.size);

            res.json({
                success: true,
                message: 'Job ajout√© √† la queue de traitement',
                jobId,
                status: 'queued',
                priority,
                estimatedTime,
                queuePosition: await getQueuePosition(jobId)
            });

        } catch (error) {
            logger.error(`Erreur traitement job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/batch
 * Traitement par lot de plusieurs jobs
 */
router.post('/batch',
    processRateLimit,
    async (req, res) => {
        try {
            const { jobIds, settings = {}, priority = 'normal' } = req.body;
            
            if (!Array.isArray(jobIds) || jobIds.length === 0) {
                return res.status(400).json({
                    success: false,
                    error: 'Liste de jobs requise'
                });
            }

            if (jobIds.length > 10) {
                return res.status(400).json({
                    success: false,
                    error: 'Maximum 10 jobs par batch'
                });
            }

            const requestLogger = logger.withContext({ 
                ip: req.ip,
                action: 'batch_process',
                jobCount: jobIds.length
            });

            requestLogger.info('Demande traitement batch', { jobIds, priority });

            const results = [];
            const errors = [];

            // Traiter chaque job
            for (const jobId of jobIds) {
                try {
                    // Validation de l'ID
                    const validation = ValidationService.validateJobId(jobId);
                    if (!validation.isValid) {
                        errors.push({
                            jobId,
                            error: 'ID de job invalide'
                        });
                        continue;
                    }

                    // R√©cup√©rer le job
                    const job = await JobService.getJob(jobId);
                    if (!job) {
                        errors.push({
                            jobId,
                            error: 'Job non trouv√©'
                        });
                        continue;
                    }

                    // V√©rifier l'√©tat
                    if (['processing', 'completed'].includes(job.status)) {
                        errors.push({
                            jobId,
                            error: `Job ${job.status}`,
                            status: job.status
                        });
                        continue;
                    }

                    // Appliquer les param√®tres globaux si fournis
                    if (Object.keys(settings).length > 0) {
                        const currentSettings = { ...job.settings, ...settings };
                        const settingsValidation = ValidationService.validateSettings(job.type, currentSettings);
                        
                        if (settingsValidation.isValid) {
                            await JobService.updateJob(jobId, {
                                settings: settingsValidation.validatedSettings,
                                status: 'uploaded',
                                progress: 0
                            });
                        }
                    }

                    // Ajouter √† la queue
                    await addJobToQueue(job, { priority: priority === 'high' ? 10 : 5 });
                    await JobService.updateJob(jobId, { status: 'queued' });

                    results.push({
                        jobId,
                        status: 'queued',
                        message: 'Ajout√© √† la queue'
                    });

                } catch (error) {
                    errors.push({
                        jobId,
                        error: error.message
                    });
                }
            }

            requestLogger.info('Traitement batch termin√©', {
                processed: results.length,
                errors: errors.length
            });

            res.json({
                success: true,
                message: `${results.length} jobs trait√©s`,
                results,
                errors: errors.length > 0 ? errors : undefined,
                summary: {
                    total: jobIds.length,
                    processed: results.length,
                    failed: errors.length
                }
            });

        } catch (error) {
            logger.error('Erreur traitement batch:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/:jobId/pause
 * Mettre en pause un job en cours (si possible)
 */
router.post('/:jobId/pause',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande pause job ${jobId}`, { ip: req.ip });

            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouv√©'
                });
            }

            if (job.status !== 'processing') {
                return res.status(400).json({
                    success: false,
                    error: 'Seuls les jobs en cours peuvent √™tre mis en pause',
                    status: job.status
                });
            }

            // Note: La mise en pause d√©pend de l'impl√©mentation du worker
            // Pour l'instant, on marque le job comme "paused" dans Redis
            await JobService.updateJob(jobId, {
                status: 'paused',
                pausedAt: new Date().toISOString()
            });

            res.json({
                success: true,
                message: 'Job mis en pause',
                jobId,
                status: 'paused'
            });

        } catch (error) {
            logger.error(`Erreur pause job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/:jobId/resume
 * Reprendre un job en pause
 */
router.post('/:jobId/resume',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande reprise job ${jobId}`, { ip: req.ip });

            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouv√©'
                });
            }

            if (job.status !== 'paused') {
                return res.status(400).json({
                    success: false,
                    error: 'Seuls les jobs en pause peuvent √™tre repris',
                    status: job.status
                });
            }

            // Remettre en queue
            await addJobToQueue(job);
            await JobService.updateJob(jobId, {
                status: 'queued',
                pausedAt: null,
                resumedAt: new Date().toISOString()
            });

            res.json({
                success: true,
                message: 'Job repris',
                jobId,
                status: 'queued'
            });

        } catch (error) {
            logger.error(`Erreur reprise job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/:jobId/cancel
 * Annuler un job en attente ou en cours
 */
router.post('/:jobId/cancel',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande annulation job ${jobId}`, { ip: req.ip });

            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouv√©'
                });
            }

            if (job.status === 'completed') {
                return res.status(400).json({
                    success: false,
                    error: 'Job d√©j√† termin√©, impossible d\'annuler',
                    status: job.status
                });
            }

            if (job.status === 'cancelled') {
                return res.status(400).json({
                    success: false,
                    error: 'Job d√©j√† annul√©',
                    status: job.status
                });
            }

            // Marquer comme annul√©
            await JobService.updateJob(jobId, {
                status: 'cancelled',
                cancelledAt: new Date().toISOString(),
                progress: 0
            });

            // TODO: Si en cours de traitement, envoyer signal d'arr√™t au worker

            logger.job(jobId, 'Job annul√©');

            res.json({
                success: true,
                message: 'Job annul√©',
                jobId,
                status: 'cancelled'
            });

        } catch (error) {
            logger.error(`Erreur annulation job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/process/queue
 * Informations sur la queue de traitement
 */
router.get('/queue', processRateLimit, async (req, res) => {
    try {
        const queueStats = await getQueueStats();
        
        if (!queueStats) {
            return res.status(500).json({
                success: false,
                error: 'Impossible de r√©cup√©rer les stats de la queue'
            });
        }

        // R√©cup√©rer quelques jobs r√©cents en attente
        const recentJobs = await JobService.getAllJobs(20);
        const queuedJobs = recentJobs
            .filter(job => job.status === 'queued')
            .slice(0, 10)
            .map(job => ({
                id: job.id,
                originalName: job.originalName,
                type: job.type,
                size: parseInt(job.size),
                sizeFormatted: require('../services/fileService').formatFileSize(parseInt(job.size)),
                createdAt: job.createdAt,
                estimatedTime: ProcessingService.estimateProcessingTime(job.type, parseInt(job.size))
            }));

        res.json({
            success: true,
            queue: {
                stats: queueStats,
                jobs: queuedJobs,
                timestamp: new Date().toISOString()
            }
        });

    } catch (error) {
        logger.error('Erreur r√©cup√©ration queue:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * GET /api/process/settings/:type
 * Obtenir les param√®tres par d√©faut pour un type de fichier
 */
router.get('/settings/:type',
    processRateLimit,
    async (req, res) => {
        try {
            const { type } = req.params;
            
            // Valider le type
            const validTypes = ['image', 'video', 'audio', 'document'];
            if (!validTypes.includes(type)) {
                return res.status(400).json({
                    success: false,
                    error: 'Type de fichier invalide',
                    validTypes
                });
            }

            const defaultSettings = ProcessingService.getDefaultSettings(type);
            
            // Ajouter des informations sur les options disponibles
            const settingsInfo = getSettingsInfo(type);

            res.json({
                success: true,
                type,
                defaultSettings,
                options: settingsInfo,
                description: getTypeDescription(type)
            });

        } catch (error) {
            logger.error('Erreur r√©cup√©ration param√®tres:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/validate-settings
 * Valider des param√®tres sans cr√©er de job
 */
router.post('/validate-settings',
    processRateLimit,
    async (req, res) => {
        try {
            const { type, settings } = req.body;
            
            if (!type || !settings) {
                return res.status(400).json({
                    success: false,
                    error: 'Type et param√®tres requis'
                });
            }

            const validation = ValidationService.validateSettings(type, settings);
            
            if (validation.isValid) {
                res.json({
                    success: true,
                    message: 'Param√®tres valides',
                    validatedSettings: validation.validatedSettings
                });
            } else {
                res.status(400).json({
                    success: false,
                    error: 'Param√®tres invalides',
                    details: validation.errors
                });
            }

        } catch (error) {
            logger.error('Erreur validation param√®tres:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/process/estimate
 * Estimation du temps de traitement
 */
router.get('/estimate',
    processRateLimit,
    async (req, res) => {
        try {
            const { type, size } = req.query;
            
            if (!type || !size) {
                return res.status(400).json({
                    success: false,
                    error: 'Type et taille requis'
                });
            }

            const fileSize = parseInt(size);
            if (isNaN(fileSize) || fileSize <= 0) {
                return res.status(400).json({
                    success: false,
                    error: 'Taille invalide'
                });
            }

            const estimatedTime = ProcessingService.estimateProcessingTime(type, fileSize);
            const queueStats = await getQueueStats();
            
            // Estimation de l'attente en queue
            let queueWaitTime = 0;
            if (queueStats && queueStats.waiting > 0) {
                // Approximation: 30 secondes par job en attente
                queueWaitTime = queueStats.waiting * 30;
            }

            const totalTime = estimatedTime + queueWaitTime;

            res.json({
                success: true,
                estimation: {
                    processingTime: estimatedTime,
                    queueWaitTime,
                    totalTime,
                    queuePosition: queueStats ? queueStats.waiting + 1 : 1,
                    fileSize,
                    fileSizeFormatted: require('../services/fileService').formatFileSize(fileSize),
                    type
                }
            });

        } catch (error) {
            logger.error('Erreur estimation:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * Fonction utilitaire pour obtenir la position dans la queue
 */
async function getQueuePosition(jobId) {
    try {
        const queueStats = await getQueueStats();
        return queueStats ? queueStats.waiting : 0;
    } catch (error) {
        logger.error('Erreur position queue:', error);
        return 0;
    }
}

/**
 * Informations d√©taill√©es sur les param√®tres par type
 */
function getSettingsInfo(type) {
    const settingsInfo = {
        image: {
            quality: {
                type: 'number',
                min: 1,
                max: 100,
                default: 80,
                description: 'Qualit√© de compression (1-100)'
            },
            maxWidth: {
                type: 'number',
                min: 100,
                max: 8000,
                default: 1920,
                description: 'Largeur maximale en pixels'
            },
            maxHeight: {
                type: 'number',
                min: 100,
                max: 8000,
                default: 1080,
                description: 'Hauteur maximale en pixels'
            },
            format: {
                type: 'string',
                options: ['auto', 'jpeg', 'png', 'webp', 'avif'],
                default: 'auto',
                description: 'Format de sortie'
            },
            removeMetadata: {
                type: 'boolean',
                default: true,
                description: 'Supprimer les m√©tadonn√©es EXIF'
            }
        },
        video: {
            codec: {
                type: 'string',
                options: ['h264', 'h265', 'vp9', 'av1'],
                default: 'h264',
                description: 'Codec vid√©o'
            },
            crf: {
                type: 'number',
                min: 18,
                max: 51,
                default: 23,
                description: 'Facteur de compression (plus bas = meilleure qualit√©)'
            },
            preset: {
                type: 'string',
                options: ['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'],
                default: 'medium',
                description: 'Vitesse d\'encodage vs compression'
            }
        },
        audio: {
            codec: {
                type: 'string',
                options: ['aac', 'mp3', 'ogg', 'flac'],
                default: 'aac',
                description: 'Codec audio'
            },
            bitrate: {
                type: 'string',
                options: ['64k', '128k', '192k', '256k', '320k'],
                default: '128k',
                description: 'D√©bit binaire'
            },
            sampleRate: {
                type: 'number',
                options: [22050, 44100, 48000],
                default: 44100,
                description: 'Fr√©quence d\'√©chantillonnage'
            }
        },
        document: {
            compress: {
                type: 'boolean',
                default: true,
                description: 'Activer la compression'
            },
            quality: {
                type: 'number',
                min: 1,
                max: 100,
                default: 80,
                description: 'Qualit√© des images int√©gr√©es'
            },
            removeMetadata: {
                type: 'boolean',
                default: true,
                description: 'Supprimer les m√©tadonn√©es'
            }
        }
    };

    return settingsInfo[type] || {};
}

/**
 * Description des types de fichiers
 */
function getTypeDescription(type) {
    const descriptions = {
        image: 'Compression et optimisation d\'images avec redimensionnement automatique',
        video: 'Compression vid√©o avec codecs modernes et optimisation pour le streaming',
        audio: 'Compression audio avec normalisation et conversion de format',
        document: 'Optimisation de documents PDF avec compression des images int√©gr√©es'
    };

    return descriptions[type] || 'Type de fichier support√©';
}

module.exports = router;


================================================
File: backend/src/routes/status.js
================================================
// backend/src/routes/status.js
const express = require('express');
const rateLimit = require('express-rate-limit');

const JobService = require('../services/jobService');
const { getQueueStats, getActiveJobs } = require('../services/queueService');
const { ValidationService, validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * Rate limiting pour les routes de statut
 */
const statusRateLimit = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: parseInt(process.env.STATUS_RATE_LIMIT) || 60, // 60 requ√™tes par minute
    message: {
        success: false,
        error: 'Trop de requ√™tes de statut'
    },
    standardHeaders: true,
    legacyHeaders: false,
    skip: (req) => {
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    }
});

/**
 * GET /api/status/:jobId
 * Obtenir le statut d'un job sp√©cifique
 */
router.get('/:jobId', 
    statusRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.debug('Demande statut job', { jobId, ip: req.ip });

            // R√©cup√©rer le job
            const job = await JobService.getJob(jobId);
            
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouv√©',
                    jobId
                });
            }

            // Calculer des m√©triques additionnelles
            const currentTime = new Date();
            const createdTime = new Date(job.createdAt);
            const updatedTime = new Date(job.updatedAt);
            
            const timeElapsed = Math.floor((currentTime - createdTime) / 1000); // en secondes
            const timeSinceUpdate = Math.floor((currentTime - updatedTime) / 1000);

            // Calculer l'ETA si en cours de traitement
            let eta = null;
            if (job.status === 'processing' && job.progress > 0) {
                const remainingProgress = 100 - job.progress;
                const progressRate = job.progress / timeElapsed; // progress par seconde
                if (progressRate > 0) {
                    eta = Math.floor(remainingProgress / progressRate);
                }
            }

            // Pr√©parer la r√©ponse
            const response = {
                success: true,
                job: {
                    id: job.id,
                    originalName: job.originalName,
                    type: job.type,
                    status: job.status,
                    progress: parseInt(job.progress) || 0,
                    size: parseInt(job.size),
                    sizeFormatted: job.size ? require('../services/fileService').formatFileSize(parseInt(job.size)) : null,
                    settings: job.settings,
                    createdAt: job.createdAt,
                    updatedAt: job.updatedAt,
                    timeElapsed,
                    timeSinceUpdate,
                    eta
                }
            };

            // Ajouter des informations sp√©cifiques au statut
            switch (job.status) {
                case 'completed':
                    response.job.compressedSize = parseInt(job.compressedSize);
                    response.job.compressedSizeFormatted = job.compressedSize ? 
                        require('../services/fileService').formatFileSize(parseInt(job.compressedSize)) : null;
                    response.job.compressionRatio = parseInt(job.compressionRatio) || 0;
                    response.job.outputPath = job.outputPath;
                    
                    // Calcul des √©conomies
                    if (job.size && job.compressedSize) {
                        const savedBytes = parseInt(job.size) - parseInt(job.compressedSize);
                        response.job.savedBytes = savedBytes;
                        response.job.savedBytesFormatted = require('../services/fileService').formatFileSize(savedBytes);
                    }
                    break;

                case 'error':
                    response.job.error = job.error;
                    break;

                case 'processing':
                    // Informations de progression d√©taill√©es
                    if (eta) {
                        response.job.etaFormatted = formatDuration(eta);
                    }
                    break;
            }

            res.json(response);

        } catch (error) {
            logger.error(`Erreur r√©cup√©ration statut job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/status
 * Obtenir la liste des jobs avec pagination et filtres
 */
router.get('/',
    statusRateLimit,
    validateRequest.pagination,
    validateRequest.jobFilters,
    async (req, res) => {
        try {
            const { page, limit, sortBy, sortOrder } = req.query;
            const filters = {
                status: req.query.status,
                type: req.query.type,
                dateFrom: req.query.dateFrom,
                dateTo: req.query.dateTo,
                minSize: req.query.minSize,
                maxSize: req.query.maxSize
            };

            logger.debug('Liste jobs demand√©e', { 
                page, limit, sortBy, sortOrder, filters, ip: req.ip 
            });

            // R√©cup√©rer tous les jobs (√† optimiser avec vraie pagination plus tard)
            let jobs = await JobService.getAllJobs(limit * 10); // Buffer pour filtrage

            // Appliquer les filtres
            if (filters.status) {
                jobs = jobs.filter(job => job.status === filters.status);
            }
            
            if (filters.type) {
                jobs = jobs.filter(job => job.type === filters.type);
            }

            if (filters.dateFrom) {
                const fromDate = new Date(filters.dateFrom);
                jobs = jobs.filter(job => new Date(job.createdAt) >= fromDate);
            }

            if (filters.dateTo) {
                const toDate = new Date(filters.dateTo);
                jobs = jobs.filter(job => new Date(job.createdAt) <= toDate);
            }

            if (filters.minSize) {
                jobs = jobs.filter(job => parseInt(job.size) >= parseInt(filters.minSize));
            }

            if (filters.maxSize) {
                jobs = jobs.filter(job => parseInt(job.size) <= parseInt(filters.maxSize));
            }

            // Tri
            jobs.sort((a, b) => {
                let valueA = a[sortBy];
                let valueB = b[sortBy];

                // Conversion pour les champs num√©riques
                if (['size', 'progress'].includes(sortBy)) {
                    valueA = parseInt(valueA) || 0;
                    valueB = parseInt(valueB) || 0;
                }

                // Conversion pour les dates
                if (['createdAt', 'updatedAt'].includes(sortBy)) {
                    valueA = new Date(valueA);
                    valueB = new Date(valueB);
                }

                if (sortOrder === 'asc') {
                    return valueA > valueB ? 1 : -1;
                } else {
                    return valueA < valueB ? 1 : -1;
                }
            });

            // Pagination
            const startIndex = (page - 1) * limit;
            const endIndex = startIndex + limit;
            const paginatedJobs = jobs.slice(startIndex, endIndex);

            // Enrichir les jobs avec des informations calcul√©es
            const enrichedJobs = paginatedJobs.map(job => {
                const currentTime = new Date();
                const createdTime = new Date(job.createdAt);
                
                return {
                    ...job,
                    size: parseInt(job.size),
                    progress: parseInt(job.progress) || 0,
                    sizeFormatted: job.size ? require('../services/fileService').formatFileSize(parseInt(job.size)) : null,
                    timeElapsed: Math.floor((currentTime - createdTime) / 1000),
                    compressedSize: job.compressedSize ? parseInt(job.compressedSize) : null,
                    compressionRatio: job.compressionRatio ? parseInt(job.compressionRatio) : null
                };
            });

            // M√©tadonn√©es de pagination
            const totalJobs = jobs.length;
            const totalPages = Math.ceil(totalJobs / limit);
            const hasNextPage = page < totalPages;
            const hasPrevPage = page > 1;

            res.json({
                success: true,
                jobs: enrichedJobs,
                pagination: {
                    page,
                    limit,
                    total: totalJobs,
                    pages: totalPages,
                    hasNext: hasNextPage,
                    hasPrev: hasPrevPage
                },
                filters: filters,
                sort: { sortBy, sortOrder }
            });

        } catch (error) {
            logger.error('Erreur r√©cup√©ration liste jobs:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/status/stats
 * Statistiques globales du syst√®me
 */
router.get('/stats/global', statusRateLimit, async (req, res) => {
    try {
        logger.debug('Statistiques globales demand√©es', { ip: req.ip });

        // R√©cup√©rer les stats des jobs
        const jobStats = await JobService.getJobStats();
        
        // R√©cup√©rer les stats de la queue
        const queueStats = await getQueueStats();
        
        // R√©cup√©rer les jobs actifs
        const activeJobs = await getActiveJobs();

        // Calculer des m√©triques additionnelles
        const currentTime = new Date();
        const last24h = new Date(currentTime.getTime() - 24 * 60 * 60 * 1000);
        
        // R√©cup√©rer les jobs des derni√®res 24h
        const recentJobs = await JobService.getAllJobs(1000);
        const jobs24h = recentJobs.filter(job => 
            new Date(job.createdAt) >= last24h
        );

        // Calculer les m√©triques de performance
        const completedJobs24h = jobs24h.filter(job => job.status === 'completed');
        const totalSizeProcessed = completedJobs24h.reduce((sum, job) => 
            sum + (parseInt(job.size) || 0), 0
        );
        const totalSizeSaved = completedJobs24h.reduce((sum, job) => {
            const original = parseInt(job.size) || 0;
            const compressed = parseInt(job.compressedSize) || original;
            return sum + (original - compressed);
        }, 0);

        const avgCompressionRatio = completedJobs24h.length > 0 ?
            completedJobs24h.reduce((sum, job) => 
                sum + (parseInt(job.compressionRatio) || 0), 0
            ) / completedJobs24h.length : 0;

        // Calculer les temps de traitement moyens
        const avgProcessingTimes = {};
        const jobsByType = completedJobs24h.reduce((acc, job) => {
            if (!acc[job.type]) acc[job.type] = [];
            
            const created = new Date(job.createdAt);
            const updated = new Date(job.updatedAt);
            const processingTime = Math.floor((updated - created) / 1000);
            
            acc[job.type].push(processingTime);
            return acc;
        }, {});

        Object.keys(jobsByType).forEach(type => {
            const times = jobsByType[type];
            avgProcessingTimes[type] = times.length > 0 ?
                Math.floor(times.reduce((a, b) => a + b, 0) / times.length) : 0;
        });

        res.json({
            success: true,
            stats: {
                jobs: {
                    total: jobStats.total,
                    uploaded: jobStats.uploaded || 0,
                    queued: jobStats.queued || 0,
                    processing: jobStats.processing || 0,
                    completed: jobStats.completed || 0,
                    error: jobStats.error || 0,
                    last24h: jobs24h.length,
                    completed24h: completedJobs24h.length
                },
                queue: queueStats || {
                    waiting: 0,
                    active: 0,
                    completed: 0,
                    failed: 0,
                    delayed: 0
                },
                performance: {
                    totalSizeProcessed,
                    totalSizeProcessedFormatted: require('../services/fileService').formatFileSize(totalSizeProcessed),
                    totalSizeSaved,
                    totalSizeSavedFormatted: require('../services/fileService').formatFileSize(totalSizeSaved),
                    avgCompressionRatio: Math.round(avgCompressionRatio),
                    avgProcessingTimes
                },
                activeJobs: activeJobs || [],
                timestamp: currentTime.toISOString()
            }
        });

    } catch (error) {
        logger.error('Erreur r√©cup√©ration statistiques:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * DELETE /api/status/:jobId
 * Supprimer un job et ses fichiers associ√©s
 */
router.delete('/:jobId',
    statusRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande suppression job ${jobId}`, { ip: req.ip });

            // V√©rifier que le job existe
            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouv√©'
                });
            }

            // Ne pas permettre la suppression des jobs en cours de traitement
            if (job.status === 'processing') {
                return res.status(400).json({
                    success: false,
                    error: 'Impossible de supprimer un job en cours de traitement'
                });
            }

            // Supprimer les fichiers associ√©s
            const FileService = require('../services/fileService');
            
            if (job.filePath) {
                await FileService.deleteFile(job.filePath);
                logger.file(`Fichier source supprim√©: ${job.filePath}`);
            }

            if (job.outputPath) {
                await FileService.deleteFile(job.outputPath);
                logger.file(`Fichier de sortie supprim√©: ${job.outputPath}`);
            }

            // Supprimer le job de Redis
            await JobService.deleteJob(jobId);

            logger.info(`Job ${jobId} supprim√© avec succ√®s`);

            res.json({
                success: true,
                message: 'Job supprim√© avec succ√®s',
                jobId
            });

        } catch (error) {
            logger.error(`Erreur suppression job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/status/:jobId/retry
 * Relancer un job en erreur
 */
router.post('/:jobId/retry',
    statusRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande retry job ${jobId}`, { ip: req.ip });

            // V√©rifier que le job existe
            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouv√©'
                });
            }

            // V√©rifier que le job est en erreur
            if (job.status !== 'error') {
                return res.status(400).json({
                    success: false,
                    error: 'Seuls les jobs en erreur peuvent √™tre relanc√©s'
                });
            }

            // V√©rifier que le fichier source existe encore
            const FileService = require('../services/fileService');
            const fileExists = await FileService.getFileStats(job.filePath);
            if (!fileExists) {
                return res.status(400).json({
                    success: false,
                    error: 'Fichier source introuvable, impossible de relancer'
                });
            }

            // Remettre le job en √©tat initial
            await JobService.updateJob(jobId, {
                status: 'uploaded',
                progress: 0,
                error: null,
                outputPath: null,
                compressedSize: null,
                compressionRatio: null,
                updatedAt: new Date().toISOString()
            });

            // Remettre en queue
            const { addJobToQueue } = require('../services/queueService');
            await addJobToQueue(job);
            
            await JobService.updateJob(jobId, { status: 'queued' });

            logger.job(jobId, 'Job relanc√© avec succ√®s');

            res.json({
                success: true,
                message: 'Job relanc√© avec succ√®s',
                jobId,
                status: 'queued'
            });

        } catch (error) {
            logger.error(`Erreur retry job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/status/types/stats
 * Statistiques par type de fichier
 */
router.get('/types/stats', statusRateLimit, async (req, res) => {
    try {
        logger.debug('Statistiques par type demand√©es', { ip: req.ip });

        // R√©cup√©rer tous les jobs r√©cents
        const jobs = await JobService.getAllJobs(1000);
        
        // Grouper par type
        const statsByType = {};
        const FileService = require('../services/fileService');
        
        jobs.forEach(job => {
            const type = job.type || 'unknown';
            
            if (!statsByType[type]) {
                statsByType[type] = {
                    total: 0,
                    uploaded: 0,
                    queued: 0,
                    processing: 0,
                    completed: 0,
                    error: 0,
                    totalSize: 0,
                    totalCompressed: 0,
                    totalSaved: 0,
                    avgCompressionRatio: 0,
                    processingTimes: []
                };
            }

            const stats = statsByType[type];
            stats.total++;
            stats[job.status]++;
            
            const size = parseInt(job.size) || 0;
            stats.totalSize += size;
            
            if (job.status === 'completed') {
                const compressed = parseInt(job.compressedSize) || size;
                stats.totalCompressed += compressed;
                stats.totalSaved += (size - compressed);
                
                // Calculer le temps de traitement
                if (job.createdAt && job.updatedAt) {
                    const processingTime = new Date(job.updatedAt) - new Date(job.createdAt);
                    stats.processingTimes.push(Math.floor(processingTime / 1000));
                }
            }
        });

        // Calculer les moyennes
        Object.keys(statsByType).forEach(type => {
            const stats = statsByType[type];
            
            // Ratio de compression moyen
            if (stats.totalSize > 0) {
                stats.avgCompressionRatio = Math.round(
                    ((stats.totalSize - stats.totalCompressed) / stats.totalSize) * 100
                );
            }
            
            // Temps de traitement moyen
            if (stats.processingTimes.length > 0) {
                stats.avgProcessingTime = Math.floor(
                    stats.processingTimes.reduce((a, b) => a + b, 0) / stats.processingTimes.length
                );
            } else {
                stats.avgProcessingTime = 0;
            }
            
            // Formater les tailles
            stats.totalSizeFormatted = FileService.formatFileSize(stats.totalSize);
            stats.totalCompressedFormatted = FileService.formatFileSize(stats.totalCompressed);
            stats.totalSavedFormatted = FileService.formatFileSize(stats.totalSaved);
            
            // Supprimer les temps bruts
            delete stats.processingTimes;
        });

        res.json({
            success: true,
            statsByType,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        logger.error('Erreur statistiques par type:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * Fonction utilitaire pour formater une dur√©e en secondes
 */
function formatDuration(seconds) {
    if (seconds < 60) {
        return `${seconds}s`;
    } else if (seconds < 3600) {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}m ${secs}s`;
    } else {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${minutes}m`;
    }
}

module.exports = router;


================================================
File: backend/src/routes/upload.js
================================================
// backend/src/routes/upload.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const rateLimit = require('express-rate-limit');

const FileService = require('../services/fileService');
const JobService = require('../services/jobService');
const ProcessingService = require('../services/processingService');
const { ValidationService } = require('../utils/validation');
const logger = require('../utils/logger');
const { addJobToQueue } = require('../services/queueService');

const router = express.Router();

/**
 * Configuration de Multer pour l'upload de fichiers
 */
const uploadConfig = multer({
    storage: multer.memoryStorage(), // Stockage en m√©moire pour validation
    limits: {
        fileSize: parseInt(process.env.UPLOAD_MAX_SIZE) || 5 * 1024 * 1024 * 1024, // 5GB par d√©faut
        files: 1, // Un seul fichier √† la fois
        fields: 10, // Limite des champs suppl√©mentaires
        fieldNameSize: 100, // Limite nom de champ
        fieldSize: 1024 * 1024 // 1MB pour les champs texte
    },
    fileFilter: (req, file, cb) => {
        // Validation pr√©liminaire du fichier
        const isValidType = FileService.isValidFileType(file.originalname);
        
        if (!isValidType) {
            logger.security('Tentative upload type invalide', {
                filename: file.originalname,
                mimetype: file.mimetype,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });
            return cb(new Error('Type de fichier non support√©'), false);
        }
        
        cb(null, true);
    }
});

/**
 * Rate limiting sp√©cifique aux uploads
 */
const uploadRateLimit = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: parseInt(process.env.UPLOAD_RATE_LIMIT) || 10, // 10 uploads par 15min
    message: {
        success: false,
        error: 'Trop d\'uploads, veuillez attendre avant de r√©essayer',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Rate limit par IP + User-Agent pour √©viter les contournements
        return `${req.ip}-${req.get('User-Agent') || 'unknown'}`;
    },
    skip: (req) => {
        // Skip rate limiting en d√©veloppement si configur√©
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    },
    onLimitReached: (req) => {
        logger.security('Rate limit upload atteint', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            path: req.path
        });
    }
});

/**
 * Middleware de validation de s√©curit√© upload
 */
const securityValidation = async (req, res, next) => {
    try {
        const file = req.file;
        if (!file) {
            return res.status(400).json({
                success: false,
                error: 'Aucun fichier fourni'
            });
        }

        // Validation de s√©curit√© avanc√©e
        const securityCheck = ValidationService.validateUploadSecurity(file, req);
        if (!securityCheck.isValid) {
            logger.security('Upload bloqu√© par s√©curit√©', {
                filename: file.originalname,
                errors: securityCheck.errors,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });
            
            return res.status(400).json({
                success: false,
                error: 'Fichier rejet√© par les contr√¥les de s√©curit√©',
                details: securityCheck.errors
            });
        }

        next();
    } catch (error) {
        logger.error('Erreur validation s√©curit√© upload:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne de validation'
        });
    }
};

/**
 * POST /api/upload
 * Upload d'un fichier avec validation compl√®te
 */
router.post('/', 
    uploadRateLimit,
    uploadConfig.single('file'),
    securityValidation,
    async (req, res) => {
        const requestLogger = logger.withContext({ 
            requestId: uuidv4(),
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });

        try {
            const file = req.file;
            const settings = req.body.settings ? JSON.parse(req.body.settings) : {};

            requestLogger.info('Upload d√©marr√©', {
                filename: file.originalname,
                size: file.size,
                mimetype: file.mimetype
            });

            // Validation compl√®te du fichier et des param√®tres
            const validation = await ValidationService.validateUpload(file, settings);
            if (!validation.isValid) {
                requestLogger.warn('Validation upload √©chou√©e', {
                    errors: validation.errors
                });
                
                return res.status(400).json({
                    success: false,
                    error: 'Fichier ou param√®tres invalides',
                    details: validation.errors
                });
            }

            // Nettoyer le nom de fichier
            const sanitizedFilename = ValidationService.sanitizeFilename(file.originalname);
            if (!sanitizedFilename) {
                return res.status(400).json({
                    success: false,
                    error: 'Nom de fichier invalide'
                });
            }

            // Cr√©er le r√©pertoire temporaire
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            await FileService.ensureDirectoryExists(tempDir);

            // G√©n√©rer un nom de fichier unique
            const uniqueFilename = FileService.generateUniqueFilename(sanitizedFilename);
            const filePath = path.join(tempDir, uniqueFilename);

            // Sauvegarder le fichier
            const fs = require('fs').promises;
            await fs.writeFile(filePath, file.buffer);

            requestLogger.info('Fichier sauvegard√©', { filePath });

            // Obtenir les param√®tres valid√©s avec valeurs par d√©faut
            const fileType = FileService.getFileType(sanitizedFilename);
            const defaultSettings = ProcessingService.getDefaultSettings(fileType);
            const finalSettings = { ...defaultSettings, ...validation.validatedData.settings };

            // Valider les param√®tres finaux
            const settingsValidation = ValidationService.validateSettings(fileType, finalSettings);
            if (!settingsValidation.isValid) {
                // Nettoyer le fichier en cas d'erreur
                await FileService.deleteFile(filePath);
                
                return res.status(400).json({
                    success: false,
                    error: 'Param√®tres invalides',
                    details: settingsValidation.errors
                });
            }

            // Cr√©er le job
            const jobId = uuidv4();
            const jobData = {
                id: jobId,
                originalName: sanitizedFilename,
                filePath,
                size: file.size,
                type: fileType,
                settings: settingsValidation.validatedSettings,
                status: 'uploaded',
                progress: 0,
                createdAt: new Date().toISOString()
            };

            // Validation finale du job
            const jobValidation = ValidationService.validateJob(jobData);
            if (!jobValidation.isValid) {
                await FileService.deleteFile(filePath);
                
                return res.status(400).json({
                    success: false,
                    error: 'Job invalide',
                    details: jobValidation.errors
                });
            }

            // Sauvegarder le job
            await JobService.createJob(jobValidation.validatedJob);

            requestLogger.job(jobId, 'Job cr√©√© avec succ√®s');

            // Estimer le temps de traitement
            const estimatedTime = ProcessingService.estimateProcessingTime(fileType, file.size);

            // R√©ponse imm√©diate
            res.status(201).json({
                success: true,
                jobId,
                message: 'Fichier upload√© avec succ√®s',
                file: {
                    originalName: sanitizedFilename,
                    size: file.size,
                    sizeFormatted: FileService.formatFileSize(file.size),
                    type: fileType
                },
                settings: settingsValidation.validatedSettings,
                estimatedTime,
                status: 'uploaded'
            });

            // Ajouter √† la queue de traitement (asynchrone)
            setImmediate(async () => {
                try {
                    await addJobToQueue(jobValidation.validatedJob);
                    await JobService.updateJob(jobId, { status: 'queued' });
                    
                    requestLogger.job(jobId, 'Job ajout√© √† la queue');
                    
                    // Notifier via WebSocket si disponible
                    if (req.io) {
                        req.io.emit('job-queued', {
                            jobId,
                            status: 'queued',
                            timestamp: new Date().toISOString()
                        });
                    }
                } catch (error) {
                    requestLogger.error('Erreur ajout queue', error, { jobId });
                    
                    await JobService.updateJob(jobId, { 
                        status: 'error',
                        error: 'Erreur ajout √† la queue'
                    });
                }
            });

        } catch (error) {
            requestLogger.error('Erreur upload:', error);
            
            // Nettoyer le fichier en cas d'erreur
            if (req.file && req.filePath) {
                await FileService.deleteFile(req.filePath).catch(() => {});
            }

            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur',
                message: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }
);

/**
 * POST /api/upload/batch
 * Upload de plusieurs fichiers (limit√©)
 */
router.post('/batch',
    uploadRateLimit,
    uploadConfig.array('files', 5), // Maximum 5 fichiers
    async (req, res) => {
        const requestLogger = logger.withContext({ 
            requestId: uuidv4(),
            ip: req.ip
        });

        try {
            const files = req.files;
            if (!files || files.length === 0) {
                return res.status(400).json({
                    success: false,
                    error: 'Aucun fichier fourni'
                });
            }

            requestLogger.info('Upload batch d√©marr√©', {
                fileCount: files.length,
                totalSize: files.reduce((sum, f) => sum + f.size, 0)
            });

            const results = [];
            const errors = [];

            // Traiter chaque fichier
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                try {
                    // Simulation de l'upload individuel
                    // (logique similaire √† l'upload simple)
                    const jobId = uuidv4();
                    const sanitizedFilename = ValidationService.sanitizeFilename(file.originalname);
                    
                    if (!sanitizedFilename) {
                        errors.push({
                            file: file.originalname,
                            error: 'Nom de fichier invalide'
                        });
                        continue;
                    }

                    results.push({
                        jobId,
                        filename: sanitizedFilename,
                        size: file.size,
                        status: 'uploaded'
                    });

                } catch (error) {
                    errors.push({
                        file: file.originalname,
                        error: error.message
                    });
                }
            }

            res.json({
                success: true,
                message: `${results.length} fichiers trait√©s`,
                results,
                errors: errors.length > 0 ? errors : undefined,
                total: files.length,
                processed: results.length,
                failed: errors.length
            });

        } catch (error) {
            requestLogger.error('Erreur upload batch:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur traitement batch'
            });
        }
    }
);

/**
 * GET /api/upload/info
 * Informations sur les limites d'upload
 */
router.get('/info', (req, res) => {
    res.json({
        success: true,
        limits: {
            maxFileSize: parseInt(process.env.UPLOAD_MAX_SIZE) || 5 * 1024 * 1024 * 1024,
            maxFileSizeFormatted: FileService.formatFileSize(
                parseInt(process.env.UPLOAD_MAX_SIZE) || 5 * 1024 * 1024 * 1024
            ),
            maxFiles: 1,
            maxFilesBatch: 5,
            rateLimit: parseInt(process.env.UPLOAD_RATE_LIMIT) || 10,
            rateLimitWindow: '15 minutes'
        },
        supportedFormats: FileService.getSupportedFormats(),
        defaultSettings: {
            image: ProcessingService.getDefaultSettings('image'),
            video: ProcessingService.getDefaultSettings('video'),
            audio: ProcessingService.getDefaultSettings('audio'),
            document: ProcessingService.getDefaultSettings('document')
        }
    });
});

/**
 * Middleware de gestion d'erreurs Multer
 */
router.use((error, req, res, next) => {
    if (error instanceof multer.MulterError) {
        logger.warn('Erreur Multer:', {
            code: error.code,
            field: error.field,
            message: error.message,
            ip: req.ip
        });

        const errorMessages = {
            'LIMIT_FILE_SIZE': 'Fichier trop volumineux',
            'LIMIT_FILE_COUNT': 'Trop de fichiers',
            'LIMIT_FIELD_KEY': 'Nom de champ trop long',
            'LIMIT_FIELD_VALUE': 'Valeur de champ trop longue',
            'LIMIT_FIELD_COUNT': 'Trop de champs',
            'LIMIT_UNEXPECTED_FILE': 'Fichier inattendu'
        };

        return res.status(400).json({
            success: false,
            error: errorMessages[error.code] || 'Erreur upload',
            code: error.code
        });
    }

    if (error.message === 'Type de fichier non support√©') {
        return res.status(400).json({
            success: false,
            error: 'Type de fichier non support√©'
        });
    }

    logger.error('Erreur route upload:', error);
    res.status(500).json({
        success: false,
        error: 'Erreur interne du serveur'
    });
});

module.exports = router;


================================================
File: backend/src/services/fileService.js
================================================
// backend/src/services/fileService.js
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const logger = require('../utils/logger');

/**
 * Service de gestion des fichiers
 */
class FileService {
    /**
     * Formats support√©s par type
     */
    static SUPPORTED_FORMATS = {
        images: ['.jpg', '.jpeg', '.png', '.webp', '.avif', '.heic', '.tiff', '.bmp'],
        videos: ['.mp4', '.avi', '.mkv', '.webm', '.mov', '.flv', '.m4v'],
        audio: ['.mp3', '.flac', '.wav', '.aac', '.ogg', '.m4a', '.wma'],
        documents: ['.pdf']
    };

    /**
     * Obtenir tous les formats support√©s
     */
    static getSupportedFormats() {
        return this.SUPPORTED_FORMATS;
    }

    /**
     * D√©terminer le type d'un fichier bas√© sur son extension
     */
    static getFileType(filename) {
        const ext = path.extname(filename).toLowerCase();
        
        for (const [type, extensions] of Object.entries(this.SUPPORTED_FORMATS)) {
            if (extensions.includes(ext)) {
                return type.slice(0, -1); // Retire le 's' final (images -> image)
            }
        }
        
        return 'unknown';
    }

    /**
     * V√©rifier si un fichier est support√©
     */
    static isValidFileType(filename) {
        const ext = path.extname(filename).toLowerCase();
        return Object.values(this.SUPPORTED_FORMATS).flat().includes(ext);
    }

    /**
     * G√©n√©rer un nom de fichier unique
     */
    static generateUniqueFilename(originalName) {
        const ext = path.extname(originalName);
        const name = path.basename(originalName, ext);
        const timestamp = Date.now();
        const random = crypto.randomBytes(4).toString('hex');
        
        // Nettoyer le nom original (caract√®res sp√©ciaux)
        const cleanName = name.replace(/[^a-zA-Z0-9-_]/g, '_');
        
        return `${cleanName}_${timestamp}_${random}${ext}`;
    }

    /**
     * Cr√©er un r√©pertoire s'il n'existe pas
     */
    static async ensureDirectoryExists(dirPath) {
        try {
            await fs.access(dirPath);
        } catch (error) {
            await fs.mkdir(dirPath, { recursive: true });
            logger.info(`Dossier cr√©√©: ${dirPath}`);
        }
    }

    /**
     * Obtenir les statistiques d'un fichier
     */
    static async getFileStats(filePath) {
        try {
            const stats = await fs.stat(filePath);
            return {
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                isFile: stats.isFile(),
                isDirectory: stats.isDirectory()
            };
        } catch (error) {
            logger.error(`Erreur stats fichier ${filePath}:`, error);
            return null;
        }
    }

    /**
     * Supprimer un fichier
     */
    static async deleteFile(filePath) {
        try {
            await fs.unlink(filePath);
            logger.info(`Fichier supprim√©: ${filePath}`);
            return true;
        } catch (error) {
            logger.error(`Erreur suppression ${filePath}:`, error);
            return false;
        }
    }

    /**
     * Copier un fichier
     */
    static async copyFile(sourcePath, destPath) {
        try {
            await fs.copyFile(sourcePath, destPath);
            logger.info(`Fichier copi√©: ${sourcePath} -> ${destPath}`);
            return true;
        } catch (error) {
            logger.error(`Erreur copie ${sourcePath} -> ${destPath}:`, error);
            return false;
        }
    }

    /**
     * D√©placer un fichier
     */
    static async moveFile(sourcePath, destPath) {
        try {
            await fs.rename(sourcePath, destPath);
            logger.info(`Fichier d√©plac√©: ${sourcePath} -> ${destPath}`);
            return true;
        } catch (error) {
            logger.error(`Erreur d√©placement ${sourcePath} -> ${destPath}:`, error);
            return false;
        }
    }

    /**
     * Formater la taille d'un fichier
     */
    static formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Calculer le ratio de compression
     */
    static calculateCompressionRatio(originalSize, compressedSize) {
        if (originalSize === 0) return 0;
        return Math.round(((originalSize - compressedSize) / originalSize) * 100);
    }

    /**
     * V√©rifier l'int√©grit√© d'un fichier via checksum
     */
    static async calculateChecksum(filePath, algorithm = 'md5') {
        try {
            const fileBuffer = await fs.readFile(filePath);
            const hashSum = crypto.createHash(algorithm);
            hashSum.update(fileBuffer);
            
            return hashSum.digest('hex');
        } catch (error) {
            logger.error(`Erreur calcul checksum ${filePath}:`, error);
            return null;
        }
    }

    /**
     * Obtenir les informations d√©taill√©es d'un fichier
     */
    static async getFileInfo(filePath) {
        try {
            const stats = await this.getFileStats(filePath);
            if (!stats) return null;

            const filename = path.basename(filePath);
            const ext = path.extname(filename).toLowerCase();
            const type = this.getFileType(filename);
            const checksum = await this.calculateChecksum(filePath);

            return {
                path: filePath,
                filename,
                extension: ext,
                type,
                size: stats.size,
                sizeFormatted: this.formatFileSize(stats.size),
                created: stats.created,
                modified: stats.modified,
                checksum,
                isValid: this.isValidFileType(filename)
            };
        } catch (error) {
            logger.error(`Erreur info fichier ${filePath}:`, error);
            return null;
        }
    }

    /**
     * Nettoyer les fichiers temporaires
     */
    static async cleanupTempFiles(tempDir, maxAge = 24 * 60 * 60 * 1000) { // 24h par d√©faut
        try {
            const files = await fs.readdir(tempDir);
            const now = Date.now();
            let cleanedCount = 0;
            let totalSize = 0;
            
            for (const file of files) {
                const filePath = path.join(tempDir, file);
                const stats = await this.getFileStats(filePath);
                
                if (stats && stats.isFile) {
                    const age = now - stats.created.getTime();
                    
                    if (age > maxAge) {
                        totalSize += stats.size;
                        if (await this.deleteFile(filePath)) {
                            cleanedCount++;
                        }
                    }
                }
            }
            
            if (cleanedCount > 0) {
                logger.info(`Nettoyage: ${cleanedCount} fichiers supprim√©s (${this.formatFileSize(totalSize)} lib√©r√©s)`);
            }
            
            return { count: cleanedCount, size: totalSize };
        } catch (error) {
            logger.error('Erreur nettoyage fichiers temporaires:', error);
            return { count: 0, size: 0 };
        }
    }

    /**
     * Lister les fichiers d'un r√©pertoire avec filtres
     */
    static async listFiles(directory, options = {}) {
        try {
            const {
                extension = null,
                type = null,
                maxSize = null,
                minSize = null,
                recursive = false
            } = options;

            const files = [];
            const entries = await fs.readdir(directory, { withFileTypes: true });

            for (const entry of entries) {
                const fullPath = path.join(directory, entry.name);

                if (entry.isFile()) {
                    const fileInfo = await this.getFileInfo(fullPath);
                    if (!fileInfo) continue;

                    // Appliquer les filtres
                    if (extension && fileInfo.extension !== extension) continue;
                    if (type && fileInfo.type !== type) continue;
                    if (maxSize && fileInfo.size > maxSize) continue;
                    if (minSize && fileInfo.size < minSize) continue;

                    files.push(fileInfo);
                } else if (entry.isDirectory() && recursive) {
                    const subFiles = await this.listFiles(fullPath, options);
                    files.push(...subFiles);
                }
            }

            return files;
        } catch (error) {
            logger.error(`Erreur listage fichiers ${directory}:`, error);
            return [];
        }
    }

    /**
     * Obtenir l'usage disque d'un r√©pertoire
     */
    static async getDirectorySize(directory) {
        try {
            let totalSize = 0;
            let fileCount = 0;

            const calculateSize = async (dir) => {
                const entries = await fs.readdir(dir, { withFileTypes: true });

                for (const entry of entries) {
                    const fullPath = path.join(dir, entry.name);

                    if (entry.isFile()) {
                        const stats = await this.getFileStats(fullPath);
                        if (stats) {
                            totalSize += stats.size;
                            fileCount++;
                        }
                    } else if (entry.isDirectory()) {
                        await calculateSize(fullPath);
                    }
                }
            };

            await calculateSize(directory);

            return {
                size: totalSize,
                sizeFormatted: this.formatFileSize(totalSize),
                fileCount
            };
        } catch (error) {
            logger.error(`Erreur calcul taille r√©pertoire ${directory}:`, error);
            return { size: 0, sizeFormatted: '0 B', fileCount: 0 };
        }
    }
}

module.exports = FileService;


================================================
File: backend/src/services/imageService.js
================================================
// backend/src/services/imageService.js
const sharp = require('sharp');
const path = require('path');
const FileService = require('./fileService');
const logger = require('../utils/logger');

/**
 * Service de traitement d'images
 */
class ImageService {
    /**
     * Traiter une image selon les param√®tres fournis
     */
    static async processImage(inputPath, outputPath, settings = {}) {
        try {
            logger.info(`Traitement image: ${path.basename(inputPath)}`);

            // Param√®tres par d√©faut
            const config = {
                quality: settings.quality || 80,
                maxWidth: settings.maxWidth || 1920,
                maxHeight: settings.maxHeight || 1080,
                format: settings.format || 'auto',
                removeMetadata: settings.removeMetadata !== false,
                progressive: settings.progressive !== false,
                ...settings
            };

            // Cr√©er le processeur Sharp
            let processor = sharp(inputPath);

            // Obtenir les m√©tadonn√©es de l'image originale
            const metadata = await processor.metadata();
            logger.debug(`Image originale: ${metadata.width}x${metadata.height}, format: ${metadata.format}`);

            // Redimensionnement si n√©cessaire
            if (this.shouldResize(metadata, config)) {
                processor = processor.resize(config.maxWidth, config.maxHeight, {
                    fit: 'inside',
                    withoutEnlargement: true
                });
                logger.debug(`Redimensionnement: ${config.maxWidth}x${config.maxHeight}`);
            }

            // Suppression des m√©tadonn√©es EXIF
            if (config.removeMetadata) {
                processor = processor.removeMetadata();
            }

            // Rotation automatique bas√©e sur EXIF
            if (metadata.orientation) {
                processor = processor.rotate();
            }

            // Configuration du format de sortie
            processor = this.configureOutputFormat(processor, config, metadata);

            // Traitement et sauvegarde
            await processor.toFile(outputPath);

            // Calculer les statistiques
            const originalStats = await FileService.getFileStats(inputPath);
            const processedStats = await FileService.getFileStats(outputPath);
            
            const result = {
                success: true,
                originalSize: originalStats.size,
                processedSize: processedStats.size,
                compressionRatio: FileService.calculateCompressionRatio(originalStats.size, processedStats.size),
                originalDimensions: { width: metadata.width, height: metadata.height },
                processedDimensions: await this.getImageDimensions(outputPath),
                outputPath
            };

            logger.info(`Image trait√©e: ${FileService.formatFileSize(originalStats.size)} -> ${FileService.formatFileSize(processedStats.size)} (${result.compressionRatio}%)`);

            return result;
        } catch (error) {
            logger.error('Erreur traitement image:', error);
            throw new Error(`Erreur traitement image: ${error.message}`);
        }
    }

    /**
     * D√©terminer si l'image doit √™tre redimensionn√©e
     */
    static shouldResize(metadata, config) {
        if (!metadata.width || !metadata.height) return false;
        if (!config.maxWidth && !config.maxHeight) return false;

        return metadata.width > config.maxWidth || metadata.height > config.maxHeight;
    }

    /**
     * Configurer le format de sortie
     */
    static configureOutputFormat(processor, config, metadata) {
        const format = config.format === 'auto' ? metadata.format : config.format;

        switch (format?.toLowerCase()) {
            case 'jpeg':
            case 'jpg':
                return processor.jpeg({
                    quality: config.quality,
                    progressive: config.progressive,
                    mozjpeg: true // Utiliser mozjpeg pour une meilleure compression
                });

            case 'png':
                return processor.png({
                    quality: config.quality,
                    progressive: config.progressive,
                    compressionLevel: Math.round(9 - (config.quality / 100) * 9)
                });

            case 'webp':
                return processor.webp({
                    quality: config.quality,
                    effort: 6 // Niveau d'effort de compression (0-6)
                });

            case 'avif':
                return processor.avif({
                    quality: config.quality,
                    effort: 4 // Niveau d'effort de compression (0-9)
                });

            case 'tiff':
                return processor.tiff({
                    quality: config.quality,
                    compression: 'lzw'
                });

            default:
                // Format par d√©faut: JPEG
                return processor.jpeg({
                    quality: config.quality,
                    progressive: config.progressive,
                    mozjpeg: true
                });
        }
    }

    /**
     * Obtenir les dimensions d'une image
     */
    static async getImageDimensions(imagePath) {
        try {
            const metadata = await sharp(imagePath).metadata();
            return {
                width: metadata.width,
                height: metadata.height
            };
        } catch (error) {
            logger.error(`Erreur lecture dimensions ${imagePath}:`, error);
            return { width: 0, height: 0 };
        }
    }

    /**
     * Obtenir les m√©tadonn√©es d√©taill√©es d'une image
     */
    static async getImageMetadata(imagePath) {
        try {
            const metadata = await sharp(imagePath).metadata();
            return {
                format: metadata.format,
                width: metadata.width,
                height: metadata.height,
                channels: metadata.channels,
                depth: metadata.depth,
                density: metadata.density,
                hasAlpha: metadata.hasAlpha,
                orientation: metadata.orientation,
                colorSpace: metadata.space,
                exif: metadata.exif ? this.parseExifData(metadata.exif) : null
            };
        } catch (error) {
            logger.error(`Erreur lecture m√©tadonn√©es ${imagePath}:`, error);
            return null;
        }
    }

    /**
     * Parser les donn√©es EXIF (basique)
     */
    static parseExifData(exifBuffer) {
        try {
            // Ici on pourrait utiliser une lib comme exif-parser pour plus de d√©tails
            return {
                hasExif: true,
                size: exifBuffer.length
            };
        } catch (error) {
            return { hasExif: false };
        }
    }

    /**
     * Cr√©er une vignette
     */
    static async createThumbnail(inputPath, outputPath, size = 200) {
        try {
            await sharp(inputPath)
                .resize(size, size, {
                    fit: 'cover',
                    position: 'center'
                })
                .jpeg({ quality: 80 })
                .toFile(outputPath);

            logger.debug(`Vignette cr√©√©e: ${outputPath}`);
            return outputPath;
        } catch (error) {
            logger.error(`Erreur cr√©ation vignette:`, error);
            throw error;
        }
    }

    /**
     * Optimiser une image pour le web
     */
    static async optimizeForWeb(inputPath, outputPath) {
        try {
            const metadata = await sharp(inputPath).metadata();
            
            // Param√®tres optimis√©s pour le web
            const webSettings = {
                quality: 85,
                maxWidth: 1920,
                maxHeight: 1920,
                format: this.getBestWebFormat(metadata.format),
                progressive: true,
                removeMetadata: true
            };

            return await this.processImage(inputPath, outputPath, webSettings);
        } catch (error) {
            logger.error('Erreur optimisation web:', error);
            throw error;
        }
    }

    /**
     * D√©terminer le meilleur format pour le web
     */
    static getBestWebFormat(originalFormat) {
        // Priorit√©: WebP > AVIF > JPEG > PNG
        const supportModern = true; // √Ä adapter selon le support navigateur

        if (supportModern) {
            if (originalFormat === 'png') {
                return 'webp'; // Garde la transparence
            }
            return 'webp'; // Meilleure compression g√©n√©rale
        }

        // Fallback pour anciens navigateurs
        return originalFormat === 'png' ? 'png' : 'jpeg';
    }

    /**
     * Redimensionner par lot
     */
    static async batchResize(inputPaths, outputDir, settings = {}) {
        const results = [];
        
        for (const inputPath of inputPaths) {
            try {
                const filename = path.basename(inputPath);
                const outputPath = path.join(outputDir, filename);
                
                const result = await this.processImage(inputPath, outputPath, settings);
                results.push({ ...result, inputPath });
            } catch (error) {
                logger.error(`Erreur traitement ${inputPath}:`, error);
                results.push({
                    success: false,
                    inputPath,
                    error: error.message
                });
            }
        }

        return results;
    }

    /**
     * Valider qu'un fichier est bien une image
     */
    static async validateImage(imagePath) {
        try {
            const metadata = await sharp(imagePath).metadata();
            return {
                isValid: true,
                format: metadata.format,
                width: metadata.width,
                height: metadata.height
            };
        } catch (error) {
            return {
                isValid: false,
                error: error.message
            };
        }
    }
}

module.exports = ImageService;


================================================
File: backend/src/services/jobService.js
================================================
// backend/src/services/jobService.js
const { getRedisClient } = require('../utils/redis');
const logger = require('../utils/logger');

const JOB_PREFIX = 'job:';
const JOB_INDEX = 'jobs:index';

/**
 * Service de gestion des jobs de traitement de fichiers
 */
class JobService {
    /**
     * Cr√©er un nouveau job
     */
    static async createJob(jobData) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobData.id}`;
            
            // S√©rialiser les donn√©es complexes
            const serializedData = {
                ...jobData,
                settings: JSON.stringify(jobData.settings),
                createdAt: jobData.createdAt || new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            // Stocker le job dans Redis
            await redis.hSet(jobKey, serializedData);
            
            // Ajouter √† l'index des jobs
            await redis.sAdd(JOB_INDEX, jobData.id);
            
            // Expiration apr√®s 7 jours
            await redis.expire(jobKey, 7 * 24 * 60 * 60);
            
            logger.info(`Job cr√©√©: ${jobData.id}`);
            return jobData;
        } catch (error) {
            logger.error('Erreur cr√©ation job:', error);
            throw error;
        }
    }

    /**
     * R√©cup√©rer un job par son ID
     */
    static async getJob(jobId) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobId}`;
            const jobData = await redis.hGetAll(jobKey);
            
            if (!jobData || Object.keys(jobData).length === 0) {
                return null;
            }
            
            // D√©s√©rialiser les donn√©es JSON
            if (jobData.settings) {
                jobData.settings = JSON.parse(jobData.settings);
            }
            
            // Convertir les nombres
            if (jobData.size) jobData.size = parseInt(jobData.size);
            if (jobData.compressedSize) jobData.compressedSize = parseInt(jobData.compressedSize);
            if (jobData.progress) jobData.progress = parseInt(jobData.progress);
            if (jobData.compressionRatio) jobData.compressionRatio = parseInt(jobData.compressionRatio);
            
            return jobData;
        } catch (error) {
            logger.error(`Erreur r√©cup√©ration job ${jobId}:`, error);
            throw error;
        }
    }

    /**
     * Mettre √† jour un job
     */
    static async updateJob(jobId, updates) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobId}`;
            
            // S√©rialiser les objets complexes
            const serializedUpdates = {
                ...updates,
                updatedAt: new Date().toISOString()
            };
            
            // S√©rialiser les objets si n√©cessaire
            for (const [key, value] of Object.entries(serializedUpdates)) {
                if (typeof value === 'object' && value !== null && key !== 'updatedAt') {
                    serializedUpdates[key] = JSON.stringify(value);
                }
            }
            
            await redis.hSet(jobKey, serializedUpdates);
            logger.debug(`Job mis √† jour: ${jobId}`);
            
            return true;
        } catch (error) {
            logger.error(`Erreur mise √† jour job ${jobId}:`, error);
            throw error;
        }
    }

    /**
     * Supprimer un job
     */
    static async deleteJob(jobId) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobId}`;
            
            await redis.del(jobKey);
            await redis.sRem(JOB_INDEX, jobId);
            
            logger.info(`Job supprim√©: ${jobId}`);
            return true;
        } catch (error) {
            logger.error(`Erreur suppression job ${jobId}:`, error);
            throw error;
        }
    }

    /**
     * R√©cup√©rer tous les jobs
     */
    static async getAllJobs(limit = 100) {
        try {
            const redis = getRedisClient();
            const jobIds = await redis.sMembers(JOB_INDEX);
            
            const jobs = [];
            for (const jobId of jobIds.slice(0, limit)) {
                const job = await this.getJob(jobId);
                if (job) {
                    jobs.push(job);
                }
            }
            
            // Trier par date de cr√©ation (plus r√©cent en premier)
            jobs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            
            return jobs;
        } catch (error) {
            logger.error('Erreur r√©cup√©ration jobs:', error);
            throw error;
        }
    }

    /**
     * R√©cup√©rer les statistiques des jobs
     */
    static async getJobStats() {
        try {
            const redis = getRedisClient();
            const jobIds = await redis.sMembers(JOB_INDEX);
            
            const stats = {
                total: jobIds.length,
                uploaded: 0,
                queued: 0,
                processing: 0,
                completed: 0,
                error: 0
            };
            
            for (const jobId of jobIds) {
                const job = await this.getJob(jobId);
                if (job && job.status) {
                    stats[job.status] = (stats[job.status] || 0) + 1;
                }
            }
            
            return stats;
        } catch (error) {
            logger.error('Erreur stats jobs:', error);
            throw error;
        }
    }

    /**
     * Nettoyer les jobs expir√©s
     */
    static async cleanupExpiredJobs(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 jours par d√©faut
        try {
            const redis = getRedisClient();
            const jobIds = await redis.sMembers(JOB_INDEX);
            const now = new Date();
            let cleanedCount = 0;
            
            for (const jobId of jobIds) {
                const job = await this.getJob(jobId);
                if (job) {
                    const createdAt = new Date(job.createdAt);
                    if (now - createdAt > maxAge) {
                        await this.deleteJob(jobId);
                        cleanedCount++;
                    }
                }
            }
            
            if (cleanedCount > 0) {
                logger.info(`Jobs nettoy√©s: ${cleanedCount}`);
            }
            
            return cleanedCount;
        } catch (error) {
            logger.error('Erreur nettoyage jobs:', error);
            throw error;
        }
    }
}

module.exports = JobService;


================================================
File: backend/src/services/processingService.js
================================================
// backend/src/services/processingService.js
const path = require('path');
const JobService = require('./jobService');
const FileService = require('./fileService');
const ImageService = require('./imageService');
const logger = require('../utils/logger');

/**
 * Service principal de traitement des fichiers
 */
class ProcessingService {
    /**
     * Traiter un fichier selon son type
     */
    static async processFile(jobData, progressCallback) {
        const fileType = FileService.getFileType(jobData.originalName);
        
        try {
            // Mettre √† jour le statut √† "processing"
            await JobService.updateJob(jobData.id, { 
                status: 'processing',
                progress: 5
            });
            
            progressCallback(10);
            
            let result;
            switch (fileType) {
                case 'image':
                    result = await this.processImage(jobData, progressCallback);
                    break;
                case 'video':
                    result = await this.processVideo(jobData, progressCallback);
                    break;
                case 'audio':
                    result = await this.processAudio(jobData, progressCallback);
                    break;
                case 'document':
                    result = await this.processDocument(jobData, progressCallback);
                    break;
                default:
                    throw new Error(`Type de fichier non support√©: ${fileType}`);
            }
            
            progressCallback(100);
            
            // Mettre √† jour le job avec les r√©sultats
            await JobService.updateJob(jobData.id, {
                status: 'completed',
                outputPath: result.outputPath,
                compressedSize: result.compressedSize,
                compressionRatio: result.compressionRatio,
                progress: 100
            });
            
            logger.info(`Traitement termin√© pour job ${jobData.id}`);
            return result;
            
        } catch (error) {
            logger.error(`Erreur traitement job ${jobData.id}:`, error);
            
            await JobService.updateJob(jobData.id, {
                status: 'error',
                error: error.message,
                progress: 0
            });
            
            throw error;
        }
    }

    /**
     * Traiter une image
     */
    static async processImage(jobData, progressCallback) {
        try {
            logger.info(`Traitement image: ${jobData.originalName}`);
            
            // Pr√©parer les chemins
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            // D√©terminer l'extension de sortie
            const outputExt = jobData.settings.format === 'auto' 
                ? path.extname(jobData.filePath) 
                : `.${jobData.settings.format}`;
            
            const outputPath = path.join(outputDir, `${jobData.id}${outputExt}`);
            
            progressCallback(20);
            
            // Traiter l'image avec ImageService
            const result = await ImageService.processImage(
                jobData.filePath, 
                outputPath, 
                jobData.settings
            );
            
            progressCallback(80);
            
            // V√©rifier que le fichier de sortie existe
            const outputStats = await FileService.getFileStats(outputPath);
            if (!outputStats) {
                throw new Error('Fichier de sortie non cr√©√©');
            }
            
            logger.info(`Image trait√©e: ${jobData.originalName} -> ${FileService.formatFileSize(outputStats.size)}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: FileService.calculateCompressionRatio(jobData.size, outputStats.size)
            };
            
        } catch (error) {
            logger.error(`Erreur traitement image ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Traiter une vid√©o (impl√©mentation basique)
     */
    static async processVideo(jobData, progressCallback) {
        try {
            logger.info(`Traitement vid√©o: ${jobData.originalName}`);
            
            // Pour le moment, copie simple du fichier
            // TODO: Impl√©menter FFmpeg pour compression vid√©o
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            const outputPath = path.join(outputDir, `${jobData.id}_processed${path.extname(jobData.filePath)}`);
            
            progressCallback(30);
            
            // Copie temporaire (√† remplacer par traitement FFmpeg)
            await FileService.copyFile(jobData.filePath, outputPath);
            
            progressCallback(90);
            
            const outputStats = await FileService.getFileStats(outputPath);
            
            logger.info(`Vid√©o "trait√©e": ${jobData.originalName}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: 0 // Pas de compression pour le moment
            };
            
        } catch (error) {
            logger.error(`Erreur traitement vid√©o ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Traiter un fichier audio (impl√©mentation basique)
     */
    static async processAudio(jobData, progressCallback) {
        try {
            logger.info(`Traitement audio: ${jobData.originalName}`);
            
            // Pour le moment, copie simple du fichier
            // TODO: Impl√©menter FFmpeg pour compression audio
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            const outputPath = path.join(outputDir, `${jobData.id}_processed${path.extname(jobData.filePath)}`);
            
            progressCallback(40);
            
            // Copie temporaire (√† remplacer par traitement FFmpeg)
            await FileService.copyFile(jobData.filePath, outputPath);
            
            progressCallback(90);
            
            const outputStats = await FileService.getFileStats(outputPath);
            
            logger.info(`Audio "trait√©": ${jobData.originalName}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: 0 // Pas de compression pour le moment
            };
            
        } catch (error) {
            logger.error(`Erreur traitement audio ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Traiter un document (impl√©mentation basique)
     */
    static async processDocument(jobData, progressCallback) {
        try {
            logger.info(`Traitement document: ${jobData.originalName}`);
            
            // Pour le moment, copie simple du fichier
            // TODO: Impl√©menter compression PDF
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            const outputPath = path.join(outputDir, `${jobData.id}_processed.pdf`);
            
            progressCallback(50);
            
            // Copie temporaire (√† remplacer par traitement PDF)
            await FileService.copyFile(jobData.filePath, outputPath);
            
            progressCallback(90);
            
            const outputStats = await FileService.getFileStats(outputPath);
            
            logger.info(`Document "trait√©": ${jobData.originalName}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: 0 // Pas de compression pour le moment
            };
            
        } catch (error) {
            logger.error(`Erreur traitement document ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Valider un job avant traitement
     */
    static async validateJob(jobData) {
        const errors = [];

        // V√©rifier que le fichier existe
        const fileStats = await FileService.getFileStats(jobData.filePath);
        if (!fileStats) {
            errors.push('Fichier source introuvable');
        }

        // V√©rifier le type de fichier
        if (!FileService.isValidFileType(jobData.originalName)) {
            errors.push('Type de fichier non support√©');
        }

        // V√©rifier les param√®tres selon le type
        const fileType = FileService.getFileType(jobData.originalName);
        const validationErrors = this.validateSettings(fileType, jobData.settings);
        errors.push(...validationErrors);

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Valider les param√®tres selon le type de fichier
     */
    static validateSettings(fileType, settings) {
        const errors = [];

        switch (fileType) {
            case 'image':
                if (settings.quality && (settings.quality < 1 || settings.quality > 100)) {
                    errors.push('Qualit√© doit √™tre entre 1 et 100');
                }
                if (settings.maxWidth && settings.maxWidth < 100) {
                    errors.push('Largeur minimum: 100px');
                }
                if (settings.maxHeight && settings.maxHeight < 100) {
                    errors.push('Hauteur minimum: 100px');
                }
                break;
            
            case 'video':
                if (settings.crf && (settings.crf < 18 || settings.crf > 51)) {
                    errors.push('CRF doit √™tre entre 18 et 51');
                }
                break;
                
            case 'audio':
                if (settings.sampleRate && ![22050, 44100, 48000].includes(settings.sampleRate)) {
                    errors.push('Fr√©quence d\'√©chantillonnage non support√©e');
                }
                break;
        }

        return errors;
    }

    /**
     * Obtenir les param√®tres par d√©faut selon le type de fichier
     */
    static getDefaultSettings(fileType) {
        const defaults = {
            image: {
                quality: 80,
                maxWidth: 1920,
                maxHeight: 1080,
                format: 'auto',
                removeMetadata: true
            },
            video: {
                codec: 'h264',
                crf: 23,
                preset: 'medium',
                maxBitrate: '2M'
            },
            audio: {
                codec: 'aac',
                bitrate: '128k',
                sampleRate: 44100
            },
            document: {
                compress: true,
                removeMetadata: true
            }
        };

        return defaults[fileType] || {};
    }

    /**
     * Estimer la dur√©e de traitement
     */
    static estimateProcessingTime(fileType, fileSize) {
        // Estimation basique en secondes
        const sizeInMB = fileSize / (1024 * 1024);
        
        const estimates = {
            image: Math.max(2, sizeInMB * 0.5),      // ~0.5s par MB
            video: Math.max(10, sizeInMB * 2),       // ~2s par MB
            audio: Math.max(5, sizeInMB * 1),        // ~1s par MB
            document: Math.max(3, sizeInMB * 0.8)    // ~0.8s par MB
        };

        return Math.round(estimates[fileType] || 10);
    }
}

module.exports = ProcessingService;


================================================
File: backend/src/services/queueService.js
================================================
// backend/src/services/queueService.js
const Queue = require('bull');
const logger = require('../utils/logger');

/**
 * Service de gestion de la queue de traitement
 */
class QueueService {
    constructor() {
        this.processingQueue = null;
        this.initialized = false;
    }

    /**
     * Initialiser la queue
     */
    init() {
        if (this.initialized) return;

        try {
            // Configuration de la queue Bull
            this.processingQueue = new Queue('file processing', {
                redis: {
                    port: process.env.REDIS_PORT || 6379,
                    host: process.env.REDIS_HOST || 'localhost',
                    password: process.env.REDIS_PASSWORD || undefined
                },
                defaultJobOptions: {
                    removeOnComplete: 10,   // Garder 10 jobs compl√©t√©s
                    removeOnFail: 50,       // Garder 50 jobs √©chou√©s
                    attempts: 3,            // 3 tentatives max
                    backoff: {
                        type: 'exponential',
                        delay: 2000
                    }
                }
            });

            // √âv√©nements de la queue
            this.setupEventListeners();
            
            this.initialized = true;
            logger.info('Queue service initialis√©');
        } catch (error) {
            logger.error('Erreur initialisation queue:', error);
            throw error;
        }
    }

    /**
     * Configurer les √©v√©nements de la queue
     */
    setupEventListeners() {
        this.processingQueue.on('completed', (job, result) => {
            logger.info(`Job compl√©t√©: ${result.jobId}`);
        });

        this.processingQueue.on('failed', (job, err) => {
            logger.error(`Job √©chou√©: ${job.data.jobData.id}`, err);
        });

        this.processingQueue.on('stalled', (job) => {
            logger.warn(`Job bloqu√©: ${job.data.jobData.id}`);
        });

        this.processingQueue.on('progress', (job, progress) => {
            logger.debug(`Job progr√®s: ${job.data.jobData.id} - ${progress}%`);
        });

        this.processingQueue.on('active', (job) => {
            logger.info(`Job d√©marr√©: ${job.data.jobData.id}`);
        });
    }

    /**
     * Ajouter un job √† la queue
     */
    async addJob(jobData, options = {}) {
        try {
            if (!this.initialized) {
                this.init();
            }

            const job = await this.processingQueue.add('optimize-file', 
                { jobData }, 
                {
                    priority: this.getJobPriority(jobData),
                    delay: options.delay || 0,
                    ...options
                }
            );
            
            logger.info(`Job ajout√© √† la queue: ${jobData.id} (Bull ID: ${job.id})`);
            return job;
        } catch (error) {
            logger.error('Erreur ajout job √† la queue:', error);
            throw error;
        }
    }

    /**
     * Calculer la priorit√© d'un job bas√©e sur la taille du fichier
     */
    getJobPriority(jobData) {
        const sizeInMB = jobData.size / (1024 * 1024);
        
        // Plus le fichier est petit, plus la priorit√© est haute
        if (sizeInMB < 10) return 10;      // Tr√®s haute priorit√©
        if (sizeInMB < 100) return 5;      // Priorit√© normale
        return 1;                          // Basse priorit√©
    }

    /**
     * Obtenir les statistiques de la queue
     */
    async getQueueStats() {
        try {
            if (!this.initialized) {
                return null;
            }

            const waiting = await this.processingQueue.getWaiting();
            const active = await this.processingQueue.getActive();
            const completed = await this.processingQueue.getCompleted();
            const failed = await this.processingQueue.getFailed();
            const delayed = await this.processingQueue.getDelayed();
            
            return {
                waiting: waiting.length,
                active: active.length,
                completed: completed.length,
                failed: failed.length,
                delayed: delayed.length,
                total: waiting.length + active.length + completed.length + failed.length + delayed.length
            };
        } catch (error) {
            logger.error('Erreur stats queue:', error);
            return null;
        }
    }

    /**
     * Obtenir les jobs actifs
     */
    async getActiveJobs() {
        try {
            if (!this.initialized) {
                return [];
            }

            const activeJobs = await this.processingQueue.getActive();
            return activeJobs.map(job => ({
                id: job.id,
                jobId: job.data.jobData.id,
                progress: job.progress(),
                timestamp: job.timestamp,
                processedOn: job.processedOn
            }));
        } catch (error) {
            logger.error('Erreur r√©cup√©ration jobs actifs:', error);
            return [];
        }
    }

    /**
     * Nettoyer la queue
     */
    async cleanQueue() {
        try {
            if (!this.initialized) {
                return;
            }

            await this.processingQueue.clean(24 * 60 * 60 * 1000, 'completed'); // 24h
            await this.processingQueue.clean(7 * 24 * 60 * 60 * 1000, 'failed'); // 7 jours
            
            logger.info('Queue nettoy√©e');
        } catch (error) {
            logger.error('Erreur nettoyage queue:', error);
        }
    }

    /**
     * Fermer la queue
     */
    async close() {
        try {
            if (this.processingQueue) {
                await this.processingQueue.close();
                logger.info('Queue ferm√©e');
            }
        } catch (error) {
            logger.error('Erreur fermeture queue:', error);
        }
    }

    /**
     * Obtenir la queue (pour le worker)
     */
    getQueue() {
        if (!this.initialized) {
            this.init();
        }
        return this.processingQueue;
    }
}

// Singleton
const queueService = new QueueService();

module.exports = {
    addJobToQueue: (jobData, options) => queueService.addJob(jobData, options),
    getQueueStats: () => queueService.getQueueStats(),
    getActiveJobs: () => queueService.getActiveJobs(),
    cleanQueue: () => queueService.cleanQueue(),
    closeQueue: () => queueService.close(),
    processingQueue: queueService.getQueue()
};


================================================
File: backend/src/utils/logger.js
================================================
// backend/src/utils/logger.js
const winston = require('winston');
const path = require('path');

/**
 * Configuration du syst√®me de logging avec Winston
 */
class Logger {
    constructor() {
        this.logger = null;
        this.init();
    }

    /**
     * Initialiser le logger Winston
     */
    init() {
        // Configuration des niveaux de log
        const levels = {
            error: 0,
            warn: 1,
            info: 2,
            http: 3,
            debug: 4
        };

        const colors = {
            error: 'red',
            warn: 'yellow',
            info: 'green',
            http: 'magenta',
            debug: 'cyan'
        };

        winston.addColors(colors);

        // Format personnalis√© pour les logs
        const format = winston.format.combine(
            winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
            winston.format.errors({ stack: true }),
            winston.format.colorize({ all: true }),
            winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
                let log = `[${timestamp}] ${level}: ${message}`;
                
                // Ajouter la stack trace pour les erreurs
                if (stack) {
                    log += `\n${stack}`;
                }
                
                // Ajouter les m√©tadonn√©es si pr√©sentes
                if (Object.keys(meta).length > 0) {
                    log += `\n${JSON.stringify(meta, null, 2)}`;
                }
                
                return log;
            })
        );

        // Configuration des transports
        const transports = [
            // Console pour le d√©veloppement
            new winston.transports.Console({
                level: process.env.LOG_LEVEL || 'info',
                format
            })
        ];

        // Fichier de logs pour la production
        if (process.env.NODE_ENV === 'production') {
            const logDir = process.env.LOG_DIR || './logs';
            
            transports.push(
                // Logs g√©n√©raux
                new winston.transports.File({
                    filename: path.join(logDir, 'app.log'),
                    level: 'info',
                    format: winston.format.combine(
                        winston.format.timestamp(),
                        winston.format.errors({ stack: true }),
                        winston.format.json()
                    ),
                    maxsize: 50 * 1024 * 1024, // 50MB
                    maxFiles: 5,
                    tailable: true
                }),
                
                // Logs d'erreurs s√©par√©s
                new winston.transports.File({
                    filename: path.join(logDir, 'error.log'),
                    level: 'error',
                    format: winston.format.combine(
                        winston.format.timestamp(),
                        winston.format.errors({ stack: true }),
                        winston.format.json()
                    ),
                    maxsize: 20 * 1024 * 1024, // 20MB
                    maxFiles: 5,
                    tailable: true
                })
            );
        }

        // Cr√©er l'instance Winston
        this.logger = winston.createLogger({
            levels,
            level: process.env.LOG_LEVEL || 'info',
            transports,
            // Ne pas sortir sur les rejections non g√©r√©es
            exitOnError: false
        });

        // G√©rer les exceptions non captur√©es
        this.logger.exceptions.handle(
            new winston.transports.Console({
                format
            })
        );

        // G√©rer les rejections de promesses non g√©r√©es
        this.logger.rejections.handle(
            new winston.transports.Console({
                format
            })
        );
    }

    /**
     * Log de niveau info
     */
    info(message, meta = {}) {
        this.logger.info(message, meta);
    }

    /**
     * Log de niveau debug
     */
    debug(message, meta = {}) {
        this.logger.debug(message, meta);
    }

    /**
     * Log de niveau warn
     */
    warn(message, meta = {}) {
        this.logger.warn(message, meta);
    }

    /**
     * Log de niveau error
     */
    error(message, error = null, meta = {}) {
        if (error instanceof Error) {
            this.logger.error(message, { 
                error: error.message, 
                stack: error.stack,
                ...meta 
            });
        } else if (error) {
            this.logger.error(message, { error, ...meta });
        } else {
            this.logger.error(message, meta);
        }
    }

    /**
     * Log de niveau http pour les requ√™tes
     */
    http(message, meta = {}) {
        this.logger.http(message, meta);
    }

    /**
     * Logger sp√©cialis√© pour les jobs
     */
    job(jobId, message, meta = {}) {
        this.logger.info(`[JOB:${jobId}] ${message}`, meta);
    }

    /**
     * Logger sp√©cialis√© pour la queue
     */
    queue(message, meta = {}) {
        this.logger.info(`[QUEUE] ${message}`, meta);
    }

    /**
     * Logger sp√©cialis√© pour les fichiers
     */
    file(message, meta = {}) {
        this.logger.info(`[FILE] ${message}`, meta);
    }

    /**
     * Logger sp√©cialis√© pour le traitement
     */
    processing(message, meta = {}) {
        this.logger.info(`[PROCESSING] ${message}`, meta);
    }

    /**
     * Logger pour les performances
     */
    performance(operation, duration, meta = {}) {
        this.logger.info(`[PERF] ${operation} completed in ${duration}ms`, meta);
    }

    /**
     * Logger pour les m√©triques
     */
    metric(name, value, unit = '', meta = {}) {
        this.logger.info(`[METRIC] ${name}: ${value}${unit}`, meta);
    }

    /**
     * Logger pour la s√©curit√©
     */
    security(message, meta = {}) {
        this.logger.warn(`[SECURITY] ${message}`, meta);
    }

    /**
     * Cr√©er un timer pour mesurer les performances
     */
    timer(label) {
        const start = Date.now();
        return {
            end: (meta = {}) => {
                const duration = Date.now() - start;
                this.performance(label, duration, meta);
                return duration;
            }
        };
    }

    /**
     * Logger avec contexte (pour suivre une requ√™te)
     */
    withContext(context) {
        return {
            info: (message, meta = {}) => this.info(message, { ...context, ...meta }),
            debug: (message, meta = {}) => this.debug(message, { ...context, ...meta }),
            warn: (message, meta = {}) => this.warn(message, { ...context, ...meta }),
            error: (message, error = null, meta = {}) => this.error(message, error, { ...context, ...meta }),
            http: (message, meta = {}) => this.http(message, { ...context, ...meta })
        };
    }

    /**
     * Obtenir l'instance Winston native si n√©cessaire
     */
    getInstance() {
        return this.logger;
    }

    /**
     * Cr√©er un stream pour int√©gration avec Express Morgan
     */
    stream() {
        return {
            write: (message) => {
                this.http(message.trim());
            }
        };
    }

    /**
     * Changer le niveau de log √† chaud
     */
    setLevel(level) {
        this.logger.level = level;
        this.logger.transports.forEach(transport => {
            if (transport.level !== 'error') { // Garder error.log sur error
                transport.level = level;
            }
        });
        this.info(`Log level changed to: ${level}`);
    }

    /**
     * Ajouter un transport personnalis√©
     */
    addTransport(transport) {
        this.logger.add(transport);
    }

    /**
     * Supprimer un transport
     */
    removeTransport(transport) {
        this.logger.remove(transport);
    }

    /**
     * Vider les logs (pour les tests)
     */
    clear() {
        this.logger.clear();
    }

    /**
     * Fermer le logger proprement
     */
    close() {
        return new Promise((resolve) => {
            this.logger.on('finish', resolve);
            this.logger.end();
        });
    }
}

// Singleton
const logger = new Logger();

// Export des m√©thodes principales pour faciliter l'usage
module.exports = {
    info: logger.info.bind(logger),
    debug: logger.debug.bind(logger),
    warn: logger.warn.bind(logger),
    error: logger.error.bind(logger),
    http: logger.http.bind(logger),
    job: logger.job.bind(logger),
    queue: logger.queue.bind(logger),
    file: logger.file.bind(logger),
    processing: logger.processing.bind(logger),
    performance: logger.performance.bind(logger),
    metric: logger.metric.bind(logger),
    security: logger.security.bind(logger),
    timer: logger.timer.bind(logger),
    withContext: logger.withContext.bind(logger),
    stream: logger.stream.bind(logger),
    setLevel: logger.setLevel.bind(logger),
    getInstance: logger.getInstance.bind(logger),
    close: logger.close.bind(logger)
};


================================================
File: backend/src/utils/redis.js
================================================
// backend/src/utils/redis.js
const { createClient } = require('redis');
const logger = require('./logger');

/**
 * Client Redis singleton avec gestion de connexion robuste
 */
class RedisClient {
    constructor() {
        this.client = null;
        this.isConnected = false;
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.reconnectDelay = 1000; // 1 seconde
    }

    /**
     * Initialiser la connexion Redis
     */
    async init() {
        if (this.client && this.isConnected) {
            return this.client;
        }

        if (this.isConnecting) {
            // Attendre que la connexion en cours se termine
            return new Promise((resolve, reject) => {
                const checkConnection = () => {
                    if (this.isConnected && this.client) {
                        resolve(this.client);
                    } else if (!this.isConnecting) {
                        reject(new Error('Connection failed'));
                    } else {
                        setTimeout(checkConnection, 100);
                    }
                };
                checkConnection();
            });
        }

        this.isConnecting = true;

        try {
            // Configuration de la connexion
            const config = this.getRedisConfig();
            
            logger.info('Initialisation de la connexion Redis', { 
                host: config.socket?.host || config.host,
                port: config.socket?.port || config.port,
                database: config.database
            });

            this.client = createClient(config);

            // Gestionnaires d'√©v√©nements
            this.setupEventHandlers();

            // Connexion
            await this.client.connect();
            
            this.isConnected = true;
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            
            logger.info('Redis connect√© avec succ√®s');
            
            // Test de la connexion
            await this.client.ping();
            
            return this.client;
        } catch (error) {
            this.isConnecting = false;
            this.isConnected = false;
            logger.error('Erreur connexion Redis:', error);
            throw error;
        }
    }

    /**
     * Obtenir la configuration Redis depuis les variables d'environnement
     */
    getRedisConfig() {
        const redisUrl = process.env.REDIS_URL;
        
        if (redisUrl) {
            // Parse de l'URL Redis
            return {
                url: redisUrl,
                retry_unfulfilled_commands: true,
                socket: {
                    reconnectStrategy: (retries) => {
                        if (retries >= this.maxReconnectAttempts) {
                            logger.error(`Redis: Trop de tentatives de reconnexion (${retries})`);
                            return false;
                        }
                        const delay = Math.min(retries * this.reconnectDelay, 30000);
                        logger.warn(`Redis: Tentative de reconnexion ${retries} dans ${delay}ms`);
                        return delay;
                    }
                }
            };
        }

        // Configuration par d√©faut
        return {
            socket: {
                host: process.env.REDIS_HOST || 'localhost',
                port: parseInt(process.env.REDIS_PORT) || 6379,
                reconnectStrategy: (retries) => {
                    if (retries >= this.maxReconnectAttempts) {
                        logger.error(`Redis: Trop de tentatives de reconnexion (${retries})`);
                        return false;
                    }
                    const delay = Math.min(retries * this.reconnectDelay, 30000);
                    logger.warn(`Redis: Tentative de reconnexion ${retries} dans ${delay}ms`);
                    return delay;
                }
            },
            password: process.env.REDIS_PASSWORD || undefined,
            database: parseInt(process.env.REDIS_DATABASE) || 0,
            retry_unfulfilled_commands: true
        };
    }

    /**
     * Configurer les gestionnaires d'√©v√©nements Redis
     */
    setupEventHandlers() {
        this.client.on('ready', () => {
            logger.info('Redis client ready');
            this.isConnected = true;
            this.reconnectAttempts = 0;
        });

        this.client.on('connect', () => {
            logger.info('Redis client connected');
        });

        this.client.on('reconnecting', () => {
            this.reconnectAttempts++;
            logger.warn(`Redis reconnecting (attempt ${this.reconnectAttempts})`);
            this.isConnected = false;
        });

        this.client.on('error', (error) => {
            logger.error('Redis client error:', error);
            this.isConnected = false;
        });

        this.client.on('end', () => {
            logger.warn('Redis client disconnected');
            this.isConnected = false;
        });

        // Gestion gracieuse de l'arr√™t
        process.on('SIGINT', () => this.gracefulShutdown('SIGINT'));
        process.on('SIGTERM', () => this.gracefulShutdown('SIGTERM'));
    }

    /**
     * Arr√™t gracieux de Redis
     */
    async gracefulShutdown(signal) {
        logger.info(`Redis: Arr√™t gracieux re√ßu (${signal})`);
        if (this.client && this.isConnected) {
            try {
                await this.client.quit();
                logger.info('Redis: Connexion ferm√©e proprement');
            } catch (error) {
                logger.error('Redis: Erreur lors de la fermeture:', error);
            }
        }
    }

    /**
     * Obtenir le client Redis (avec auto-connexion)
     */
    async getClient() {
        if (!this.client || !this.isConnected) {
            await this.init();
        }
        return this.client;
    }

    /**
     * V√©rifier si Redis est connect√©
     */
    isHealthy() {
        return this.isConnected && this.client;
    }

    /**
     * Test de sant√© Redis
     */
    async healthCheck() {
        try {
            if (!this.isConnected || !this.client) {
                return { status: 'error', message: 'Not connected' };
            }

            const start = Date.now();
            await this.client.ping();
            const latency = Date.now() - start;

            return {
                status: 'ok',
                latency: `${latency}ms`,
                connected: this.isConnected,
                reconnectAttempts: this.reconnectAttempts
            };
        } catch (error) {
            return {
                status: 'error',
                message: error.message,
                connected: false
            };
        }
    }

    /**
     * Obtenir les informations de Redis
     */
    async getInfo() {
        try {
            const client = await this.getClient();
            const info = await client.info();
            const memory = await client.info('memory');
            
            return {
                info: this.parseRedisInfo(info),
                memory: this.parseRedisInfo(memory)
            };
        } catch (error) {
            logger.error('Erreur r√©cup√©ration info Redis:', error);
            return null;
        }
    }

    /**
     * Parser les informations Redis
     */
    parseRedisInfo(infoString) {
        const info = {};
        const lines = infoString.split('\r\n');
        
        lines.forEach(line => {
            if (line.includes(':') && !line.startsWith('#')) {
                const [key, value] = line.split(':');
                info[key] = isNaN(value) ? value : parseFloat(value);
            }
        });
        
        return info;
    }

    /**
     * Obtenir les m√©triques Redis
     */
    async getMetrics() {
        try {
            const client = await this.getClient();
            const info = await this.getInfo();
            
            if (!info) return null;

            const dbSize = await client.dbSize();
            const lastSave = await client.lastSave();
            
            return {
                connected_clients: info.info.connected_clients || 0,
                used_memory: info.memory.used_memory || 0,
                used_memory_human: info.memory.used_memory_human || '0B',
                total_commands_processed: info.info.total_commands_processed || 0,
                keyspace_hits: info.info.keyspace_hits || 0,
                keyspace_misses: info.info.keyspace_misses || 0,
                db_size: dbSize,
                last_save_time: lastSave,
                uptime_in_seconds: info.info.uptime_in_seconds || 0
            };
        } catch (error) {
            logger.error('Erreur r√©cup√©ration m√©triques Redis:', error);
            return null;
        }
    }

    /**
     * Nettoyer Redis (pour les tests)
     */
    async flush() {
        try {
            const client = await this.getClient();
            await client.flushDb();
            logger.info('Redis database flushed');
        } catch (error) {
            logger.error('Erreur flush Redis:', error);
            throw error;
        }
    }

    /**
     * Fermer la connexion Redis
     */
    async close() {
        if (this.client) {
            try {
                if (this.isConnected) {
                    await this.client.quit();
                }
                this.isConnected = false;
                this.client = null;
                logger.info('Redis client closed');
            } catch (error) {
                logger.error('Erreur fermeture Redis:', error);
            }
        }
    }

    /**
     * Wrapper pour les op√©rations Redis avec retry automatique
     */
    async withRetry(operation, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const client = await this.getClient();
                return await operation(client);
            } catch (error) {
                lastError = error;
                logger.warn(`Redis operation failed (attempt ${attempt}/${maxRetries}):`, error.message);
                
                if (attempt < maxRetries) {
                    // Attendre avant de retry
                    await new Promise(resolve => setTimeout(resolve, attempt * 1000));
                    // R√©initialiser la connexion si n√©cessaire
                    if (!this.isConnected) {
                        this.client = null;
                    }
                }
            }
        }
        
        throw lastError;
    }
}

// Singleton
const redisClient = new RedisClient();

/**
 * Obtenir le client Redis (fonction principale)
 */
async function getRedisClient() {
    return await redisClient.getClient();
}

/**
 * Wrapper simplifi√© pour les op√©rations courantes
 */
const redisOperations = {
    // GET
    get: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.get(key);
        });
    },

    // SET
    set: async (key, value, options = {}) => {
        return await redisClient.withRetry(async (client) => {
            return await client.set(key, value, options);
        });
    },

    // HGET ALL
    hGetAll: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.hGetAll(key);
        });
    },

    // HSET
    hSet: async (key, field, value) => {
        return await redisClient.withRetry(async (client) => {
            return await client.hSet(key, field, value);
        });
    },

    // DEL
    del: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.del(key);
        });
    },

    // EXISTS
    exists: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.exists(key);
        });
    },

    // EXPIRE
    expire: async (key, seconds) => {
        return await redisClient.withRetry(async (client) => {
            return await client.expire(key, seconds);
        });
    }
};

module.exports = {
    getRedisClient,
    redisClient,
    redisOperations,
    healthCheck: () => redisClient.healthCheck(),
    getInfo: () => redisClient.getInfo(),
    getMetrics: () => redisClient.getMetrics(),
    close: () => redisClient.close(),
    flush: () => redisClient.flush()
};


================================================
File: backend/src/utils/validation.js
================================================
// backend/src/utils/validation.js
const Joi = require('joi');
const FileService = require('../services/fileService');
const logger = require('./logger');

/**
 * Sch√©mas de validation avec Joi
 */
class ValidationSchemas {
    /**
     * Validation des param√®tres d'upload
     */
    static uploadSchema = Joi.object({
        file: Joi.object({
            originalname: Joi.string().required(),
            mimetype: Joi.string().required(),
            size: Joi.number().min(1).max(5 * 1024 * 1024 * 1024).required(), // 5GB max
            buffer: Joi.binary().required()
        }).required(),
        settings: Joi.object().optional()
    });

    /**
     * Validation des param√®tres d'image
     */
    static imageSettingsSchema = Joi.object({
        quality: Joi.number().min(1).max(100).default(80),
        maxWidth: Joi.number().min(100).max(8000).default(1920),
        maxHeight: Joi.number().min(100).max(8000).default(1080),
        format: Joi.string().valid('auto', 'jpeg', 'jpg', 'png', 'webp', 'avif', 'tiff').default('auto'),
        removeMetadata: Joi.boolean().default(true),
        progressive: Joi.boolean().default(true)
    });

    /**
     * Validation des param√®tres de vid√©o
     */
    static videoSettingsSchema = Joi.object({
        codec: Joi.string().valid('h264', 'h265', 'vp9', 'av1').default('h264'),
        crf: Joi.number().min(18).max(51).default(23),
        preset: Joi.string().valid('ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow').default('medium'),
        maxBitrate: Joi.string().regex(/^\d+[KMG]?$/).default('2M'),
        fps: Joi.number().min(1).max(60).optional(),
        resolution: Joi.string().valid('480p', '720p', '1080p', '1440p', '4K').optional()
    });

    /**
     * Validation des param√®tres d'audio
     */
    static audioSettingsSchema = Joi.object({
        codec: Joi.string().valid('aac', 'mp3', 'ogg', 'flac').default('aac'),
        bitrate: Joi.string().regex(/^\d+[k]?$/).default('128k'),
        sampleRate: Joi.number().valid(22050, 44100, 48000, 96000).default(44100),
        channels: Joi.number().valid(1, 2).default(2),
        normalize: Joi.boolean().default(false)
    });

    /**
     * Validation des param√®tres de document
     */
    static documentSettingsSchema = Joi.object({
        compress: Joi.boolean().default(true),
        removeMetadata: Joi.boolean().default(true),
        quality: Joi.number().min(1).max(100).default(80),
        optimizeImages: Joi.boolean().default(true)
    });

    /**
     * Validation d'un job
     */
    static jobSchema = Joi.object({
        id: Joi.string().uuid().required(),
        originalName: Joi.string().min(1).max(255).required(),
        filePath: Joi.string().required(),
        size: Joi.number().min(1).required(),
        type: Joi.string().valid('image', 'video', 'audio', 'document').required(),
        settings: Joi.object().required(),
        status: Joi.string().valid('uploaded', 'queued', 'processing', 'completed', 'error').default('uploaded'),
        progress: Joi.number().min(0).max(100).default(0),
        createdAt: Joi.date().iso().default(() => new Date()),
        updatedAt: Joi.date().iso().default(() => new Date())
    });

    /**
     * Validation des param√®tres de pagination
     */
    static paginationSchema = Joi.object({
        page: Joi.number().min(1).default(1),
        limit: Joi.number().min(1).max(100).default(20),
        sortBy: Joi.string().valid('createdAt', 'updatedAt', 'size', 'status').default('createdAt'),
        sortOrder: Joi.string().valid('asc', 'desc').default('desc')
    });

    /**
     * Validation des filtres de jobs
     */
    static jobFiltersSchema = Joi.object({
        status: Joi.string().valid('uploaded', 'queued', 'processing', 'completed', 'error').optional(),
        type: Joi.string().valid('image', 'video', 'audio', 'document').optional(),
        dateFrom: Joi.date().iso().optional(),
        dateTo: Joi.date().iso().optional(),
        minSize: Joi.number().min(0).optional(),
        maxSize: Joi.number().min(0).optional()
    });

    /**
     * Validation d'un ID de job
     */
    static jobIdSchema = Joi.string().uuid().required();

    /**
     * Validation des param√®tres de health check
     */
    static healthCheckSchema = Joi.object({
        includeMetrics: Joi.boolean().default(false),
        includeRedis: Joi.boolean().default(true),
        includeQueue: Joi.boolean().default(true)
    });
}

/**
 * Service de validation
 */
class ValidationService {
    /**
     * Valider un fichier upload√©
     */
    static async validateUpload(file, settings = {}) {
        try {
            // Validation de base
            const { error: baseError, value: validatedData } = ValidationSchemas.uploadSchema.validate({
                file,
                settings
            });

            if (baseError) {
                return {
                    isValid: false,
                    errors: baseError.details.map(detail => detail.message)
                };
            }

            const errors = [];

            // V√©rification du type de fichier
            const fileType = FileService.getFileType(file.originalname);
            if (fileType === 'unknown') {
                errors.push('Type de fichier non support√©');
            }

            // V√©rification de l'extension vs MIME type
            if (!this.validateMimeType(file.originalname, file.mimetype)) {
                errors.push('Extension de fichier et type MIME incompatibles');
            }

            // Validation des param√®tres selon le type
            if (fileType !== 'unknown') {
                const settingsValidation = this.validateSettings(fileType, settings);
                if (!settingsValidation.isValid) {
                    errors.push(...settingsValidation.errors);
                }
            }

            // V√©rification de la taille selon le type
            const maxSizeValidation = this.validateFileSize(fileType, file.size);
            if (!maxSizeValidation.isValid) {
                errors.push(maxSizeValidation.error);
            }

            return {
                isValid: errors.length === 0,
                errors,
                validatedData: errors.length === 0 ? validatedData : null,
                fileType
            };

        } catch (error) {
            logger.error('Erreur validation upload:', error);
            return {
                isValid: false,
                errors: ['Erreur interne de validation']
            };
        }
    }

    /**
     * Valider les param√®tres selon le type de fichier
     */
    static validateSettings(fileType, settings) {
        try {
            let schema;
            
            switch (fileType) {
                case 'image':
                    schema = ValidationSchemas.imageSettingsSchema;
                    break;
                case 'video':
                    schema = ValidationSchemas.videoSettingsSchema;
                    break;
                case 'audio':
                    schema = ValidationSchemas.audioSettingsSchema;
                    break;
                case 'document':
                    schema = ValidationSchemas.documentSettingsSchema;
                    break;
                default:
                    return { isValid: true, validatedSettings: settings };
            }

            const { error, value } = schema.validate(settings, { allowUnknown: false });
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedSettings: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedSettings: value
            };

        } catch (error) {
            logger.error('Erreur validation settings:', error);
            return {
                isValid: false,
                errors: ['Erreur validation des param√®tres']
            };
        }
    }

    /**
     * Valider la correspondance entre extension et MIME type
     */
    static validateMimeType(filename, mimetype) {
        const mimeTypeMap = {
            // Images
            '.jpg': ['image/jpeg'],
            '.jpeg': ['image/jpeg'],
            '.png': ['image/png'],
            '.webp': ['image/webp'],
            '.avif': ['image/avif'],
            '.heic': ['image/heic', 'image/heif'],
            '.tiff': ['image/tiff'],
            '.bmp': ['image/bmp'],
            
            // Vid√©os
            '.mp4': ['video/mp4'],
            '.avi': ['video/x-msvideo'],
            '.mkv': ['video/x-matroska'],
            '.webm': ['video/webm'],
            '.mov': ['video/quicktime'],
            '.flv': ['video/x-flv'],
            '.m4v': ['video/x-m4v'],
            
            // Audio
            '.mp3': ['audio/mpeg'],
            '.flac': ['audio/flac'],
            '.wav': ['audio/wav', 'audio/wave'],
            '.aac': ['audio/aac'],
            '.ogg': ['audio/ogg'],
            '.m4a': ['audio/mp4', 'audio/x-m4a'],
            '.wma': ['audio/x-ms-wma'],
            
            // Documents
            '.pdf': ['application/pdf']
        };

        const ext = require('path').extname(filename).toLowerCase();
        const allowedMimeTypes = mimeTypeMap[ext];

        if (!allowedMimeTypes) {
            return false; // Extension non support√©e
        }

        return allowedMimeTypes.includes(mimetype);
    }

    /**
     * Valider la taille de fichier selon le type
     */
    static validateFileSize(fileType, size) {
        const maxSizes = {
            image: 100 * 1024 * 1024,    // 100MB
            video: 5 * 1024 * 1024 * 1024, // 5GB
            audio: 500 * 1024 * 1024,    // 500MB
            document: 100 * 1024 * 1024  // 100MB
        };

        const maxSize = maxSizes[fileType] || 100 * 1024 * 1024; // 100MB par d√©faut

        if (size > maxSize) {
            return {
                isValid: false,
                error: `Taille de fichier trop importante (max: ${this.formatFileSize(maxSize)})`
            };
        }

        return { isValid: true };
    }

    /**
     * Valider un job complet
     */
    static validateJob(jobData) {
        try {
            const { error, value } = ValidationSchemas.jobSchema.validate(jobData);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedJob: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedJob: value
            };

        } catch (error) {
            logger.error('Erreur validation job:', error);
            return {
                isValid: false,
                errors: ['Erreur validation du job']
            };
        }
    }

    /**
     * Valider les param√®tres de pagination
     */
    static validatePagination(params) {
        try {
            const { error, value } = ValidationSchemas.paginationSchema.validate(params);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedParams: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedParams: value
            };

        } catch (error) {
            logger.error('Erreur validation pagination:', error);
            return {
                isValid: false,
                errors: ['Erreur validation pagination']
            };
        }
    }

    /**
     * Valider les filtres de jobs
     */
    static validateJobFilters(filters) {
        try {
            const { error, value } = ValidationSchemas.jobFiltersSchema.validate(filters);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedFilters: null
                };
            }

            // Validation additionnelle pour les dates
            if (value.dateFrom && value.dateTo && value.dateFrom > value.dateTo) {
                return {
                    isValid: false,
                    errors: ['La date de d√©but doit √™tre ant√©rieure √† la date de fin'],
                    validatedFilters: null
                };
            }

            // Validation additionnelle pour les tailles
            if (value.minSize && value.maxSize && value.minSize > value.maxSize) {
                return {
                    isValid: false,
                    errors: ['La taille minimum doit √™tre inf√©rieure √† la taille maximum'],
                    validatedFilters: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedFilters: value
            };

        } catch (error) {
            logger.error('Erreur validation filtres:', error);
            return {
                isValid: false,
                errors: ['Erreur validation des filtres']
            };
        }
    }

    /**
     * Valider un ID de job
     */
    static validateJobId(jobId) {
        try {
            const { error, value } = ValidationSchemas.jobIdSchema.validate(jobId);
            
            if (error) {
                return {
                    isValid: false,
                    errors: ['ID de job invalide (UUID requis)'],
                    validatedId: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedId: value
            };

        } catch (error) {
            logger.error('Erreur validation ID job:', error);
            return {
                isValid: false,
                errors: ['Erreur validation ID']
            };
        }
    }

    /**
     * Valider les param√®tres de health check
     */
    static validateHealthCheck(params) {
        try {
            const { error, value } = ValidationSchemas.healthCheckSchema.validate(params);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedParams: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedParams: value
            };

        } catch (error) {
            logger.error('Erreur validation health check:', error);
            return {
                isValid: false,
                errors: ['Erreur validation health check']
            };
        }
    }

    /**
     * Nettoyer et valider un nom de fichier
     */
    static sanitizeFilename(filename) {
        if (!filename || typeof filename !== 'string') {
            return null;
        }

        // Supprimer les caract√®res dangereux
        let cleaned = filename
            .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_') // Caract√®res interdits
            .replace(/^\.+/, '_') // Points au d√©but
            .replace(/\.+$/, '') // Points √† la fin
            .replace(/\s+/g, '_') // Espaces multiples
            .trim();

        // Limiter la longueur
        if (cleaned.length > 255) {
            const ext = require('path').extname(cleaned);
            const name = require('path').basename(cleaned, ext);
            cleaned = name.substring(0, 255 - ext.length) + ext;
        }

        // V√©rifier qu'il reste quelque chose
        if (!cleaned || cleaned === '_') {
            return null;
        }

        return cleaned;
    }

    /**
     * Valider et nettoyer les en-t√™tes HTTP
     */
    static validateHeaders(headers) {
        const allowedHeaders = [
            'content-type',
            'content-length',
            'authorization',
            'x-requested-with',
            'user-agent'
        ];

        const cleanHeaders = {};
        
        for (const [key, value] of Object.entries(headers)) {
            const lowerKey = key.toLowerCase();
            if (allowedHeaders.includes(lowerKey)) {
                cleanHeaders[lowerKey] = value;
            }
        }

        return cleanHeaders;
    }

    /**
     * Formater la taille d'un fichier
     */
    static formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Middleware Express pour validation automatique
     */
    static createValidationMiddleware(schema, property = 'body') {
        return (req, res, next) => {
            const { error, value } = schema.validate(req[property]);
            
            if (error) {
                const errors = error.details.map(detail => detail.message);
                logger.security(`Validation failed: ${errors.join(', ')}`, {
                    ip: req.ip,
                    userAgent: req.get('User-Agent'),
                    path: req.path
                });
                
                return res.status(400).json({
                    success: false,
                    error: 'Donn√©es invalides',
                    details: errors
                });
            }

            req[property] = value;
            next();
        };
    }

    /**
     * Validation de s√©curit√© pour les uploads
     */
    static validateUploadSecurity(file, req) {
        const errors = [];

        // V√©rifier les magic bytes (signatures de fichier)
        if (!this.validateMagicBytes(file.buffer, file.originalname)) {
            errors.push('Signature de fichier invalide');
        }

        // V√©rifier la taille r√©elle vs d√©clar√©e
        if (file.buffer.length !== file.size) {
            errors.push('Taille de fichier incoh√©rente');
        }

        // V√©rifier les m√©tadonn√©es suspectes
        if (this.containsSuspiciousContent(file.originalname)) {
            errors.push('Nom de fichier suspect');
        }

        // Rate limiting par IP
        const userAgent = req.get('User-Agent') || '';
        if (this.isSuspiciousUserAgent(userAgent)) {
            errors.push('User-Agent suspect');
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Valider les magic bytes d'un fichier
     */
    static validateMagicBytes(buffer, filename) {
        if (!buffer || buffer.length < 4) return false;

        const magicBytes = {
            // Images
            'jpg': [0xFF, 0xD8, 0xFF],
            'png': [0x89, 0x50, 0x4E, 0x47],
            'webp': [0x52, 0x49, 0x46, 0x46], // + WEBP √† l'offset 8
            'pdf': [0x25, 0x50, 0x44, 0x46],
            // Ajouter d'autres signatures selon les besoins
        };

        const ext = require('path').extname(filename).toLowerCase().substring(1);
        const expectedSignature = magicBytes[ext];

        if (!expectedSignature) {
            return true; // Pas de signature connue, on laisse passer
        }

        for (let i = 0; i < expectedSignature.length; i++) {
            if (buffer[i] !== expectedSignature[i]) {
                return false;
            }
        }

        return true;
    }

    /**
     * D√©tecter du contenu suspect dans un nom de fichier
     */
    static containsSuspiciousContent(filename) {
        const suspiciousPatterns = [
            /\.(exe|bat|cmd|scr|pif|com)$/i,
            /\.(php|asp|jsp|cgi)$/i,
            /<script/i,
            /javascript:/i,
            /\.\./,
            /^(con|prn|aux|nul|com[1-9]|lpt[1-9])$/i
        ];

        return suspiciousPatterns.some(pattern => pattern.test(filename));
    }

    /**
     * D√©tecter un User-Agent suspect
     */
    static isSuspiciousUserAgent(userAgent) {
        if (!userAgent || userAgent.length < 10) return true;
        
        const suspiciousPatterns = [
            /bot|crawler|spider|scraper/i,
            /^curl/i,
            /^wget/i,
            /python-requests/i
        ];

        return suspiciousPatterns.some(pattern => pattern.test(userAgent));
    }
}

/**
 * Middleware de validation rapide pour les routes Express
 */
const validateRequest = {
    upload: ValidationService.createValidationMiddleware(ValidationSchemas.uploadSchema),
    jobId: ValidationService.createValidationMiddleware(ValidationSchemas.jobIdSchema, 'params'),
    pagination: ValidationService.createValidationMiddleware(ValidationSchemas.paginationSchema, 'query'),
    jobFilters: ValidationService.createValidationMiddleware(ValidationSchemas.jobFiltersSchema, 'query'),
    healthCheck: ValidationService.createValidationMiddleware(ValidationSchemas.healthCheckSchema, 'query')
};

module.exports = {
    ValidationSchemas,
    ValidationService,
    validateRequest
};


================================================
File: backend/src/workers/processor.js
================================================
// backend/src/workers/processor.js
require('dotenv').config();

const { processingQueue } = require('../services/queueService');
const ProcessingService = require('../services/processingService');
const JobService = require('../services/jobService');
const FileService = require('../services/fileService');
const logger = require('../utils/logger');
const { getRedisClient } = require('../utils/redis');

/**
 * Worker de traitement des fichiers multim√©dia
 */
class FileProcessor {
    constructor() {
        this.isShuttingDown = false;
        this.activeJobs = new Map();
        this.stats = {
            processed: 0,
            failed: 0,
            startTime: Date.now(),
            totalProcessingTime: 0
        };
    }

    /**
     * Initialiser le worker
     */
    async init() {
        try {
            logger.info('üîß Initialisation du worker de traitement');

            // V√©rifier les pr√©requis
            await this.checkPrerequisites();

            // Configuration du worker
            this.setupWorker();

            // Gestion gracieuse de l'arr√™t
            this.setupGracefulShutdown();

            // Monitoring p√©riodique
            this.setupMonitoring();

            logger.info('‚úÖ Worker de traitement initialis√©');
        } catch (error) {
            logger.error('‚ùå Erreur initialisation worker:', error);
            throw error;
        }
    }

    /**
     * V√©rifier les pr√©requis
     */
    async checkPrerequisites() {
        try {
            // V√©rifier Redis
            const redis = await getRedisClient();
            await redis.ping();
            logger.info('‚úÖ Redis connect√©');

            // V√©rifier Sharp
            const sharp = require('sharp');
            logger.info(`‚úÖ Sharp v${sharp.versions.sharp} disponible`);

            // V√©rifier les r√©pertoires
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            await FileService.ensureDirectoryExists(tempDir);
            await FileService.ensureDirectoryExists(`${tempDir}/output`);
            logger.info('‚úÖ R√©pertoires v√©rifi√©s');

        } catch (error) {
            throw new Error(`Pr√©requis worker non satisfaits: ${error.message}`);
        }
    }

    /**
     * Configuration du worker Bull
     */
    setupWorker() {
        logger.info('‚öôÔ∏è Configuration du worker Bull...');

        const concurrency = parseInt(process.env.WORKER_CONCURRENCY) || 2;
        const jobTimeout = parseInt(process.env.JOB_TIMEOUT) || 1800; // 30 minutes

        // Configuration du processeur principal
        processingQueue.process('optimize-file', concurrency, async (job) => {
            return await this.processJob(job);
        });

        // √âv√©nements du worker
        processingQueue.on('active', (job) => {
            const jobData = job.data.jobData;
            this.activeJobs.set(job.id, {
                jobId: jobData.id,
                startTime: Date.now(),
                fileName: jobData.originalName,
                type: jobData.type
            });

            logger.processing(`Job d√©marr√©: ${jobData.id} (${jobData.originalName})`);
        });

        processingQueue.on('completed', (job, result) => {
            const activeJob = this.activeJobs.get(job.id);
            if (activeJob) {
                const processingTime = Date.now() - activeJob.startTime;
                this.stats.processed++;
                this.stats.totalProcessingTime += processingTime;
                
                logger.processing(`Job termin√©: ${result.jobId} en ${processingTime}ms`);
                this.activeJobs.delete(job.id);
            }
        });

        processingQueue.on('failed', (job, error) => {
            const activeJob = this.activeJobs.get(job.id);
            if (activeJob) {
                this.stats.failed++;
                logger.error(`Job √©chou√©: ${activeJob.jobId}`, error);
                this.activeJobs.delete(job.id);
            }
        });

        processingQueue.on('stalled', (job) => {
            const jobData = job.data.jobData;
            logger.warn(`Job bloqu√©: ${jobData.id} (${jobData.originalName})`);
        });

        processingQueue.on('progress', (job, progress) => {
            const jobData = job.data.jobData;
            logger.debug(`Progression ${jobData.id}: ${progress}%`);
        });

        logger.info(`‚úÖ Worker configur√© (concurrence: ${concurrency}, timeout: ${jobTimeout}s)`);
    }

    /**
     * Traiter un job
     */
    async processJob(bullJob) {
        const { jobData } = bullJob.data;
        const startTime = Date.now();
        
        const jobLogger = logger.withContext({
            jobId: jobData.id,
            worker: 'processor',
            fileName: jobData.originalName
        });

        try {
            jobLogger.info('üîÑ D√©marrage du traitement');

            // Validation pr√©alable
            const validation = await ProcessingService.validateJob(jobData);
            if (!validation.isValid) {
                throw new Error(`Validation √©chou√©e: ${validation.errors.join(', ')}`);
            }

            // Callback de progression pour Bull et WebSocket
            const progressCallback = async (progress) => {
                // Mettre √† jour Bull
                bullJob.progress(progress);
                
                // Mettre √† jour Redis
                await JobService.updateJob(jobData.id, { progress });
                
                // Notifier via WebSocket (si serveur disponible)
                if (global.io) {
                    global.io.emitJobProgress(jobData.id, progress);
                }
                
                jobLogger.debug(`Progression: ${progress}%`);
            };

            // Traitement principal
            jobLogger.info('üöÄ D√©but du traitement du fichier');
            const result = await ProcessingService.processFile(jobData, progressCallback);

            const processingTime = Date.now() - startTime;
            jobLogger.info(`‚úÖ Traitement termin√© en ${processingTime}ms`);

            // Notifier la completion via WebSocket
            if (global.io) {
                global.io.emitJobCompleted(jobData.id, {
                    status: 'completed',
                    ...result,
                    processingTime
                });
            }

            // M√©triques
            this.recordMetrics(jobData, processingTime, result);

            return {
                jobId: jobData.id,
                success: true,
                ...result,
                processingTime
            };

        } catch (error) {
            const processingTime = Date.now() - startTime;
            
            jobLogger.error('‚ùå Erreur traitement:', error, { processingTime });

            // Mettre √† jour le job en erreur
            await JobService.updateJob(jobData.id, {
                status: 'error',
                error: error.message,
                progress: 0
            });

            // Notifier l'erreur via WebSocket
            if (global.io) {
                global.io.emitJobError(jobData.id, error);
            }

            // Nettoyer les fichiers en cas d'erreur
            await this.cleanupJobFiles(jobData);

            throw error;
        }
    }

    /**
     * Nettoyer les fichiers d'un job en erreur
     */
    async cleanupJobFiles(jobData) {
        try {
            // Supprimer le fichier source si il existe
            if (jobData.filePath) {
                await FileService.deleteFile(jobData.filePath);
            }

            // Supprimer le fichier de sortie partiel si il existe
            const outputDir = `${process.env.TEMP_DIR || '/tmp/uploads'}/output`;
            const possibleOutputs = [
                `${outputDir}/${jobData.id}.jpg`,
                `${outputDir}/${jobData.id}.png`,
                `${outputDir}/${jobData.id}.webp`,
                `${outputDir}/${jobData.id}_processed.mp4`,
                `${outputDir}/${jobData.id}_processed.mp3`,
                `${outputDir}/${jobData.id}_processed.pdf`
            ];

            for (const file of possibleOutputs) {
                await FileService.deleteFile(file).catch(() => {}); // Ignore les erreurs
            }

            logger.debug(`Fichiers nettoy√©s pour job ${jobData.id}`);
        } catch (error) {
            logger.warn(`Erreur nettoyage fichiers job ${jobData.id}:`, error);
        }
    }

    /**
     * Enregistrer les m√©triques de traitement
     */
    recordMetrics(jobData, processingTime, result) {
        try {
            const metrics = {
                type: jobData.type,
                originalSize: jobData.size,
                compressedSize: result.compressedSize,
                compressionRatio: result.compressionRatio,
                processingTime,
                timestamp: new Date().toISOString()
            };

            // Log m√©trique
            logger.metric('file_processed', 1, 'count', metrics);
            logger.metric('processing_time', processingTime, 'ms', {
                type: jobData.type,
                size: jobData.size
            });

            if (result.compressionRatio > 0) {
                logger.metric('compression_ratio', result.compressionRatio, '%', {
                    type: jobData.type
                });
                logger.metric('bytes_saved', jobData.size - result.compressedSize, 'bytes', {
                    type: jobData.type
                });
            }

        } catch (error) {
            logger.warn('Erreur enregistrement m√©triques:', error);
        }
    }

    /**
     * Configuration de l'arr√™t gracieux
     */
    setupGracefulShutdown() {
        logger.info('üõ°Ô∏è Configuration arr√™t gracieux worker...');

        const shutdown = async (signal) => {
            if (this.isShuttingDown) return;
            this.isShuttingDown = true;

            logger.info(`üõë Arr√™t gracieux worker d√©marr√© (${signal})`);

            try {
                // 1. Arr√™ter d'accepter de nouveaux jobs
                await processingQueue.pause();
                logger.info('Queue mise en pause');

                // 2. Attendre la fin des jobs en cours (max 5 minutes)
                const timeout = 5 * 60 * 1000; // 5 minutes
                const startTime = Date.now();

                while (this.activeJobs.size > 0 && (Date.now() - startTime) < timeout) {
                    logger.info(`Attente fin des jobs en cours (${this.activeJobs.size} restants)`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                if (this.activeJobs.size > 0) {
                    logger.warn(`Timeout atteint, arr√™t forc√© (${this.activeJobs.size} jobs interrompus)`);
                }

                // 3. Fermer la queue
                await processingQueue.close();
                logger.info('Queue ferm√©e');

                // 4. Afficher les statistiques finales
                this.logFinalStats();

                logger.info('‚úÖ Arr√™t gracieux worker termin√©');
                process.exit(0);

            } catch (error) {
                logger.error('‚ùå Erreur arr√™t gracieux worker:', error);
                process.exit(1);
            }
        };

        // Signaux d'arr√™t
        process.on('SIGTERM', () => shutdown('SIGTERM'));
        process.on('SIGINT', () => shutdown('SIGINT'));
        process.on('SIGUSR2', () => shutdown('SIGUSR2')); // Nodemon

        // Erreurs non g√©r√©es
        process.on('uncaughtException', (error) => {
            logger.error('Exception non g√©r√©e worker:', error);
            shutdown('uncaughtException');
        });

        process.on('unhandledRejection', (reason, promise) => {
            logger.error('Rejection non g√©r√©e worker:', reason, { promise });
            shutdown('unhandledRejection');
        });

        logger.info('‚úÖ Arr√™t gracieux worker configur√©');
    }

    /**
     * Configuration du monitoring p√©riodique
     */
    setupMonitoring() {
        logger.info('üìä Configuration monitoring worker...');

        // Stats p√©riodiques toutes les 5 minutes
        setInterval(() => {
            this.logWorkerStats();
        }, 5 * 60 * 1000);

        // Health check toutes les minutes
        setInterval(async () => {
            await this.healthCheck();
        }, 60 * 1000);

        logger.info('‚úÖ Monitoring worker configur√©');
    }

    /**
     * Afficher les statistiques du worker
     */
    logWorkerStats() {
        const uptime = Date.now() - this.stats.startTime;
        const avgProcessingTime = this.stats.processed > 0 
            ? Math.round(this.stats.totalProcessingTime / this.stats.processed)
            : 0;

        const memUsage = process.memoryUsage();

        logger.info('üìä Statistiques worker', {
            uptime: Math.round(uptime / 1000),
            uptimeFormatted: this.formatDuration(uptime),
            activeJobs: this.activeJobs.size,
            processed: this.stats.processed,
            failed: this.stats.failed,
            avgProcessingTime: `${avgProcessingTime}ms`,
            memory: {
                rss: FileService.formatFileSize(memUsage.rss),
                heapUsed: FileService.formatFileSize(memUsage.heapUsed),
                heapTotal: FileService.formatFileSize(memUsage.heapTotal)
            }
        });

        // M√©triques d√©taill√©es des jobs actifs
        if (this.activeJobs.size > 0) {
            const activeJobsInfo = Array.from(this.activeJobs.values()).map(job => ({
                jobId: job.jobId,
                fileName: job.fileName,
                type: job.type,
                duration: Date.now() - job.startTime
            }));

            logger.info('üîÑ Jobs actifs', { jobs: activeJobsInfo });
        }
    }

    /**
     * Health check du worker
     */
    async healthCheck() {
        try {
            // V√©rifier Redis
            const redis = await getRedisClient();
            await redis.ping();

            // V√©rifier l'espace disque
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            const dirStats = await FileService.getDirectorySize(tempDir);

            // V√©rifier la m√©moire
            const memUsage = process.memoryUsage();
            const memLimit = 1 * 1024 * 1024 * 1024; // 1GB limite
            
            if (memUsage.heapUsed > memLimit) {
                logger.warn('‚ö†Ô∏è Utilisation m√©moire √©lev√©e', {
                    heapUsed: FileService.formatFileSize(memUsage.heapUsed),
                    limit: FileService.formatFileSize(memLimit)
                });
            }

            // V√©rifier les jobs bloqu√©s
            const now = Date.now();
            const maxJobDuration = 30 * 60 * 1000; // 30 minutes
            
            for (const [bullJobId, activeJob] of this.activeJobs) {
                if (now - activeJob.startTime > maxJobDuration) {
                    logger.warn('‚ö†Ô∏è Job potentiellement bloqu√©', {
                        jobId: activeJob.jobId,
                        duration: now - activeJob.startTime,
                        fileName: activeJob.fileName
                    });
                }
            }

        } catch (error) {
            logger.error('‚ùå Health check worker √©chou√©:', error);
        }
    }

    /**
     * Afficher les statistiques finales
     */
    logFinalStats() {
        const uptime = Date.now() - this.stats.startTime;
        const successRate = this.stats.processed + this.stats.failed > 0
            ? Math.round((this.stats.processed / (this.stats.processed + this.stats.failed)) * 100)
            : 0;

        logger.info('üìà Statistiques finales worker', {
            uptime: this.formatDuration(uptime),
            processed: this.stats.processed,
            failed: this.stats.failed,
            successRate: `${successRate}%`,
            totalProcessingTime: this.formatDuration(this.stats.totalProcessingTime),
            avgProcessingTime: this.stats.processed > 0 
                ? Math.round(this.stats.totalProcessingTime / this.stats.processed)
                : 0
        });
    }

    /**
     * Formater une dur√©e en millisecondes
     */
    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
            return `${days}j ${hours % 24}h ${minutes % 60}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        } else {
            return `${seconds}s`;
        }
    }

    /**
     * Obtenir les statistiques actuelles
     */
    getStats() {
        const uptime = Date.now() - this.stats.startTime;
        
        return {
            uptime,
            uptimeFormatted: this.formatDuration(uptime),
            activeJobs: this.activeJobs.size,
            processed: this.stats.processed,
            failed: this.stats.failed,
            successRate: this.stats.processed + this.stats.failed > 0
                ? Math.round((this.stats.processed / (this.stats.processed + this.stats.failed)) * 100)
                : 100,
            avgProcessingTime: this.stats.processed > 0 
                ? Math.round(this.stats.totalProcessingTime / this.stats.processed)
                : 0,
            memory: process.memoryUsage()
        };
    }
}

/**
 * Fonction principale de d√©marrage du worker
 */
async function main() {
    try {
        logger.info('üéØ File Optimizer Worker v2.0.0');
        logger.info(`üìç Environnement: ${process.env.NODE_ENV || 'development'}`);
        logger.info(`üîß Node.js: ${process.version}`);
        logger.info(`üë∑ PID: ${process.pid}`);

        const processor = new FileProcessor();
        await processor.init();

        // Exposer les stats du worker
        global.getWorkerStats = () => processor.getStats();

        logger.info('üéâ Worker de traitement d√©marr√© avec succ√®s !');
        logger.info('‚è≥ En attente de jobs √† traiter...');

    } catch (error) {
        logger.error('üí• √âchec d√©marrage worker:', error);
        process.exit(1);
    }
}

// D√©marrer le worker si ce fichier est ex√©cut√© directement
if (require.main === module) {
    main();
}

module.exports = { FileProcessor, main };



================================================
File: frontend/index.html
================================================
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>File Optimizer - Compresseur de Fichiers</title>
    
    <!-- Styles CSS -->
    <link rel="stylesheet" href="css/styles.css">
    
    <!-- Socket.IO CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.js"></script>
    
    <!-- Favicon et m√©tadonn√©es -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üóúÔ∏è</text></svg>" type="image/svg+xml">
    <meta name="description" content="Compressez et optimisez vos fichiers multim√©dia sans changer leur format">
    <meta name="keywords" content="compression fichiers, optimisation images, compresseur vid√©o">
    <meta name="author" content="File Optimizer Team">
    
    <!-- Open Graph pour partage social -->
    <meta property="og:title" content="File Optimizer - Compresseur de Fichiers">
    <meta property="og:description" content="Compressez et optimisez vos fichiers multim√©dia sans changer leur format">
    <meta property="og:type" content="website">
    <meta property="og:image" content="assets/og-image.png">
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com;
        style-src 'self' 'unsafe-inline';
        connect-src 'self' ws: wss:;
        img-src 'self' data: blob:;
        font-src 'self' data:;
    ">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>
                <span class="logo">üóúÔ∏è</span>
                <span class="title-text">File Optimizer</span>
            </h1>
            <p>Compressez et optimisez vos fichiers multim√©dia sans changer leur format</p>
        </header>

        <!-- Upload Section -->
        <section class="upload-section">
            <div class="upload-zone" id="uploadZone">
                <div class="upload-icon">
                    üì§
                </div>
                <div class="upload-text">Glissez vos fichiers ici ou cliquez pour s√©lectionner</div>
                <div class="upload-subtext">
                    Images, vid√©os, audio et documents ‚Ä¢ Maximum 5GB
                </div>
                <input type="file" id="fileInput" class="file-input" multiple 
                       accept="image/*,video/*,audio/*,.pdf">
            </div>
        </section>

        <!-- Settings Panel -->
        <section class="settings-panel" id="settingsPanel">
            <h2 class="settings-title">
                <span class="section-icon">‚öôÔ∏è</span>
                <span>Param√®tres de compression</span>
            </h2>
            <div class="settings-grid" id="settingsGrid">
                <!-- Les param√®tres seront g√©n√©r√©s dynamiquement selon le type de fichier -->
            </div>
        </section>

        <!-- Jobs Section -->
        <section class="jobs-section">
            <h2 class="jobs-title">
                <span class="section-icon">üìã</span>
                <span>Fichiers en traitement</span>
            </h2>
            <div class="jobs-controls">
                <button class="btn btn-secondary" id="refreshJobs">
                    <span>üîÑ</span>
                    <span>Actualiser</span>
                </button>
                <button class="btn btn-secondary" id="clearCompleted">
                    <span>üßπ</span>
                    <span>Nettoyer termin√©s</span>
                </button>
            </div>
            <div id="jobsList">
                <div class="empty-state">
                    <div class="empty-state-icon">
                        üìÅ
                    </div>
                    <div>Aucun fichier en cours de traitement</div>
                    <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                        Uploadez un fichier pour commencer
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Status Indicator -->
    <div class="status-indicator" id="statusIndicator">
        <div class="status-icon" id="statusIcon"></div>
        <div id="statusMessage"></div>
        <button class="status-close" id="statusClose">&times;</button>
    </div>

    <!-- Connection Status -->
    <div class="connection-status disconnected" id="connectionStatus">
        <div class="connection-dot"></div>
        <span>D√©connect√©</span>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <div class="loading-text">Chargement...</div>
        </div>
    </div>

    <!-- JavaScript Files - ORDRE CRITIQUE -->
    <script src="js/utils.js"></script>
    <script src="js/api.js"></script>
    <script src="js/websocket.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/app.js"></script>
    
    <!-- Error Handler Global -->
    <script>
        // Gestionnaire d'erreurs global
        window.addEventListener('error', (event) => {
            console.error('Erreur JavaScript:', event.error);
            if (window.fileOptimizer && window.fileOptimizer.ui) {
                window.fileOptimizer.ui.showStatus('Erreur inattendue d√©tect√©e', 'error');
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Promise rejet√©e:', event.reason);
            if (window.fileOptimizer && window.fileOptimizer.ui) {
                window.fileOptimizer.ui.showStatus('Erreur async non g√©r√©e', 'error');
            }
        });

        // V√©rification des modules requis
        document.addEventListener('DOMContentLoaded', () => {
            const requiredModules = ['Utils', 'ApiClient', 'WebSocketManager', 'UIManager'];
            const missingModules = requiredModules.filter(module => !window[module]);
            
            if (missingModules.length > 0) {
                console.error('Modules manquants:', missingModules);
                document.body.innerHTML = `
                    <div style="
                        position: fixed; 
                        top: 50%; 
                        left: 50%; 
                        transform: translate(-50%, -50%);
                        background: #1e293b; 
                        color: #f8fafc; 
                        padding: 2rem; 
                        border-radius: 12px; 
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
                        text-align: center;
                        max-width: 400px;
                        border: 1px solid #334155;
                    ">
                        <h2 style="color: #ef4444; margin-bottom: 1rem;">‚ùå Erreur de Chargement</h2>
                        <p style="margin-bottom: 1rem;">Modules JavaScript manquants:</p>
                        <ul style="list-style: none; padding: 0; margin-bottom: 1.5rem;">
                            ${missingModules.map(m => `<li style="color: #fbbf24;">‚Ä¢ ${m}</li>`).join('')}
                        </ul>
                        <p style="font-size: 0.9rem; color: #cbd5e1;">
                            V√©rifiez que tous les fichiers .js sont pr√©sents et se chargent correctement.
                        </p>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>


================================================
File: frontend/css/styles.css
================================================
/* ===========================================
   üóúÔ∏è File Optimizer - Styles CSS CORRIG√âS
   Frontend moderne et responsive
   =========================================== */

/* Variables CSS */
:root {
    /* Couleurs principales */
    --primary: #2563eb;
    --primary-dark: #1d4ed8;
    --primary-light: #3b82f6;
    --secondary: #64748b;
    --success: #10b981;
    --warning: #f59e0b;
    --error: #ef4444;
    --info: #06b6d4;

    /* Couleurs interface */
    --background: #0f172a;
    --background-alt: #1e293b;
    --surface: #1e293b;
    --surface-alt: #334155;
    --border: #334155;
    --border-light: #475569;
    
    /* Couleurs texte */
    --text: #f8fafc;
    --text-light: #cbd5e1;
    --text-muted: #64748b;
    
    /* Ombres */
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
    --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    
    /* Rayons de courbure */
    --radius-sm: 6px;
    --radius: 8px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    --radius-full: 9999px;
    
    /* Espacements */
    --space-xs: 0.25rem;
    --space-sm: 0.5rem;
    --space: 1rem;
    --space-lg: 1.5rem;
    --space-xl: 2rem;
    --space-2xl: 3rem;
    
    /* Transitions */
    --transition: all 0.2s ease;
    --transition-slow: all 0.3s ease;
}

/* R√©initialisation et base */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    scroll-behavior: smooth;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--background);
    color: var(--text);
    line-height: 1.6;
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    min-height: 100vh;
}

/* Container principal */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--space-xl);
    width: 100%;
}

/* ===========================================
   HEADER - CORRIG√â
   =========================================== */
.header {
    text-align: center;
    margin-bottom: var(--space-2xl);
    width: 100%;
}

.header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--text);
    margin-bottom: var(--space-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space);
    /* FIX: √âviter chevauchement */
    white-space: nowrap;
    flex-wrap: nowrap;
    width: 100%;
    overflow: visible;
}

.logo {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    object-fit: contain;
}

.header p {
    font-size: 1.1rem;
    color: var(--text-light);
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.5;
    padding: 0 var(--space);
}

/* ===========================================
   SECTIONS - CORRIG√âES
   =========================================== */
.upload-section,
.settings-panel,
.jobs-section {
    background: var(--surface);
    border-radius: var(--radius-xl);
    padding: var(--space-xl);
    box-shadow: var(--shadow);
    margin-bottom: var(--space-xl);
    border: 1px solid var(--border);
    width: 100%;
    overflow: hidden;
}

.section-icon {
    width: 20px;
    height: 20px;
    margin-right: var(--space-sm);
    flex-shrink: 0;
}

/* ===========================================
   UPLOAD ZONE - CORRIG√âE
   =========================================== */
.upload-zone {
    border: 3px dashed var(--border);
    border-radius: var(--radius-lg);
    padding: var(--space-2xl);
    text-align: center;
    transition: var(--transition-slow);
    cursor: pointer;
    position: relative;
    overflow: hidden;
    background: var(--surface-alt);
    width: 100%;
    min-height: 200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.upload-zone:hover {
    border-color: var(--primary);
    background: rgba(37, 99, 235, 0.1);
    transform: translateY(-2px);
}

.upload-zone.dragover {
    border-color: var(--primary);
    background: rgba(37, 99, 235, 0.2);
    transform: scale(1.02);
    box-shadow: var(--shadow-lg);
}

.upload-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto var(--space);
    background: var(--primary);
    border-radius: var(--radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 24px;
    flex-shrink: 0;
}

.upload-icon img {
    width: 32px;
    height: 32px;
    filter: invert(1);
}

.upload-text {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: var(--space-sm);
    text-align: center;
    line-height: 1.4;
}

.upload-subtext {
    color: var(--text-light);
    font-size: 0.9rem;
    text-align: center;
    line-height: 1.4;
}

.file-input {
    display: none;
}

/* ===========================================
   SETTINGS PANEL - CORRIG√âE
   =========================================== */
.settings-panel {
    display: none;
    animation: slideDown 0.3s ease;
}

.settings-panel.active {
    display: block;
}

.settings-title {
    font-size: 1.3rem;
    font-weight: 600;
    margin-bottom: var(--space-lg);
    color: var(--text);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    white-space: nowrap;
    overflow: visible;
}

.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-lg);
    width: 100%;
}

.setting-group {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
}

.setting-label {
    font-weight: 500;
    color: var(--text);
    font-size: 0.9rem;
    line-height: 1.4;
}

.setting-input,
.setting-select {
    padding: 0.75rem;
    border: 2px solid var(--border);
    border-radius: var(--radius);
    font-size: 0.9rem;
    transition: var(--transition);
    background: var(--surface-alt);
    color: var(--text);
    width: 100%;
}

.setting-input:focus,
.setting-select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
}

.setting-description {
    font-size: 0.8rem;
    color: var(--text-muted);
    line-height: 1.3;
}

/* ===========================================
   JOBS SECTION - CORRIG√âE
   =========================================== */
.jobs-title {
    font-size: 1.3rem;
    font-weight: 600;
    color: var(--text);
    display: flex;
    align-items: center;
    margin-bottom: var(--space);
    gap: var(--space-sm);
    white-space: nowrap;
    overflow: visible;
}

.jobs-controls {
    display: flex;
    gap: var(--space);
    margin-bottom: var(--space-lg);
    flex-wrap: wrap;
    align-items: center;
}

.job-item {
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    margin-bottom: var(--space);
    transition: var(--transition);
    background: var(--surface-alt);
    width: 100%;
    overflow: hidden;
}

.job-item:hover {
    box-shadow: var(--shadow);
    transform: translateY(-1px);
}

.job-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space);
    gap: var(--space);
    flex-wrap: wrap;
}

.job-name {
    font-weight: 600;
    color: var(--text);
    font-size: 1rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 300px;
    flex: 1;
    min-width: 0;
}

.job-status {
    padding: var(--space-xs) var(--space);
    border-radius: var(--radius-full);
    font-size: 0.8rem;
    font-weight: 500;
    white-space: nowrap;
    flex-shrink: 0;
}

/* Status colors */
.status-uploaded {
    background: rgba(124, 58, 237, 0.2);
    color: #a78bfa;
    border: 1px solid rgba(124, 58, 237, 0.3);
}

.status-queued {
    background: rgba(217, 119, 6, 0.2);
    color: #fbbf24;
    border: 1px solid rgba(217, 119, 6, 0.3);
}

.status-processing {
    background: rgba(37, 99, 235, 0.2);
    color: var(--primary-light);
    border: 1px solid rgba(37, 99, 235, 0.3);
}

.status-completed {
    background: rgba(16, 185, 129, 0.2);
    color: #34d399;
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.status-error {
    background: rgba(239, 68, 68, 0.2);
    color: #f87171;
    border: 1px solid rgba(239, 68, 68, 0.3);
}

/* Progress bar */
.job-progress {
    margin-bottom: var(--space);
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: var(--border);
    border-radius: var(--radius-sm);
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--primary-light));
    transition: width 0.3s ease;
    border-radius: var(--radius-sm);
}

.progress-text {
    font-size: 0.8rem;
    color: var(--text-light);
    margin-top: var(--space-xs);
}

.job-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: var(--space);
    font-size: 0.9rem;
    color: var(--text-light);
    margin-bottom: var(--space);
}

.job-actions {
    display: flex;
    gap: var(--space-sm);
    margin-top: var(--space);
    flex-wrap: wrap;
    align-items: center;
}

/* ===========================================
   BOUTONS - CORRIG√âS
   =========================================== */
.btn {
    padding: var(--space-sm) var(--space);
    border: none;
    border-radius: var(--radius);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: var(--space-sm);
    white-space: nowrap;
    border: 1px solid transparent;
    line-height: 1.2;
    min-height: 40px;
    justify-content: center;
}

.btn img {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
}

.btn-primary {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
}

.btn-primary:hover {
    background: var(--primary-dark);
    transform: translateY(-1px);
    box-shadow: var(--shadow);
}

.btn-secondary {
    background: var(--surface-alt);
    color: var(--text);
    border-color: var(--border);
}

.btn-secondary:hover {
    background: var(--secondary);
    color: white;
    border-color: var(--secondary);
}

.btn-success {
    background: var(--success);
    color: white;
    border-color: var(--success);
}

.btn-success:hover {
    background: #059669;
    transform: translateY(-1px);
    box-shadow: var(--shadow);
}

.btn-danger {
    background: var(--error);
    color: white;
    border-color: var(--error);
}

.btn-danger:hover {
    background: #dc2626;
}

/* ===========================================
   STATUS INDICATOR - CORRIG√â
   =========================================== */
.status-indicator {
    position: fixed;
    top: var(--space-xl);
    right: var(--space-xl);
    background: var(--surface);
    padding: var(--space);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg);
    border-left: 4px solid var(--success);
    display: none;
    z-index: 1000;
    max-width: 400px;
    min-width: 300px;
    border: 1px solid var(--border);
}

.status-indicator.show {
    display: flex;
    align-items: flex-start;
    gap: var(--space);
    animation: slideInRight 0.3s ease;
}

.status-indicator.error {
    border-left-color: var(--error);
}

.status-indicator.warning {
    border-left-color: var(--warning);
}

.status-indicator.info {
    border-left-color: var(--info);
}

.status-icon {
    font-size: 1.2rem;
    margin-top: 2px;
    flex-shrink: 0;
}

.status-close {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    color: var(--text-muted);
    margin-left: auto;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.status-close:hover {
    color: var(--text);
}

/* ===========================================
   CONNECTION STATUS - CORRIG√â
   =========================================== */
.connection-status {
    position: fixed;
    bottom: var(--space-xl);
    right: var(--space-xl);
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius-full);
    font-size: 0.8rem;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    z-index: 1000;
    transition: var(--transition);
    white-space: nowrap;
    border: 1px solid transparent;
}

.connection-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: pulse 2s infinite;
    flex-shrink: 0;
}

.connection-status.connected {
    background: rgba(16, 185, 129, 0.2);
    color: #34d399;
    border-color: rgba(16, 185, 129, 0.3);
}

.connection-status.connected .connection-dot {
    background: #34d399;
}

.connection-status.disconnected {
    background: rgba(239, 68, 68, 0.2);
    color: #f87171;
    border-color: rgba(239, 68, 68, 0.3);
}

.connection-status.disconnected .connection-dot {
    background: #f87171;
}

/* ===========================================
   LOADING & ANIMATIONS - CORRIG√âES
   =========================================== */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 23, 42, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.loading-overlay.show {
    display: flex;
}

.loading-spinner {
    text-align: center;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top: 3px solid var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto var(--space);
}

.loading-text {
    color: var(--text-light);
    font-weight: 500;
}

/* Empty state */
.empty-state {
    text-align: center;
    padding: var(--space-2xl);
    color: var(--text-light);
}

.empty-state-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto var(--space);
    background: var(--border);
    border-radius: var(--radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
}

.empty-state-icon img {
    width: 32px;
    height: 32px;
    opacity: 0.5;
}

/* ===========================================
   ANIMATIONS
   =========================================== */
@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideDown {
    from {
        transform: translateY(-20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

/* ===========================================
   RESPONSIVE DESIGN - CORRIG√â
   =========================================== */
@media (max-width: 768px) {
    .container {
        padding: var(--space);
    }

    .header h1 {
        font-size: 2rem;
        flex-direction: row;
        gap: var(--space-sm);
        /* Permettre wrap seulement si absolument n√©cessaire */
        flex-wrap: wrap;
        justify-content: center;
    }

    .upload-section,
    .settings-panel,
    .jobs-section {
        padding: var(--space-lg);
        margin-bottom: var(--space-lg);
    }

    .upload-zone {
        padding: var(--space-lg);
        min-height: 160px;
    }

    .settings-grid {
        grid-template-columns: 1fr;
    }

    .job-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-sm);
    }

    .job-name {
        max-width: 100%;
    }

    .job-actions {
        width: 100%;
        justify-content: flex-start;
    }

    .jobs-controls {
        flex-direction: column;
        align-items: stretch;
    }

    .jobs-controls .btn {
        width: 100%;
        justify-content: center;
    }

    .status-indicator {
        top: var(--space);
        right: var(--space);
        left: var(--space);
        max-width: none;
        min-width: 0;
    }

    .connection-status {
        bottom: var(--space);
        right: var(--space);
    }
}

@media (max-width: 480px) {
    .container {
        padding: var(--space-sm);
    }

    .header h1 {
        font-size: 1.75rem;
        flex-direction: column;
        gap: var(--space-sm);
    }

    .upload-section,
    .settings-panel,
    .jobs-section {
        padding: var(--space);
    }

    .job-info {
        grid-template-columns: 1fr;
    }

    .btn {
        font-size: 0.8rem;
        padding: var(--space-xs) var(--space-sm);
    }
}

/* ===========================================
   PRINT STYLES
   =========================================== */
@media print {
    .status-indicator,
    .connection-status,
    .loading-overlay {
        display: none !important;
    }
}

/* Fix pour le titre avec emojis */
.header h1 .title-text {
    display: inline-block;
    white-space: nowrap;
    margin-left: var(--space-sm);
    vertical-align: middle;
}

.header h1 .logo {
    display: inline-block;
    vertical-align: middle;
    line-height: 1;
}

/* Fix pour les boutons avec ic√¥nes et texte */
.btn {
    /* Forcer layout inline-flex stable */
    display: inline-flex !important;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    vertical-align: top;
    box-sizing: border-box;
}

.btn span {
    display: inline-block;
    line-height: 1.2;
    vertical-align: middle;
}

/* Fix sp√©cifique pour jobs-controls */
.jobs-controls {
    display: flex;
    gap: var(--space);
    margin-bottom: var(--space-lg);
    flex-wrap: wrap;
    align-items: flex-start; /* √âvite alignement center qui cause chevauchements */
}

.jobs-controls .btn {
    min-width: 140px; /* Largeur minimum pour √©viter compression */
    flex-shrink: 0;
}

/* Fix pour les titres de section */
.jobs-title,
.settings-title {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    margin-bottom: var(--space);
    line-height: 1.3;
    overflow: visible;
}

.jobs-title span,
.settings-title span {
    display: inline-block;
    vertical-align: middle;
}

/* Fix pour job-item layout */
.job-item {
    position: relative;
    isolation: isolate; /* Cr√©er un nouveau contexte de stacking */
}

.job-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; /* Alignement en haut pour √©viter chevauchements */
    margin-bottom: var(--space);
    gap: var(--space);
    flex-wrap: wrap;
}

.job-name {
    flex: 1 1 auto;
    min-width: 0; /* Permet shrinking */
    word-break: break-word;
    overflow-wrap: break-word;
    max-width: none; /* Retire limitation pr√©c√©dente */
}

.job-status {
    flex: 0 0 auto;
    margin-left: auto;
}

/* Fix pour upload zone */
.upload-zone {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    position: relative;
    isolation: isolate;
}

.upload-icon,
.upload-text,
.upload-subtext {
    z-index: 1;
    position: relative;
}

/* Fix pour empty state */
.empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    gap: var(--space);
}

/* Fix g√©n√©ral pour √©viter text overflow */
* {
    word-wrap: break-word;
    overflow-wrap: break-word;
}

/* Fix pour √©l√©ments flex qui d√©bordent */
.flex-container {
    min-width: 0; /* Permet aux flex items de shrink */
}

/* Fix pour status indicator */
.status-indicator {
    max-width: calc(100vw - 2 * var(--space-xl));
    word-break: break-word;
}

/* Fix responsive suppl√©mentaire */
@media (max-width: 600px) {
    .job-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-sm);
    }
    
    .job-status {
        align-self: flex-start;
        margin-left: 0;
    }
    
    .jobs-controls {
        flex-direction: column;
        align-items: stretch;
    }
    
    .jobs-controls .btn {
        width: 100%;
        min-width: auto;
    }
    
    .header h1 {
        flex-direction: column;
        gap: var(--space-sm);
        align-items: center;
    }
    
    .header h1 .title-text {
        margin-left: 0;
    }
}


================================================
File: frontend/js/api.js
================================================
// js/api.js
// Client API REST pour File Optimizer

/**
 * Client API REST avec retry automatique et cache intelligent
 */
class ApiClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
        this.logger = Utils.createLogger('ApiClient');
        this.defaultTimeout = 30000; // 30 secondes
    }

    /**
     * Requ√™te HTTP g√©n√©rique avec retry automatique
     */
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const config = {
            timeout: this.defaultTimeout,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        };

        // V√©rifier le cache pour GET
        if (options.method === 'GET' || !options.method) {
            const cached = this.getFromCache(url);
            if (cached) {
                return cached;
            }
        }

        return Utils.retry(async () => {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), config.timeout);

            try {
                const response = await fetch(url, {
                    ...config,
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                
                // Mettre en cache les GET r√©ussis
                if (!options.method || options.method === 'GET') {
                    this.setCache(url, data);
                }

                return data;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Timeout de requ√™te');
                }
                throw error;
            }
        }, 3, 1000);
    }

    /**
     * Upload de fichier avec progression
     */
    async uploadFile(file, settings = {}) {
        try {
            this.logger.info(`Upload fichier: ${file.name} (${Utils.formatFileSize(file.size)})`);
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('settings', JSON.stringify(settings));

            const response = await fetch(`${this.baseUrl}/upload`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}`);
            }

            const result = await response.json();
            this.logger.info(`Upload r√©ussi: ${result.jobId}`);
            
            return result;
        } catch (error) {
            this.logger.error('Erreur upload:', error);
            throw error;
        }
    }

    /**
     * R√©cup√©rer les jobs avec pagination
     */
    async getJobs(params = {}) {
        const query = new URLSearchParams({
            page: 1,
            limit: 20,
            sortBy: 'createdAt',
            sortOrder: 'desc',
            ...params
        });

        return this.request(`/status?${query}`);
    }

    /**
     * R√©cup√©rer un job sp√©cifique
     */
    async getJob(jobId) {
        return this.request(`/status/${jobId}`);
    }

    /**
     * Supprimer un job
     */
    async deleteJob(jobId) {
        return this.request(`/status/${jobId}`, { method: 'DELETE' });
    }

    /**
     * Relancer un job en erreur
     */
    async retryJob(jobId) {
        return this.request(`/status/${jobId}/retry`, { method: 'POST' });
    }

    /**
     * Annuler un job
     */
    async cancelJob(jobId) {
        return this.request(`/process/${jobId}/cancel`, { method: 'POST' });
    }

    /**
     * D√©marrer le traitement d'un job
     */
    async startProcessing(jobId, settings = {}) {
        return this.request(`/process/${jobId}`, {
            method: 'POST',
            body: JSON.stringify({ settings })
        });
    }

    /**
     * R√©cup√©rer les informations d'upload
     */
    async getUploadInfo() {
        return this.request('/upload/info');
    }

    /**
     * R√©cup√©rer les statistiques
     */
    async getStats() {
        return this.request('/status/stats/global');
    }

    /**
     * Health check
     */
    async healthCheck() {
        return this.request('/health');
    }

    /**
     * Gestion du cache
     */
    getFromCache(key) {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            this.logger.debug(`Cache hit: ${key}`);
            return cached.data;
        }
        if (cached) {
            this.cache.delete(key);
        }
        return null;
    }

    setCache(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }

    clearCache() {
        this.cache.clear();
        this.logger.info('Cache vid√©');
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ApiClient;
} else {
    window.ApiClient = ApiClient;
}


================================================
File: frontend/js/app.js
================================================
// js/app.js
// Application principale File Optimizer

/**
 * Classe principale de l'application File Optimizer
 */
class FileOptimizer {
    constructor() {
        this.jobs = new Map();
        this.socket = null;
        this.api = null;
        this.ui = null;
        this.websocket = null;
        
        this.config = {
            maxFileSize: 5 * 1024 * 1024 * 1024, // 5GB
            supportedTypes: ['image', 'video', 'audio', 'document'],
            apiEndpoint: window.location.origin + '/api'
        };
        
        this.init();
    }

    /**
     * Initialiser l'application
     */
    async init() {
        try {
            console.log('üöÄ Initialisation File Optimizer');
            
            // Initialiser les modules
            this.api = new ApiClient(this.config.apiEndpoint);
            this.ui = new UIManager();
            this.websocket = new WebSocketManager(this.config.apiEndpoint);
            
            // Configuration des √©v√©nements
            this.setupEventListeners();
            this.setupWebSocketEvents();
            
            // Charger les donn√©es existantes
            await this.loadExistingJobs();
            await this.loadUploadInfo();
            
            // Marquer comme pr√™t
            this.ui.setLoadingState(false);
            this.ui.showStatus('Application pr√™te', 'success');
            
            console.log('‚úÖ File Optimizer initialis√©');
            
        } catch (error) {
            console.error('‚ùå Erreur initialisation:', error);
            this.ui.showStatus('Erreur initialisation: ' + error.message, 'error');
        }
    }

    /**
     * Configuration des √©v√©nements DOM
     */
    setupEventListeners() {
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const refreshJobs = document.getElementById('refreshJobs');
        const clearCompleted = document.getElementById('clearCompleted');

        // Upload zone drag & drop
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', this.handleDragOver.bind(this));
        uploadZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
        uploadZone.addEventListener('drop', this.handleDrop.bind(this));

        // File input change
        fileInput.addEventListener('change', (e) => {
            this.handleFiles(Array.from(e.target.files));
        });

        // Boutons de contr√¥le
        if (refreshJobs) {
            refreshJobs.addEventListener('click', () => this.loadExistingJobs());
        }
        
        if (clearCompleted) {
            clearCompleted.addEventListener('click', () => this.clearCompletedJobs());
        }

        // Fermeture notifications
        document.addEventListener('click', (e) => {
            if (e.target.id === 'statusClose') {
                this.ui.hideStatus();
            }
        });

        // Raccourcis clavier
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'u': // Ctrl+U pour upload
                        e.preventDefault();
                        fileInput.click();
                        break;
                    case 'r': // Ctrl+R pour refresh
                        if (e.shiftKey) {
                            e.preventDefault();
                            this.loadExistingJobs();
                        }
                        break;
                }
            }
        });
    }

    /**
     * Configuration des √©v√©nements WebSocket
     */
    setupWebSocketEvents() {
        this.websocket.on('connect', () => {
            this.ui.setConnectionStatus(true);
            console.log('üîå WebSocket connect√©');
        });

        this.websocket.on('disconnect', () => {
            this.ui.setConnectionStatus(false);
            console.log('üîå WebSocket d√©connect√©');
        });

        this.websocket.on('job-progress', (data) => {
            this.updateJobProgress(data.jobId, data.progress);
        });

        this.websocket.on('job-completed', (data) => {
            this.updateJobStatus(data.jobId, 'completed', data);
        });

        this.websocket.on('job-error', (data) => {
            this.updateJobStatus(data.jobId, 'error', { error: data.error });
        });

        this.websocket.on('job-queued', (data) => {
            this.updateJobStatus(data.jobId, 'queued');
        });
    }

    /**
     * Gestion drag & drop
     */
    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        this.ui.setUploadZoneState('dragover');
    }

    handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        this.ui.setUploadZoneState('normal');
    }

    handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.ui.setUploadZoneState('normal');
        
        const files = Array.from(e.dataTransfer.files);
        this.handleFiles(files);
    }

    /**
     * Traitement des fichiers s√©lectionn√©s
     */
    async handleFiles(files) {
        if (files.length === 0) return;

        console.log(`üìÅ ${files.length} fichier(s) s√©lectionn√©(s)`);
        
        // Valider les fichiers
        const validFiles = files.filter(file => this.validateFile(file));
        
        if (validFiles.length !== files.length) {
            this.ui.showStatus(
                `${files.length - validFiles.length} fichier(s) rejet√©(s) (type non support√© ou trop volumineux)`,
                'warning'
            );
        }

        // Traiter les fichiers valides
        for (const file of validFiles) {
            try {
                await this.uploadFile(file);
            } catch (error) {
                console.error(`Erreur upload ${file.name}:`, error);
            }
        }
    }

    /**
     * Validation d'un fichier
     */
    validateFile(file) {
        // V√©rifier la taille
        if (file.size > this.config.maxFileSize) {
            console.warn(`Fichier trop volumineux: ${file.name} (${Utils.formatFileSize(file.size)})`);
            return false;
        }

        // V√©rifier le type
        const fileType = Utils.getFileType(file.name);
        if (!this.config.supportedTypes.includes(fileType)) {
            console.warn(`Type non support√©: ${file.name} (${fileType})`);
            return false;
        }

        return true;
    }

    /**
     * Upload d'un fichier
     */
    async uploadFile(file) {
        try {
            this.ui.showStatus(`Upload de ${file.name}...`, 'info');

            // D√©terminer les param√®tres par d√©faut
            const fileType = Utils.getFileType(file.name);
            const settings = this.getDefaultSettings(fileType);

            // Cr√©er le job temporaire
            const tempJob = {
                id: 'temp-' + Date.now(),
                name: file.name,
                size: file.size,
                type: fileType,
                status: 'uploading',
                progress: 0,
                createdAt: new Date().toISOString()
            };

            this.addJob(tempJob);

            // Upload via API
            const result = await this.api.uploadFile(file, settings);

            if (result.success) {
                // Remplacer le job temporaire par le vrai
                this.jobs.delete(tempJob.id);
                
                const job = {
                    id: result.jobId,
                    name: file.name,
                    size: file.size,
                    type: fileType,
                    status: 'uploaded',
                    progress: 0,
                    settings: settings,
                    createdAt: new Date().toISOString(),
                    estimatedTime: result.estimatedTime
                };

                this.addJob(job);
                this.websocket.joinJobRoom(result.jobId);
                
                this.ui.showStatus(`${file.name} upload√© avec succ√®s!`, 'success');
                
            } else {
                this.jobs.delete(tempJob.id);
                throw new Error(result.error || 'Erreur upload');
            }

        } catch (error) {
            console.error('Erreur upload:', error);
            this.ui.showStatus(`Erreur upload ${file.name}: ${error.message}`, 'error');
        }
    }

    /**
     * Obtenir les param√®tres par d√©faut selon le type
     */
    getDefaultSettings(type) {
        const defaultSettings = {
            image: {
                quality: 80,
                maxWidth: 1920,
                maxHeight: 1080,
                format: 'auto',
                removeMetadata: true
            },
            video: {
                codec: 'h264',
                crf: 23,
                preset: 'medium',
                maxBitrate: '2M'
            },
            audio: {
                codec: 'aac',
                bitrate: '128k',
                sampleRate: 44100
            },
            document: {
                compress: true,
                removeMetadata: true
            }
        };

        return defaultSettings[type] || {};
    }

    /**
     * Ajouter un job √† la liste
     */
    addJob(job) {
        this.jobs.set(job.id, job);
        this.ui.renderJobs(Array.from(this.jobs.values()));
    }

    /**
     * Mettre √† jour la progression d'un job
     */
    updateJobProgress(jobId, progress) {
        const job = this.jobs.get(jobId);
        if (job) {
            job.progress = progress;
            job.status = 'processing';
            this.ui.renderJobs(Array.from(this.jobs.values()));
            
            console.log(`üìä Job ${jobId}: ${progress}%`);
        }
    }

    /**
     * Mettre √† jour le statut d'un job
     */
    updateJobStatus(jobId, status, data = {}) {
        const job = this.jobs.get(jobId);
        if (job) {
            job.status = status;
            Object.assign(job, data);
            this.ui.renderJobs(Array.from(this.jobs.values()));

            if (status === 'completed') {
                this.ui.showStatus(`${job.name} trait√© avec succ√®s!`, 'success');
                console.log(`‚úÖ Job ${jobId} termin√©`);
            } else if (status === 'error') {
                this.ui.showStatus(`Erreur traitement ${job.name}: ${data.error}`, 'error');
                console.error(`‚ùå Job ${jobId} √©chou√©:`, data.error);
            }
        }
    }

    /**
     * Supprimer un job
     */
    async deleteJob(jobId) {
        try {
            const job = this.jobs.get(jobId);
            if (!job) return;

            const confirmed = confirm(`Supprimer ${job.name} ?`);
            if (!confirmed) return;

            this.ui.setLoadingState(true);
            
            const result = await this.api.deleteJob(jobId);
            
            if (result.success) {
                this.jobs.delete(jobId);
                this.ui.renderJobs(Array.from(this.jobs.values()));
                this.ui.showStatus('Fichier supprim√©', 'success');
            } else {
                throw new Error(result.error || 'Erreur suppression');
            }
        } catch (error) {
            console.error('Erreur suppression:', error);
            this.ui.showStatus('Erreur suppression: ' + error.message, 'error');
        } finally {
            this.ui.setLoadingState(false);
        }
    }

    /**
     * Retenter un job en erreur
     */
    async retryJob(jobId) {
        try {
            this.ui.setLoadingState(true);
            
            const result = await this.api.retryJob(jobId);
            
            if (result.success) {
                this.updateJobStatus(jobId, 'queued');
                this.websocket.joinJobRoom(jobId);
                this.ui.showStatus('Job relanc√©', 'success');
            } else {
                throw new Error(result.error || 'Erreur retry');
            }
        } catch (error) {
            console.error('Erreur retry:', error);
            this.ui.showStatus('Erreur retry: ' + error.message, 'error');
        } finally {
            this.ui.setLoadingState(false);
        }
    }

    /**
     * Charger les jobs existants
     */
    async loadExistingJobs() {
        try {
            console.log('üîÑ Chargement des jobs existants...');
            
            const result = await this.api.getJobs({ limit: 50 });
            
            if (result.success && result.jobs) {
                this.jobs.clear();
                
                result.jobs.forEach(apiJob => {
                    const job = {
                        id: apiJob.id,
                        name: apiJob.originalName,
                        size: apiJob.size,
                        type: apiJob.type,
                        status: apiJob.status,
                        progress: apiJob.progress || 0,
                        createdAt: apiJob.createdAt,
                        compressedSize: apiJob.compressedSize,
                        compressionRatio: apiJob.compressionRatio,
                        error: apiJob.error
                    };
                    
                    this.jobs.set(job.id, job);
                    
                    // Rejoindre les rooms pour les jobs actifs
                    if (['queued', 'processing'].includes(job.status)) {
                        this.websocket.joinJobRoom(job.id);
                    }
                });
                
                this.ui.renderJobs(Array.from(this.jobs.values()));
                console.log(`üìã ${this.jobs.size} job(s) charg√©(s)`);
            }
        } catch (error) {
            console.error('Erreur chargement jobs:', error);
            this.ui.showStatus('Erreur chargement jobs', 'error');
        }
    }

    /**
     * Charger les informations d'upload
     */
    async loadUploadInfo() {
        try {
            const info = await this.api.getUploadInfo();
            if (info.success) {
                this.config.maxFileSize = info.limits.maxFileSize;
                console.log('üìä Limites upload:', info.limits);
            }
        } catch (error) {
            console.warn('Impossible de charger les infos upload:', error);
        }
    }

    /**
     * Nettoyer les jobs termin√©s
     */
    async clearCompletedJobs() {
        try {
            const completedJobs = Array.from(this.jobs.values())
                .filter(job => job.status === 'completed');
            
            if (completedJobs.length === 0) {
                this.ui.showStatus('Aucun job termin√© √† nettoyer', 'info');
                return;
            }
            
            const confirmed = confirm(`Supprimer ${completedJobs.length} job(s) termin√©(s) ?`);
            if (!confirmed) return;
            
            this.ui.setLoadingState(true);
            
            let successCount = 0;
            for (const job of completedJobs) {
                try {
                    const result = await this.api.deleteJob(job.id);
                    if (result.success) {
                        this.jobs.delete(job.id);
                        successCount++;
                    }
                } catch (error) {
                    console.error(`Erreur suppression ${job.id}:`, error);
                }
            }
            
            this.ui.renderJobs(Array.from(this.jobs.values()));
            this.ui.showStatus(`${successCount} job(s) supprim√©(s)`, 'success');
            
        } catch (error) {
            console.error('Erreur nettoyage:', error);
            this.ui.showStatus('Erreur nettoyage: ' + error.message, 'error');
        } finally {
            this.ui.setLoadingState(false);
        }
    }

    /**
     * T√©l√©charger un fichier trait√©
     */
    downloadFile(jobId) {
        const job = this.jobs.get(jobId);
        if (!job || job.status !== 'completed') {
            this.ui.showStatus('Fichier non disponible pour t√©l√©chargement', 'warning');
            return;
        }

        // Cr√©er un lien de t√©l√©chargement
        const downloadUrl = `${this.config.apiEndpoint}/download/${jobId}`;
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = job.name;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.ui.showStatus(`T√©l√©chargement de ${job.name} d√©marr√©`, 'success');
    }

    /**
     * Obtenir les statistiques
     */
    getStats() {
        const jobs = Array.from(this.jobs.values());
        
        return {
            total: jobs.length,
            completed: jobs.filter(j => j.status === 'completed').length,
            processing: jobs.filter(j => j.status === 'processing').length,
            error: jobs.filter(j => j.status === 'error').length,
            totalSize: jobs.reduce((sum, j) => sum + j.size, 0),
            totalSaved: jobs
                .filter(j => j.compressedSize)
                .reduce((sum, j) => sum + (j.size - j.compressedSize), 0)
        };
    }

    /**
     * Nettoyer les ressources
     */
    destroy() {
        if (this.websocket) {
            this.websocket.disconnect();
        }
        this.jobs.clear();
        console.log('üßπ File Optimizer nettoy√©');
    }
}

// Fonctions globales pour l'interface
window.fileOptimizer = null;

window.deleteJob = (jobId) => {
    if (window.fileOptimizer) {
        window.fileOptimizer.deleteJob(jobId);
    }
};

window.retryJob = (jobId) => {
    if (window.fileOptimizer) {
        window.fileOptimizer.retryJob(jobId);
    }
};

window.downloadFile = (jobId) => {
    if (window.fileOptimizer) {
        window.fileOptimizer.downloadFile(jobId);
    }
};

// Initialisation au chargement de la page
document.addEventListener('DOMContentLoaded', () => {
    console.log('üéØ File Optimizer Frontend v2.0.0');
    window.fileOptimizer = new FileOptimizer();
});

// Nettoyage √† la fermeture
window.addEventListener('beforeunload', () => {
    if (window.fileOptimizer) {
        window.fileOptimizer.destroy();
    }
});


================================================
File: frontend/js/ui.js
================================================
// js/ui.js
// Gestionnaire de l'interface utilisateur

/**
 * Gestionnaire de l'interface utilisateur
 */
class UIManager {
    constructor() {
        this.elements = this.getElements();
        this.logger = Utils.createLogger('UIManager');
        this.setupUI();
    }

    /**
     * R√©cup√©rer les √©l√©ments DOM
     */
    getElements() {
        return {
            uploadZone: document.getElementById('uploadZone'),
            fileInput: document.getElementById('fileInput'),
            settingsPanel: document.getElementById('settingsPanel'),
            settingsGrid: document.getElementById('settingsGrid'),
            jobsList: document.getElementById('jobsList'),
            statusIndicator: document.getElementById('statusIndicator'),
            statusMessage: document.getElementById('statusMessage'),
            statusIcon: document.getElementById('statusIcon'),
            statusClose: document.getElementById('statusClose'),
            connectionStatus: document.getElementById('connectionStatus'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            refreshJobs: document.getElementById('refreshJobs'),
            clearCompleted: document.getElementById('clearCompleted')
        };
    }

    /**
     * Configuration initiale de l'UI
     */
    setupUI() {
        this.logger.info('Initialisation UI Manager');
        
        // Configuration des tooltips
        this.setupTooltips();
        
        // Configuration des animations
        this.setupAnimations();
        
        // Configuration des raccourcis
        this.setupKeyboardShortcuts();
        
        // √âtat initial
        this.setLoadingState(false);
        this.setConnectionStatus(false);
    }

    /**
     * Afficher un message de statut
     */
    showStatus(message, type = 'info', duration = 3000) {
        const { statusIndicator, statusMessage, statusIcon } = this.elements;
        
        if (!statusIndicator || !statusMessage || !statusIcon) {
            console.warn('√âl√©ments de statut non trouv√©s');
            return;
        }

        // Ic√¥nes selon le type
        const icons = {
            success: '‚úÖ',
            error: '‚ùå',
            warning: '‚ö†Ô∏è',
            info: '‚ÑπÔ∏è'
        };

        statusIcon.textContent = icons[type] || icons.info;
        statusMessage.textContent = message;
        
        // Classes CSS
        statusIndicator.className = `status-indicator show ${type}`;
        
        // Animation d'entr√©e
        statusIndicator.style.transform = 'translateX(100%)';
        statusIndicator.style.opacity = '0';
        
        requestAnimationFrame(() => {
            statusIndicator.style.transform = 'translateX(0)';
            statusIndicator.style.opacity = '1';
        });

        // Auto-masquage
        if (duration > 0) {
            setTimeout(() => {
                this.hideStatus();
            }, duration);
        }

        this.logger.debug(`Status affich√©: ${type} - ${message}`);
    }

    /**
     * Masquer le message de statut
     */
    hideStatus() {
        const { statusIndicator } = this.elements;
        
        if (statusIndicator) {
            statusIndicator.style.transform = 'translateX(100%)';
            statusIndicator.style.opacity = '0';
            
            setTimeout(() => {
                statusIndicator.classList.remove('show');
            }, 300);
        }
    }

    /**
     * D√©finir l'√©tat de connexion
     */
    setConnectionStatus(connected) {
        const { connectionStatus } = this.elements;
        
        if (!connectionStatus) return;

        if (connected) {
            connectionStatus.className = 'connection-status connected';
            connectionStatus.innerHTML = '<div class="connection-dot"></div><span>Connect√©</span>';
        } else {
            connectionStatus.className = 'connection-status disconnected';
            connectionStatus.innerHTML = '<div class="connection-dot"></div><span>D√©connect√©</span>';
        }
    }

    /**
     * D√©finir l'√©tat de chargement global
     */
    setLoadingState(loading) {
        const { loadingOverlay } = this.elements;
        
        if (!loadingOverlay) return;

        if (loading) {
            loadingOverlay.classList.add('show');
        } else {
            loadingOverlay.classList.remove('show');
        }
    }

    /**
     * D√©finir l'√©tat de la zone d'upload
     */
    setUploadZoneState(state) {
        const { uploadZone } = this.elements;
        
        if (!uploadZone) return;

        uploadZone.classList.remove('dragover', 'uploading');
        
        if (state === 'dragover') {
            uploadZone.classList.add('dragover');
        } else if (state === 'uploading') {
            uploadZone.classList.add('uploading');
        }
    }

    /**
     * Rendre la liste des jobs
     */
    renderJobs(jobs) {
        const { jobsList } = this.elements;
        
        if (!jobsList) {
            this.logger.error('Element jobsList non trouv√©');
            return;
        }

        if (!jobs || jobs.length === 0) {
            jobsList.innerHTML = this.renderEmptyState();
            return;
        }

        // Trier par date de cr√©ation (plus r√©cent en premier)
        const sortedJobs = jobs.sort((a, b) => 
            new Date(b.createdAt) - new Date(a.createdAt)
        );

        jobsList.innerHTML = sortedJobs.map(job => this.renderJob(job)).join('');
        
        // Animer les nouveaux √©l√©ments
        this.animateJobItems();
    }

    /**
     * Rendre un job individuel
     */
    renderJob(job) {
        const statusClass = `status-${job.status}`;
        const statusText = this.getStatusText(job.status);
        const progressPercent = Math.max(0, Math.min(100, job.progress || 0));
        const showProgress = ['processing', 'queued'].includes(job.status);
        
        // Informations de taille et compression
        const sizeInfo = this.renderSizeInfo(job);
        
        // Actions disponibles
        const actions = this.renderJobActions(job);
        
        // Temps relatif
        const timeAgo = Utils.formatRelativeTime(job.createdAt);
        
        // Ic√¥ne du type de fichier
        const fileIcon = Utils.getFileIcon(job.type);

        return `
            <div class="job-item" data-job-id="${job.id}" data-status="${job.status}">
                <div class="job-header">
                    <div class="job-name" title="${Utils.escapeHtml(job.name)}">
                        ${fileIcon} ${Utils.escapeHtml(job.name)}
                    </div>
                    <div class="job-status ${statusClass}">${statusText}</div>
                </div>
                
                ${showProgress ? `
                    <div class="job-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progressPercent}%"></div>
                        </div>
                        <div class="progress-text">
                            ${progressPercent}% compl√©t√©
                            ${job.estimatedTime && job.status === 'processing' ? 
                                `‚Ä¢ ETA: ${Utils.formatDuration(job.estimatedTime * 1000)}` : ''}
                        </div>
                    </div>
                ` : ''}

                <div class="job-info">
                    <div><strong>Type:</strong> ${job.type}</div>
                    <div><strong>Cr√©√©:</strong> ${timeAgo}</div>
                    ${sizeInfo}
                    ${job.error ? `<div class="job-error"><strong>Erreur:</strong> ${Utils.escapeHtml(job.error)}</div>` : ''}
                </div>

                ${actions ? `<div class="job-actions">${actions}</div>` : ''}
            </div>
        `;
    }

    /**
     * Rendre les informations de taille
     */
    renderSizeInfo(job) {
        let sizeInfo = `<div><strong>Taille:</strong> ${Utils.formatFileSize(job.size)}</div>`;
        
        if (job.compressedSize && job.status === 'completed') {
            const ratio = Utils.calculateCompressionRatio(job.size, job.compressedSize);
            const saved = job.size - job.compressedSize;
            
            sizeInfo += `
                <div><strong>Compress√©:</strong> ${Utils.formatFileSize(job.compressedSize)}</div>
                <div><strong>√âconomis√©:</strong> ${Utils.formatFileSize(saved)} (${ratio}%)</div>
            `;
        }
        
        return sizeInfo;
    }

    /**
     * Rendre les actions disponibles pour un job
     */
    renderJobActions(job) {
        const actions = [];

        switch (job.status) {
            case 'completed':
                actions.push(`
                    <button class="btn btn-success" onclick="downloadFile('${job.id}')" title="T√©l√©charger le fichier optimis√©">
                        üì• T√©l√©charger
                    </button>
                `);
                actions.push(`
                    <button class="btn btn-secondary" onclick="deleteJob('${job.id}')" title="Supprimer ce job">
                        üóëÔ∏è Supprimer
                    </button>
                `);
                break;

            case 'error':
                actions.push(`
                    <button class="btn btn-primary" onclick="retryJob('${job.id}')" title="Relancer le traitement">
                        üîÑ Relancer
                    </button>
                `);
                actions.push(`
                    <button class="btn btn-secondary" onclick="deleteJob('${job.id}')" title="Supprimer ce job">
                        üóëÔ∏è Supprimer
                    </button>
                `);
                break;

            case 'processing':
            case 'queued':
                actions.push(`
                    <button class="btn btn-secondary" onclick="cancelJob('${job.id}')" title="Annuler le traitement">
                        ‚èπÔ∏è Annuler
                    </button>
                `);
                break;

            case 'uploaded':
                actions.push(`
                    <button class="btn btn-primary" onclick="startProcessing('${job.id}')" title="D√©marrer le traitement">
                        ‚ñ∂Ô∏è Traiter
                    </button>
                `);
                actions.push(`
                    <button class="btn btn-secondary" onclick="deleteJob('${job.id}')" title="Supprimer ce job">
                        üóëÔ∏è Supprimer
                    </button>
                `);
                break;
        }

        return actions.join('');
    }

    /**
     * Rendre l'√©tat vide
     */
    renderEmptyState() {
        return `
            <div class="empty-state">
                <div class="empty-state-icon">
                    üìÅ
                </div>
                <div>Aucun fichier en cours de traitement</div>
                <div style="font-size: 0.9rem; margin-top: 0.5rem; color: var(--text-muted);">
                    Glissez des fichiers dans la zone d'upload pour commencer
                </div>
            </div>
        `;
    }

    /**
     * Obtenir le texte de statut
     */
    getStatusText(status) {
        const statusTexts = {
            uploaded: 'Upload√©',
            queued: 'En attente',
            processing: 'Traitement',
            completed: 'Termin√©',
            error: 'Erreur',
            cancelled: 'Annul√©',
            paused: 'En pause'
        };
        
        return statusTexts[status] || status;
    }

    /**
     * Animer les √©l√©ments de job
     */
    animateJobItems() {
        const jobItems = document.querySelectorAll('.job-item');
        
        jobItems.forEach((item, index) => {
            item.style.opacity = '0';
            item.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                item.style.transition = 'all 0.3s ease';
                item.style.opacity = '1';
                item.style.transform = 'translateY(0)';
            }, index * 50);
        });
    }

    /**
     * Mettre √† jour un job sp√©cifique dans la liste
     */
    updateJobInList(jobId, updates) {
        const jobElement = document.querySelector(`[data-job-id="${jobId}"]`);
        
        if (!jobElement) return;

        // Mettre √† jour le statut
        if (updates.status) {
            jobElement.dataset.status = updates.status;
            const statusElement = jobElement.querySelector('.job-status');
            if (statusElement) {
                statusElement.textContent = this.getStatusText(updates.status);
                statusElement.className = `job-status status-${updates.status}`;
            }
        }

        // Mettre √† jour la progression
        if (updates.progress !== undefined) {
            const progressFill = jobElement.querySelector('.progress-fill');
            const progressText = jobElement.querySelector('.progress-text');
            
            if (progressFill) {
                progressFill.style.width = `${updates.progress}%`;
            }
            if (progressText) {
                progressText.textContent = `${updates.progress}% compl√©t√©`;
            }
        }

        // Animation de mise √† jour
        jobElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
            jobElement.style.transform = 'scale(1)';
        }, 200);
    }

    /**
     * Configuration des tooltips
     */
    setupTooltips() {
        // Impl√©mentation simple de tooltips
        document.addEventListener('mouseover', (e) => {
            if (e.target.hasAttribute('title')) {
                this.showTooltip(e.target, e.target.getAttribute('title'));
            }
        });

        document.addEventListener('mouseout', (e) => {
            if (e.target.hasAttribute('title')) {
                this.hideTooltip();
            }
        });
    }

    /**
     * Afficher un tooltip
     */
    showTooltip(element, text) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.textContent = text;
        tooltip.style.cssText = `
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
        `;
        document.body.appendChild(tooltip);

        const rect = element.getBoundingClientRect();
        tooltip.style.left = rect.left + rect.width / 2 - tooltip.offsetWidth / 2 + 'px';
        tooltip.style.top = rect.bottom + 8 + 'px';
    }

    /**
     * Masquer le tooltip
     */
    hideTooltip() {
        const tooltip = document.querySelector('.tooltip');
        if (tooltip) {
            tooltip.remove();
        }
    }

    /**
     * Configuration des animations
     */
    setupAnimations() {
        // Observer pour les animations d'apparition
        if ('IntersectionObserver' in window) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                    }
                });
            });

            // Observer les √©l√©ments avec classe animate-on-scroll
            document.querySelectorAll('.animate-on-scroll').forEach(el => {
                observer.observe(el);
            });
        }
    }

    /**
     * Configuration des raccourcis clavier
     */
    setupKeyboardShortcuts() {
        // Les raccourcis sont d√©j√† g√©r√©s dans app.js
        // Ici on peut ajouter des indicateurs visuels
    }

    /**
     * Nettoyer les ressources UI
     */
    destroy() {
        // Nettoyer les √©v√©nements et timers
        this.hideStatus();
        this.hideTooltip();
        this.logger.info('UIManager d√©truit');
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = UIManager;
} else {
    window.UIManager = UIManager;
}


================================================
File: frontend/js/utils.js
================================================
// js/utils.js
// Utilitaires g√©n√©raux pour File Optimizer

/**
 * Classe d'utilitaires g√©n√©raux
 */
class Utils {
    /**
     * Formater la taille d'un fichier
     */
    static formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    /**
     * D√©terminer le type d'un fichier bas√© sur son extension
     */
    static getFileType(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        
        const typeMap = {
            // Images
            jpg: 'image', jpeg: 'image', png: 'image', webp: 'image',
            avif: 'image', heic: 'image', tiff: 'image', bmp: 'image',
            
            // Vid√©os
            mp4: 'video', avi: 'video', mkv: 'video', webm: 'video',
            mov: 'video', flv: 'video', m4v: 'video',
            
            // Audio
            mp3: 'audio', flac: 'audio', wav: 'audio', aac: 'audio',
            ogg: 'audio', m4a: 'audio', wma: 'audio',
            
            // Documents
            pdf: 'document'
        };

        return typeMap[ext] || 'unknown';
    }

    /**
     * Obtenir l'ic√¥ne pour un type de fichier
     */
    static getFileIcon(type) {
        const icons = {
            image: 'üñºÔ∏è',
            video: 'üé¨',
            audio: 'üéµ',
            document: 'üìÑ',
            unknown: 'üìé'
        };
        
        return icons[type] || icons.unknown;
    }

    /**
     * Formater une dur√©e en millisecondes
     */
    static formatDuration(ms) {
        if (ms < 1000) return '< 1s';
        
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
            return `${days}j ${hours % 24}h ${minutes % 60}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        } else {
            return `${seconds}s`;
        }
    }

    /**
     * Formater une date relative (il y a X temps)
     */
    static formatRelativeTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);

        if (diffSeconds < 60) {
            return '√Ä l\'instant';
        } else if (diffMinutes < 60) {
            return `Il y a ${diffMinutes}min`;
        } else if (diffHours < 24) {
            return `Il y a ${diffHours}h`;
        } else if (diffDays < 7) {
            return `Il y a ${diffDays}j`;
        } else {
            return date.toLocaleDateString('fr-FR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            });
        }
    }

    /**
     * Debounce une fonction
     */
    static debounce(func, wait, immediate = false) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                timeout = null;
                if (!immediate) func(...args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func(...args);
        };
    }

    /**
     * Throttle une fonction
     */
    static throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    /**
     * G√©n√©rer un ID unique
     */
    static generateId() {
        return 'id-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
    }

    /**
     * Nettoyer une cha√Æne pour l'HTML
     */
    static escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Copier du texte dans le presse-papier
     */
    static async copyToClipboard(text) {
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (error) {
            // Fallback pour les navigateurs plus anciens
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            return successful;
        }
    }

    /**
     * Valider une URL
     */
    static isValidUrl(string) {
        try {
            new URL(string);
            return true;
        } catch (_) {
            return false;
        }
    }

    /**
     * Obtenir les informations sur le navigateur
     */
    static getBrowserInfo() {
        const ua = navigator.userAgent;
        let browser = 'Unknown';
        
        if (ua.includes('Chrome')) browser = 'Chrome';
        else if (ua.includes('Firefox')) browser = 'Firefox';
        else if (ua.includes('Safari')) browser = 'Safari';
        else if (ua.includes('Edge')) browser = 'Edge';
        
        return {
            browser,
            userAgent: ua,
            language: navigator.language,
            platform: navigator.platform,
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine
        };
    }

    /**
     * D√©tecter le support de certaines fonctionnalit√©s
     */
    static getFeatureSupport() {
        return {
            websocket: 'WebSocket' in window,
            webworker: 'Worker' in window,
            clipboard: 'clipboard' in navigator,
            notification: 'Notification' in window,
            geolocation: 'geolocation' in navigator,
            localStorage: 'localStorage' in window,
            sessionStorage: 'sessionStorage' in window,
            dragDrop: 'draggable' in document.createElement('div'),
            fileApi: 'FileReader' in window,
            canvas: 'getContext' in document.createElement('canvas')
        };
    }

    /**
     * Calculer le pourcentage de compression
     */
    static calculateCompressionRatio(originalSize, compressedSize) {
        if (originalSize === 0) return 0;
        return Math.round(((originalSize - compressedSize) / originalSize) * 100);
    }

    /**
     * Formater un ratio de compression
     */
    static formatCompressionRatio(ratio) {
        if (ratio <= 0) return 'Aucune compression';
        if (ratio < 10) return `${ratio}% (faible)`;
        if (ratio < 30) return `${ratio}% (mod√©r√©e)`;
        if (ratio < 50) return `${ratio}% (bonne)`;
        if (ratio < 70) return `${ratio}% (tr√®s bonne)`;
        return `${ratio}% (excellente)`;
    }

    /**
     * Obtenir la couleur pour un statut
     */
    static getStatusColor(status) {
        const colors = {
            uploaded: '#7c3aed',
            queued: '#d97706',
            processing: '#2563eb',
            completed: '#10b981',
            error: '#ef4444',
            cancelled: '#6b7280'
        };
        
        return colors[status] || colors.uploaded;
    }

    /**
     * Cr√©er un √©l√©ment DOM avec des attributs
     */
    static createElement(tag, attributes = {}, children = []) {
        const element = document.createElement(tag);
        
        // Ajouter les attributs
        Object.entries(attributes).forEach(([key, value]) => {
            if (key === 'className') {
                element.className = value;
            } else if (key === 'innerHTML') {
                element.innerHTML = value;
            } else if (key === 'textContent') {
                element.textContent = value;
            } else if (key.startsWith('data-')) {
                element.setAttribute(key, value);
            } else {
                element[key] = value;
            }
        });
        
        // Ajouter les enfants
        children.forEach(child => {
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            } else if (child instanceof Node) {
                element.appendChild(child);
            }
        });
        
        return element;
    }

    /**
     * Animer un √©l√©ment avec CSS
     */
    static animate(element, animation, duration = 300) {
        return new Promise(resolve => {
            element.style.animation = `${animation} ${duration}ms ease`;
            
            const handleAnimationEnd = () => {
                element.style.animation = '';
                element.removeEventListener('animationend', handleAnimationEnd);
                resolve();
            };
            
            element.addEventListener('animationend', handleAnimationEnd);
        });
    }

    /**
     * Faire d√©filer vers un √©l√©ment
     */
    static scrollToElement(element, behavior = 'smooth') {
        element.scrollIntoView({
            behavior,
            block: 'nearest',
            inline: 'nearest'
        });
    }

    /**
     * V√©rifier si un √©l√©ment est visible dans le viewport
     */
    static isElementVisible(element) {
        const rect = element.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
    }

    /**
     * Obtenir les dimensions de l'√©cran
     */
    static getScreenInfo() {
        return {
            width: window.innerWidth,
            height: window.innerHeight,
            devicePixelRatio: window.devicePixelRatio || 1,
            orientation: window.orientation || 0,
            isMobile: window.innerWidth <= 768,
            isTablet: window.innerWidth > 768 && window.innerWidth <= 1024,
            isDesktop: window.innerWidth > 1024
        };
    }

    /**
     * Logger personnalis√© avec niveaux
     */
    static createLogger(prefix = 'FileOptimizer') {
        const logLevels = {
            error: 0,
            warn: 1,
            info: 2,
            debug: 3
        };
        
        const currentLevel = logLevels[localStorage.getItem('logLevel')] ?? logLevels.info;
        
        return {
            error: (...args) => {
                if (currentLevel >= logLevels.error) {
                    console.error(`[${prefix}]`, ...args);
                }
            },
            warn: (...args) => {
                if (currentLevel >= logLevels.warn) {
                    console.warn(`[${prefix}]`, ...args);
                }
            },
            info: (...args) => {
                if (currentLevel >= logLevels.info) {
                    console.info(`[${prefix}]`, ...args);
                }
            },
            debug: (...args) => {
                if (currentLevel >= logLevels.debug) {
                    console.debug(`[${prefix}]`, ...args);
                }
            }
        };
    }

    /**
     * Gestionnaire d'erreurs global
     */
    static handleError(error, context = 'Unknown') {
        const logger = this.createLogger('ErrorHandler');
        
        logger.error(`Erreur dans ${context}:`, {
            message: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href
        });

        // Optionnel : envoyer √† un service de monitoring
        if (window.Sentry) {
            window.Sentry.captureException(error, {
                tags: { context },
                extra: { timestamp: new Date().toISOString() }
            });
        }
    }

    /**
     * Retry automatique avec backoff exponentiel
     */
    static async retry(fn, maxAttempts = 3, baseDelay = 1000) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                return await fn(attempt);
            } catch (error) {
                lastError = error;
                
                if (attempt === maxAttempts) {
                    throw error;
                }
                
                const delay = baseDelay * Math.pow(2, attempt - 1);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        throw lastError;
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Utils;
} else {
    window.Utils = Utils;
}


================================================
File: frontend/js/websocket.js
================================================
// js/websocket.js
// Client WebSocket pour la communication temps r√©el

/**
 * Gestionnaire WebSocket pour les communications temps r√©el
 */
class WebSocketManager {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.socket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.reconnectDelay = 1000; // 1 seconde
        this.isConnecting = false;
        this.isConnected = false;
        this.eventHandlers = new Map();
        this.joinedRooms = new Set();
        this.logger = Utils.createLogger('WebSocket');
        
        this.connect();
    }

    /**
     * √âtablir la connexion WebSocket
     */
    connect() {
        if (this.isConnecting || this.isConnected) {
            return;
        }

        try {
            this.isConnecting = true;
            this.logger.info('Connexion WebSocket...');

            // Initialiser Socket.IO
            this.socket = io(this.baseUrl, {
                transports: ['websocket', 'polling'],
                timeout: 20000,
                reconnection: false, // Gestion manuelle
                forceNew: true
            });

            this.setupEventHandlers();

        } catch (error) {
            this.logger.error('Erreur cr√©ation WebSocket:', error);
            this.isConnecting = false;
            this.scheduleReconnect();
        }
    }

    /**
     * Configuration des gestionnaires d'√©v√©nements Socket.IO
     */
    setupEventHandlers() {
        // Connexion √©tablie
        this.socket.on('connect', () => {
            this.isConnected = true;
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            
            this.logger.info('WebSocket connect√©', { id: this.socket.id });
            this.emit('connect');

            // Rejoindre les rooms pr√©c√©demment jointes
            this.rejoinRooms();
        });

        // D√©connexion
        this.socket.on('disconnect', (reason) => {
            this.isConnected = false;
            this.logger.warn('WebSocket d√©connect√©:', reason);
            this.emit('disconnect', reason);

            // Reconnexion automatique sauf si d√©connexion volontaire
            if (reason !== 'io client disconnect') {
                this.scheduleReconnect();
            }
        });

        // Erreur de connexion
        this.socket.on('connect_error', (error) => {
            this.isConnecting = false;
            this.logger.error('Erreur connexion WebSocket:', error);
            this.emit('error', error);
            this.scheduleReconnect();
        });

        // √âv√©nements m√©tier
        this.socket.on('job-progress', (data) => {
            this.logger.debug('Progression job:', data);
            this.emit('job-progress', data);
        });

        this.socket.on('job-completed', (data) => {
            this.logger.info('Job termin√©:', data.jobId);
            this.emit('job-completed', data);
        });

        this.socket.on('job-error', (data) => {
            this.logger.error('Erreur job:', data);
            this.emit('job-error', data);
        });

        this.socket.on('job-queued', (data) => {
            this.logger.info('Job en queue:', data.jobId);
            this.emit('job-queued', data);
        });

        this.socket.on('job-started', (data) => {
            this.logger.info('Job d√©marr√©:', data.jobId);
            this.emit('job-started', data);
        });

        // √âv√©nements syst√®me
        this.socket.on('server-shutdown', (data) => {
            this.logger.warn('Serveur en arr√™t:', data);
            this.emit('server-shutdown', data);
        });

        this.socket.on('server-maintenance', (data) => {
            this.logger.info('Maintenance serveur:', data);
            this.emit('server-maintenance', data);
        });

        // √âv√©nements de notification
        this.socket.on('notification', (data) => {
            this.logger.info('Notification:', data);
            this.emit('notification', data);
        });

        // R√©ponses aux requ√™tes
        this.socket.on('joined-job', (data) => {
            this.joinedRooms.add(`job-${data.jobId}`);
            this.logger.debug('Rejoint room job:', data.jobId);
        });

        this.socket.on('left-job', (data) => {
            this.joinedRooms.delete(`job-${data.jobId}`);
            this.logger.debug('Quitt√© room job:', data.jobId);
        });

        this.socket.on('job-status', (data) => {
            this.emit('job-status-response', data);
        });

        // √âv√©nements d'erreur sp√©cifiques
        this.socket.on('error', (data) => {
            this.logger.error('Erreur WebSocket:', data);
            this.emit('websocket-error', data);
        });
    }

    /**
     * Programmer une reconnexion
     */
    scheduleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            this.logger.error('Nombre maximum de tentatives de reconnexion atteint');
            this.emit('max-reconnect-attempts');
            return;
        }

        this.reconnectAttempts++;
        const delay = Math.min(
            this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
            30000 // Maximum 30 secondes
        );

        this.logger.info(`Reconnexion dans ${delay}ms (tentative ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

        setTimeout(() => {
            if (!this.isConnected && !this.isConnecting) {
                this.connect();
            }
        }, delay);
    }

    /**
     * Rejoindre les rooms apr√®s reconnexion
     */
    rejoinRooms() {
        this.joinedRooms.forEach(room => {
            if (room.startsWith('job-')) {
                const jobId = room.replace('job-', '');
                this.joinJobRoom(jobId);
            }
        });
    }

    /**
     * Rejoindre la room d'un job pour recevoir les updates
     */
    joinJobRoom(jobId) {
        if (!this.isConnected) {
            this.logger.warn('Impossible de rejoindre room, WebSocket non connect√©');
            return;
        }

        this.socket.emit('join-job', jobId);
        this.logger.debug('Demande rejoindre room job:', jobId);
    }

    /**
     * Quitter la room d'un job
     */
    leaveJobRoom(jobId) {
        if (!this.isConnected) {
            return;
        }

        this.socket.emit('leave-job', jobId);
        this.joinedRooms.delete(`job-${jobId}`);
        this.logger.debug('Quitt√© room job:', jobId);
    }

    /**
     * Demander le statut d'un job
     */
    requestJobStatus(jobId) {
        if (!this.isConnected) {
            this.logger.warn('Impossible de demander statut, WebSocket non connect√©');
            return;
        }

        this.socket.emit('get-status', jobId);
        this.logger.debug('Demande statut job:', jobId);
    }

    /**
     * Envoyer un ping au serveur
     */
    ping() {
        if (!this.isConnected) {
            return Promise.reject(new Error('WebSocket non connect√©'));
        }

        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            this.socket.emit('ping', startTime, (response) => {
                const latency = Date.now() - startTime;
                resolve({ latency, serverTime: response });
            });

            // Timeout apr√®s 5 secondes
            setTimeout(() => {
                reject(new Error('Ping timeout'));
            }, 5000);
        });
    }

    /**
     * S'abonner √† un type d'√©v√©nement
     */
    on(event, handler) {
        if (!this.eventHandlers.has(event)) {
            this.eventHandlers.set(event, new Set());
        }
        this.eventHandlers.get(event).add(handler);
    }

    /**
     * Se d√©sabonner d'un √©v√©nement
     */
    off(event, handler) {
        if (this.eventHandlers.has(event)) {
            this.eventHandlers.get(event).delete(handler);
        }
    }

    /**
     * √âmettre un √©v√©nement vers les handlers locaux
     */
    emit(event, data) {
        if (this.eventHandlers.has(event)) {
            this.eventHandlers.get(event).forEach(handler => {
                try {
                    handler(data);
                } catch (error) {
                    this.logger.error(`Erreur handler √©v√©nement ${event}:`, error);
                }
            });
        }
    }

    /**
     * Envoyer un √©v√©nement au serveur
     */
    send(event, data) {
        if (!this.isConnected) {
            this.logger.warn(`Impossible d'envoyer ${event}, WebSocket non connect√©`);
            return;
        }

        this.socket.emit(event, data);
    }

    /**
     * D√©connexion manuelle
     */
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
        }
        
        this.isConnected = false;
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.joinedRooms.clear();
        
        this.logger.info('WebSocket d√©connect√© manuellement');
    }

    /**
     * Reconnexion manuelle
     */
    reconnect() {
        this.disconnect();
        setTimeout(() => {
            this.reconnectAttempts = 0;
            this.connect();
        }, 1000);
    }

    /**
     * Obtenir l'√©tat de la connexion
     */
    getConnectionState() {
        return {
            isConnected: this.isConnected,
            isConnecting: this.isConnecting,
            reconnectAttempts: this.reconnectAttempts,
            socketId: this.socket?.id,
            joinedRooms: Array.from(this.joinedRooms),
            transport: this.socket?.io?.engine?.transport?.name
        };
    }

    /**
     * Obtenir les statistiques de connexion
     */
    getStats() {
        if (!this.socket) {
            return { connected: false };
        }

        return {
            connected: this.isConnected,
            socketId: this.socket.id,
            transport: this.socket.io.engine.transport.name,
            reconnectAttempts: this.reconnectAttempts,
            joinedRooms: this.joinedRooms.size,
            eventHandlers: this.eventHandlers.size
        };
    }

    /**
     * Activer/d√©sactiver le mode debug
     */
    setDebugMode(enabled) {
        if (this.socket) {
            this.socket.debug(enabled);
        }
    }

    /**
     * Nettoyer les ressources
     */
    destroy() {
        this.eventHandlers.clear();
        this.joinedRooms.clear();
        
        if (this.socket) {
            this.socket.removeAllListeners();
            this.socket.disconnect();
        }
        
        this.logger.info('WebSocketManager d√©truit');
    }

    /**
     * Test de fonctionnalit√© WebSocket
     */
    async testConnection() {
        try {
            if (!this.isConnected) {
                throw new Error('WebSocket non connect√©');
            }

            // Test ping
            const pingResult = await this.ping();
            
            // Test join/leave room
            this.joinJobRoom('test-job-id');
            await new Promise(resolve => setTimeout(resolve, 100));
            this.leaveJobRoom('test-job-id');

            return {
                success: true,
                latency: pingResult.latency,
                features: {
                    ping: true,
                    rooms: true,
                    events: true
                }
            };

        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Middleware pour retry automatique des √©v√©nements critiques
     */
    sendWithRetry(event, data, maxRetries = 3) {
        return new Promise((resolve, reject) => {
            let attempts = 0;

            const attemptSend = () => {
                attempts++;

                if (!this.isConnected) {
                    if (attempts < maxRetries) {
                        setTimeout(attemptSend, 1000 * attempts);
                        return;
                    }
                    reject(new Error('WebSocket non connect√© apr√®s plusieurs tentatives'));
                    return;
                }

                this.socket.emit(event, data, (response) => {
                    if (response && response.success) {
                        resolve(response);
                    } else if (attempts < maxRetries) {
                        setTimeout(attemptSend, 1000 * attempts);
                    } else {
                        reject(new Error(response?.error || 'Erreur envoi √©v√©nement'));
                    }
                });
            };

            attemptSend();
        });
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = WebSocketManager;
} else {
    window.WebSocketManager = WebSocketManager;
}

