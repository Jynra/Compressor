Directory structure:
└── Compressor/
    ├── README.md
    ├── readme_progress.md
    ├── backend/
    │   ├── Dockerfile
    │   ├── docker-compose.dev.yml
    │   ├── docker-compose.yml
    │   ├── ecosystem.config.js
    │   ├── package.json
    │   ├── .env.example
    │   ├── scripts/
    │   │   ├── deploy-production.sh
    │   │   ├── deploy-staging.sh
    │   │   └── health-check.sh
    │   ├── src/
    │   │   ├── server.js
    │   │   ├── controllers/
    │   │   ├── routes/
    │   │   │   ├── download.js
    │   │   │   ├── health.js
    │   │   │   ├── index.js
    │   │   │   ├── process.js
    │   │   │   ├── status.js
    │   │   │   └── upload.js
    │   │   ├── services/
    │   │   │   ├── fileService.js
    │   │   │   ├── imageService.js
    │   │   │   ├── jobService.js
    │   │   │   ├── processingService.js
    │   │   │   └── queueService.js
    │   │   ├── utils/
    │   │   │   ├── logger.js
    │   │   │   ├── redis.js
    │   │   │   └── validation.js
    │   │   └── workers/
    │   │       └── processor.js
    │   └── tests/
    └── frontend/
        ├── index.html
        ├── css/
        │   └── styles.css
        └── js/
            ├── api.js
            ├── app.js
            ├── ui.js
            ├── utils.js
            └── websocket.js

================================================
File: README.md
================================================
# 🗜️ Optimiseur de Fichiers Multimédia

Une solution self-hosted complète pour compresser et optimiser tous vos fichiers multimédia tout en conservant leur format original.

![Version](https://img.shields.io/badge/version-2.0.0-blue.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)
![Node](https://img.shields.io/badge/node-%3E%3D16.0.0-brightgreen.svg)
![Docker](https://img.shields.io/badge/docker-ready-blue.svg)

## 🎯 Objectif

Réduire la taille de vos fichiers multimédia sans changer leur format, avec une interface web moderne et un backend performant utilisant FFmpeg.

## ✨ Fonctionnalités

### 📸 Images
- **Formats supportés** : JPEG, PNG, WebP, AVIF, HEIC, TIFF, BMP
- **Compression intelligente** avec préservation de la qualité
- **Redimensionnement automatique** selon vos besoins
- **Conversion de format** optionnelle
- **Optimisation des métadonnées** (suppression EXIF)

### 🎵 Audio
- **Formats supportés** : MP3, FLAC, WAV, AAC, OGG, M4A
- **Compression variable** (CBR/VBR)
- **Normalisation du volume** automatique
- **Conversion multi-format** simultanée
- **Réduction de fréquence d'échantillonnage**

### 🎬 Vidéo
- **Formats supportés** : MP4, AVI, MKV, WebM, MOV, FLV
- **Codecs modernes** : H.264, H.265/HEVC, VP9, AV1
- **Compression adaptative** selon le contenu
- **Redimensionnement et recadrage** automatique
- **Optimisation pour le streaming** web

### 📄 Documents
- **PDF** : Compression des images intégrées
- **Optimisation de la structure** du document
- **Suppression des métadonnées** sensibles

## 🏗️ Architecture

```
┌─────────────────┐    HTTP/WebSocket    ┌─────────────────┐
│                 │ ◄─────────────────► │                 │
│    Frontend     │                     │     Backend     │
│   (React/Vue)   │                     │   (Node.js)     │
│                 │                     │                 │
└─────────────────┘                     └─────────────────┘
                                                 │
                                                 ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│                 │    │                 │    │                 │
│   File Upload   │    │  Processing     │    │   FFmpeg        │
│   & Settings    │    │     Queue       │    │  ImageMagick    │
│                 │    │   (Redis)       │    │   PDF-lib       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 🚀 Installation & Déploiement

### Option 1 : Docker (Recommandé)

```bash
# Cloner le repository
git clone https://github.com/votre-username/file-optimizer.git
cd file-optimizer

# Lancer avec Docker Compose
docker-compose up -d

# L'application sera disponible sur http://localhost:3000
```

### Option 2 : Installation manuelle

#### Prérequis

- **Node.js** 16+ 
- **FFmpeg** installé et dans le PATH
- **ImageMagick** (optionnel, pour images avancées)
- **Redis** (pour la queue de traitement)

#### Backend

```bash
cd backend
npm install

# Configuration
cp .env.example .env
# Éditer .env avec vos paramètres

# Lancer le serveur
npm run dev
```

#### Frontend

```bash
cd frontend
npm install
npm run build
npm start
```

## ⚙️ Configuration

### Variables d'environnement

```env
# Backend
PORT=8000
REDIS_URL=redis://localhost:6379
UPLOAD_MAX_SIZE=500MB
TEMP_DIR=/tmp/uploads
CLEANUP_INTERVAL=3600

# FFmpeg
FFMPEG_PATH=/usr/bin/ffmpeg
FFPROBE_PATH=/usr/bin/ffprobe

# Security
CORS_ORIGIN=http://localhost:3000
JWT_SECRET=your-secret-key
RATE_LIMIT=100

# Storage
STORAGE_TYPE=local # ou s3, gcs
S3_BUCKET=your-bucket
S3_REGION=eu-west-1
```

### Paramètres de compression par défaut

```json
{
  "images": {
    "quality": 80,
    "maxWidth": 1920,
    "maxHeight": 1080,
    "format": "auto"
  },
  "videos": {
    "codec": "h264",
    "crf": 23,
    "preset": "medium",
    "maxBitrate": "2M"
  },
  "audio": {
    "codec": "aac",
    "bitrate": "128k",
    "sampleRate": 44100
  }
}
```

## 📊 Performances & Limites

### Performances typiques

| Type de fichier | Taille max | Temps de traitement | Compression moyenne |
|-----------------|------------|--------------------|--------------------|
| **Image JPEG**  | 50 MB      | 2-5 secondes       | 30-70%            |
| **Vidéo HD**    | 2 GB       | 2-10 minutes       | 40-80%            |
| **Audio FLAC**  | 200 MB     | 10-30 secondes     | 50-90%            |
| **PDF**         | 100 MB     | 5-15 secondes      | 10-60%            |

### Limites recommandées

- **Fichier unique** : 5 GB max
- **Traitement simultané** : 10 fichiers
- **Stockage temporaire** : 50 GB
- **Rétention** : 24 heures

## 🛠️ API Documentation

### Upload de fichier

```http
POST /api/upload
Content-Type: multipart/form-data

{
  "file": [binary],
  "settings": {
    "quality": 80,
    "maxWidth": 1920,
    "format": "jpeg"
  }
}
```

### Statut du traitement

```http
GET /api/status/:jobId

Response:
{
  "status": "processing|completed|error",
  "progress": 45,
  "originalSize": 15728640,
  "compressedSize": 4718592,
  "compressionRatio": 70,
  "eta": 120
}
```

### Téléchargement

```http
GET /api/download/:jobId

Response: [binary file]
```

## 🔧 Développement

### Structure du projet

```
file-optimizer/
├── backend/
│   ├── src/
│   │   ├── controllers/
│   │   ├── services/
│   │   ├── utils/
│   │   └── workers/
│   ├── tests/
│   └── package.json
├── frontend/
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   └── utils/
│   ├── public/
│   └── package.json
├── docker-compose.yml
└── README.md
```

### Lancer en mode développement

```bash
# Terminal 1 - Backend
cd backend && npm run dev

# Terminal 2 - Frontend  
cd frontend && npm run dev

# Terminal 3 - Redis
redis-server

# Terminal 4 - Worker
cd backend && npm run worker
```

### Tests

```bash
# Tests backend
cd backend && npm test

# Tests frontend
cd frontend && npm test

# Tests d'intégration
npm run test:e2e
```

## 🐳 Docker

### Dockerfile multi-stage

```dockerfile
# Frontend build
FROM node:18-alpine AS frontend
WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm ci
COPY frontend/ ./
RUN npm run build

# Backend avec FFmpeg
FROM node:18-alpine AS backend
RUN apk add --no-cache ffmpeg imagemagick
WORKDIR /app
COPY backend/package*.json ./
RUN npm ci --only=production
COPY backend/ ./
COPY --from=frontend /app/frontend/dist ./public

EXPOSE 8000
CMD ["npm", "start"]
```

### Docker Compose

```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - uploads:/tmp/uploads
    depends_on:
      - redis

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

  worker:
    build: .
    command: npm run worker
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - uploads:/tmp/uploads
    depends_on:
      - redis

volumes:
  uploads:
  redis_data:
```

## 📈 Monitoring & Logs

### Métriques disponibles

- **Débit** : Fichiers traités par heure
- **Temps de traitement** moyen par type
- **Taux de compression** moyen
- **Utilisation CPU/Mémoire**
- **Erreurs** et causes

### Intégrations

- **Prometheus** + Grafana pour métriques
- **Winston** pour logs structurés
- **Sentry** pour monitoring erreurs
- **Health checks** Docker

## 🔒 Sécurité

### Mesures implémentées

- **Rate limiting** par IP
- **Validation** stricte des fichiers uploadés
- **Scan antivirus** optionnel (ClamAV)
- **Chiffrement** des fichiers temporaires
- **Nettoyage automatique** des fichiers
- **CORS** configuré strictement

### Recommandations

- Utiliser HTTPS en production
- Configurer un reverse proxy (Nginx)
- Limiter les tailles d'upload
- Monitorer l'espace disque
- Sauvegardes régulières des configurations

## 🤝 Contribution

1. **Fork** le projet
2. **Créer** une branche feature (`git checkout -b feature/amazing-feature`)
3. **Commit** vos changements (`git commit -m 'Add amazing feature'`)
4. **Push** vers la branche (`git push origin feature/amazing-feature`)
5. **Ouvrir** une Pull Request

### Guidelines

- Code formaté avec Prettier
- Tests unitaires pour nouvelles fonctionnalités
- Documentation mise à jour
- Commits conventionnels

## 📝 Roadmap

### Version 2.1
- [ ] Support WebAssembly pour compression côté client
- [ ] Interface mobile dédiée
- [ ] Compression batch programmée
- [ ] Intégration cloud storage (S3, GCS)

### Version 2.2
- [ ] Machine Learning pour compression optimale
- [ ] API GraphQL
- [ ] Plugin WordPress/Drupal
- [ ] Support formats RAW photo

### Version 3.0
- [ ] Clustering multi-serveurs
- [ ] CDN intégré
- [ ] Compression temps réel streaming
- [ ] Interface admin avancée

## 🆘 Support

### Documentation
- [Wiki complet](https://github.com/votre-username/file-optimizer/wiki)
- [FAQ](https://github.com/votre-username/file-optimizer/wiki/FAQ)
- [Troubleshooting](https://github.com/votre-username/file-optimizer/wiki/Troubleshooting)

### Communauté
- [Discord](https://discord.gg/file-optimizer)
- [Forum](https://forum.file-optimizer.com)
- [Issues GitHub](https://github.com/votre-username/file-optimizer/issues)

### Support commercial
- Email : support@file-optimizer.com
- Consulting : consulting@file-optimizer.com

## 📄 License

Ce projet est sous licence MIT. Voir le fichier [LICENSE](LICENSE) pour plus de détails.

## 🙏 Remerciements

- **FFmpeg** pour le moteur de traitement multimédia
- **ImageMagick** pour le traitement d'images avancé
- **Redis** pour la gestion des queues
- La communauté **open source** pour les contributions

---

**Made with ❤️ by [Votre Nom]**

> 💡 **Astuce** : Commencez par la version Docker pour un déploiement rapide, puis personnalisez selon vos besoins !


================================================
File: readme_progress.md
================================================
# 🗜️ Optimiseur de Fichiers Multimédia

## 📋 État d'avancement du projet

### ✅ **Complété (Étape 1/7) - Backend Services**

**Services Backend (backend/src/services/)**
- ✅ `jobService.js` - Gestion complète des jobs Redis
- ✅ `queueService.js` - Queue Bull/Redis avec événements
- ✅ `fileService.js` - Utilitaires de gestion de fichiers
- ✅ `imageService.js` - Traitement d'images avec Sharp
- ✅ `processingService.js` - Orchestrateur principal

### ✅ **Complété (Étape 2/7) - Backend Utils & Configuration**

**Utilitaires Backend (backend/src/utils/)**
- ✅ `logger.js` - Système de logging Winston complet
- ✅ `redis.js` - Client Redis avec reconnexion automatique
- ✅ `validation.js` - Validation Joi complète + sécurité

**Configuration**
- ✅ `.env.example` - Variables d'environnement documentées
- ✅ `package.json` - Dépendances et scripts NPM

### ✅ **Complété (Étape 3/7) - Routes API**

**Routes Express (backend/src/routes/)**
- ✅ `upload.js` - Upload multipart avec validation sécurisée
- ✅ `status.js` - Statut jobs avec pagination et filtres
- ✅ `download.js` - Téléchargement avec Range support
- ✅ `process.js` - Gestion traitement et queue
- ✅ `health.js` - Health checks système complets
- ✅ `index.js` - Routeur principal avec middleware

### ✅ **Complété (Étape 4/7) - Serveur Principal & Worker**

**Serveur & Worker (backend/src/)**
- ✅ `server.js` - Serveur Express complet avec WebSocket
- ✅ `workers/processor.js` - Worker Bull pour traitement asynchrone

**Configuration Docker & Déploiement**
- ✅ `docker-compose.yml` - Configuration production + développement
- ✅ `Dockerfile` - Multi-stage build optimisé
- ✅ `ecosystem.config.js` - Configuration PM2
- ✅ Scripts de déploiement automatisés

### ✅ **Complété (Étape 5/7) - Frontend Moderne**

**Interface Frontend (frontend/)**
- ✅ `index.html` - Page principale responsive avec WebSocket
- ✅ `css/styles.css` - Design system moderne et adaptatif
- ✅ `js/app.js` - Application principale orchestratrice
- ✅ `js/api.js` - Client API REST avec retry/cache
- ✅ `js/websocket.js` - Client WebSocket temps réel
- ✅ `js/ui.js` - Gestionnaire interface utilisateur
- ✅ `js/utils.js` - Utilitaires généraux et formatage

**Fonctionnalités Frontend complètes :**
- 📤 **Upload drag & drop** : Multi-fichiers avec validation temps réel
- 📊 **Dashboard temps réel** : WebSocket pour progression jobs
- 🎨 **Interface moderne** : Responsive mobile-first avec animations
- 🔄 **Gestion d'état robuste** : Cache intelligent, retry automatique
- 🔔 **Notifications** : Toast contextuel avec auto-masquage
- ⌨️ **Raccourcis clavier** : Navigation optimisée développeur
- 🎯 **Actions contextuelles** : Download, retry, delete selon statut

---

## 🎯 **Prochaines étapes**

### 🔄 **Étape 6/7 - Tests & Monitoring**
- Tests unitaires et d'intégration
- Configuration Prometheus/Grafana
- Documentation API complète

### 🔄 **Étape 7/7 - Finalisation**
- Guide d'installation
- Documentation utilisateur
- Scripts de maintenance

---

## 🏗️ **Architecture finale actuelle**

```
backend/src/                  ✅ TERMINÉ
├── services/                 ✅ Services métier complets
│   ├── jobService.js         ✅ Gestion jobs Redis
│   ├── queueService.js       ✅ Queue Bull/Redis
│   ├── fileService.js        ✅ Utilitaires fichiers
│   ├── imageService.js       ✅ Traitement images Sharp
│   └── processingService.js  ✅ Orchestrateur principal
├── utils/                    ✅ Utilitaires robustes
│   ├── logger.js            ✅ Winston logging complet
│   ├── redis.js             ✅ Client Redis robuste
│   └── validation.js        ✅ Validation Joi + sécurité
├── routes/                   ✅ API REST complète
│   ├── upload.js            ✅ Upload multipart sécurisé
│   ├── status.js            ✅ Statut avec pagination
│   ├── download.js          ✅ Download avec streaming
│   ├── process.js           ✅ Gestion traitement
│   ├── health.js            ✅ Health checks complets
│   └── index.js             ✅ Routeur principal
├── workers/                  ✅ Worker de traitement
│   └── processor.js         ✅ Worker Bull avec monitoring
└── server.js                ✅ Serveur Express + WebSocket

backend/                      ✅ Configuration complète
├── .env.example             ✅ Variables d'environnement
├── package.json             ✅ Dépendances + scripts
├── docker-compose.yml       ✅ Docker production/dev
├── Dockerfile               ✅ Multi-stage optimisé
├── ecosystem.config.js      ✅ Configuration PM2
└── scripts/                 ✅ Scripts déploiement
    ├── deploy-production.sh ✅ Déploiement production
    ├── deploy-staging.sh    ✅ Déploiement staging
    └── health-check.sh      ✅ Vérification santé

frontend/                     ✅ TERMINÉ
├── index.html               ✅ Interface principale responsive
├── css/
│   └── styles.css          ✅ Design system moderne
├── js/                      ✅ Architecture modulaire
│   ├── app.js              ✅ Application orchestratrice
│   ├── api.js              ✅ Client API avec retry/cache
│   ├── websocket.js        ✅ Client WebSocket temps réel
│   ├── ui.js               ✅ Gestionnaire interface
│   └── utils.js            ✅ Utilitaires généraux
└── assets/                  ⏳ Icônes et images (optionnel)
```

---

## 🚀 **Nouvelles fonctionnalités Étape 5 : Frontend**

### 🎨 **Interface Utilisateur Moderne**

#### **Design System Cohérent**
- **Variables CSS** personnalisables pour thématisation
- **Responsive breakpoints** mobile/tablet/desktop optimisés
- **Dark mode** automatique selon préférences système
- **Animations fluides** avec hardware acceleration
- **Accessibilité** ARIA labels et navigation clavier

#### **Upload Drag & Drop Avancé**
```javascript
// Fonctionnalités upload
- Multi-fichiers simultanés avec validation
- Feedback visuel temps réel (dragover, errors)
- Validation côté client (type, taille, magic bytes)
- Progression upload avec indicateur pourcentage
- Gestion d'erreurs granulaire par fichier
```

#### **Dashboard Jobs Temps Réel**
- **Statuts visuels** avec couleurs contextuelles
- **Barres de progression** animées pour jobs actifs
- **Actions contextuelles** selon statut (download, retry, delete)
- **Informations détaillées** taille, compression, temps
- **Tri et filtrage** par statut, type, date

### 🔌 **Intégration WebSocket Robuste**

#### **Client WebSocket Intelligent**
```javascript
class WebSocketManager {
    // Reconnexion automatique avec backoff exponentiel
    // Gestion des rooms de jobs pour updates ciblées
    // Ping/pong pour monitoring latence
    // Queue d'événements pour offline/online
    // Retry automatique pour événements critiques
}
```

#### **Événements Temps Réel**
- **job-progress** : Mise à jour progression 0-100%
- **job-completed** : Notification completion avec métriques
- **job-error** : Gestion erreurs avec détails et retry
- **server-shutdown** : Notification arrêt serveur gracieux
- **connection-status** : Indicateur visuel connexion

### 💾 **Architecture Frontend Modulaire**

#### **5 Modules Spécialisés**

**1. app.js - Orchestrateur Principal**
```javascript
class FileOptimizer {
    // Gestion lifecycle application
    // Coordination entre modules
    // État global des jobs
    // Configuration centralisée
}
```

**2. api.js - Client API REST**
```javascript
class ApiClient {
    // Requêtes HTTP avec timeout/retry
    // Upload avec progression
    // Cache intelligent pour GET
    // Batch requests avec concurrence limitée
}
```

**3. websocket.js - Client WebSocket**
```javascript
class WebSocketManager {
    // Connexion robuste avec reconnexion
    // Gestion événements métier
    // Rooms de jobs pour updates ciblées
    // Monitoring latence et santé connexion
}
```

**4. ui.js - Gestionnaire Interface**
```javascript
class UIManager {
    // Rendu dynamique des composants
    // Animations et transitions fluides
    // Notifications toast intelligentes
    // Gestion formulaires et validations
}
```

**5. utils.js - Utilitaires Généraux**
```javascript
class Utils {
    // Formatage données (taille, durée, dates)
    // Helpers DOM et manipulation
    // Logger configurable par niveau
    // Patterns performance (debounce, throttle)
}
```

### 🎯 **Expérience Utilisateur Optimisée**

#### **Workflow Intuitif**
1. **Drag & Drop** → Validation → Upload automatique
2. **Progression temps réel** via WebSocket
3. **Notification completion** avec métriques compression
4. **Download one-click** avec nom optimisé

#### **Gestion d'Erreurs Intelligente**
- **Retry automatique** pour requêtes réseau
- **Fallback gracieux** si WebSocket indisponible
- **Messages contextuels** selon type d'erreur
- **Recovery suggestions** pour actions utilisateur

#### **Performance Frontend**
- **Cache API** intelligent avec expiration
- **Debounce** événements fréquents (scroll, resize)
- **Lazy loading** pour listes longues
- **Memory management** avec cleanup automatique

### 📱 **Support Mobile Complet**

#### **Responsive Design**
```css
/* Breakpoints adaptatifs */
@media (max-width: 768px) {
    /* Optimisations mobile */
    .job-header { flex-direction: column; }
    .job-actions { width: 100%; }
}
```

#### **Touch Optimizations**
- **Touch targets** 44px minimum pour accessibilité
- **Gestures** drag & drop tactiles optimisés
- **Swipe actions** pour actions rapides
- **Vibration feedback** si supportée

### ⚡ **Optimisations Performance**

#### **Client-Side Caching**
```javascript
// Cache intelligent API avec TTL
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// Retry automatique avec backoff
const retry = async (fn, maxAttempts = 3, baseDelay = 1000) => {
    // Backoff exponentiel pour requêtes échouées
};
```

#### **WebSocket Optimizations**
- **Connection pooling** pour éviter reconnexions fréquentes
- **Event batching** pour updates multiples
- **Heartbeat monitoring** avec latence tracking
- **Graceful degradation** si WebSocket indisponible

### 🔒 **Sécurité Frontend**

#### **Validation Multi-niveaux**
- **Magic bytes** vérification signatures fichiers
- **MIME types** validation cohérence extension/contenu
- **File size** limites configurables
- **XSS protection** échappement HTML automatique

#### **Rate Limiting Client**
- **Upload throttling** pour éviter spam
- **Request debouncing** pour actions fréquentes
- **Circuit breaker** pattern pour API instable

---

## 📊 **Métriques et Monitoring Frontend**

### **Métriques Collectées**
```javascript
const metrics = {
    uploadCount: 0,           // Nombre total uploads
    totalSize: 0,             // Taille totale uploadée
    averageTime: 0,           // Temps moyen traitement
    compressionRatio: 0,      // Ratio compression moyen
    errorRate: 0,             // Taux d'erreur
    websocketLatency: 0       // Latence WebSocket moyenne
};
```

### **Monitoring Temps Réel**
- **Connection status** : Indicateur visuel connectivité
- **Performance tracking** : Temps réponse API
- **Error tracking** : Logs détaillés par composant
- **Usage analytics** : Patterns utilisation

---

## 🎯 **Workflow Utilisateur Complet**

### **1. Upload Multi-fichiers avec Progression**
```javascript
// 1. Sélection fichiers (drag & drop ou clic)
const files = Array.from(e.dataTransfer.files);

// 2. Validation temps réel
const validFiles = files.filter(file => validateFile(file));

// 3. Upload parallèle avec progression
for (const file of validFiles) {
    await uploadFile(file); // Progression WebSocket automatique
}

// 4. Notification completion
socket.on('job-completed', (result) => {
    showNotification(`${result.filename} optimisé!`);
    showDownloadButton(result.jobId);
});
```

### **2. Dashboard Temps Réel**
```javascript
// Synchronisation automatique état local/serveur
socket.on('job-progress', (data) => {
    updateJobProgress(data.jobId, data.progress);
    updateProgressBar(data.progress);
});

// Actions contextuelles selon statut
const actions = {
    completed: ['download', 'delete'],
    error: ['retry', 'delete'],
    processing: ['cancel'],
    queued: ['cancel']
};
```

### **3. Gestion d'Erreurs et Recovery**
```javascript
// Retry automatique avec backoff
const retryUpload = async (file, maxAttempts = 3) => {
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            return await uploadFile(file);
        } catch (error) {
            if (attempt === maxAttempts) throw error;
            await delay(1000 * Math.pow(2, attempt));
        }
    }
};

// Fallback gracieux WebSocket
if (!websocket.isConnected) {
    // Polling fallback pour statuts jobs
    setInterval(() => refreshJobStatuses(), 5000);
}
```

---

## 🔧 **Déploiement et Configuration**

### **Serveur Frontend**
```bash
# Développement
npx http-server frontend/ -p 3000 -c-1

# Production avec Nginx
server {
    listen 80;
    root /var/www/file-optimizer/frontend;
    index index.html;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    location /api/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    location /socket.io/ {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

### **Configuration Frontend**
```javascript
// Configuration centralisée dans app.js
const config = {
    apiEndpoint: window.location.origin + '/api',
    maxFileSize: 5 * 1024 * 1024 * 1024, // 5GB
    supportedTypes: ['image', 'video', 'audio', 'document'],
    websocketTimeout: 20000,
    reconnectMaxAttempts: 10,
    cacheTimeout: 5 * 60 * 1000 // 5 minutes
};
```

### **Variables CSS Personnalisables**
```css
:root {
    --primary: #2563eb;        /* Couleur principale */
    --success: #10b981;        /* Couleur succès */
    --error: #ef4444;          /* Couleur erreur */
    --radius: 8px;             /* Rayons courbure */
    --shadow: 0 4px 6px rgba(0,0,0,0.1); /* Ombres */
}
```

---

## ✅ **Frontend Complet et Production-Ready**

### **🎉 Achievements Étape 5**
- ✅ **Architecture modulaire** : 5 modules JavaScript spécialisés
- ✅ **Interface moderne** : Responsive, accessible, animée
- ✅ **WebSocket temps réel** : Progression jobs, reconnexion auto
- ✅ **Upload robuste** : Drag & drop multi-fichiers, validation
- ✅ **Dashboard intuitif** : Actions contextuelles, statuts visuels
- ✅ **Performance optimisée** : Cache, retry, debounce patterns
- ✅ **Mobile-first** : Touch optimizations, responsive design

### **🚀 Backend + Frontend = Application Complète**

L'application **File Optimizer** dispose maintenant d'une stack complète :

#### **🏗️ Architecture Full-Stack**
- **Backend** : API REST + WebSocket + Worker + Redis + Docker
- **Frontend** : SPA moderne + WebSocket + Cache + Mobile
- **Communication** : REST pour actions, WebSocket pour temps réel
- **Déploiement** : Docker Compose + Nginx + PM2

#### **💪 Fonctionnalités End-to-End**
- Upload drag & drop → Traitement asynchrone → Download optimisé
- Progression temps réel via WebSocket 
- Gestion d'erreurs robuste avec retry automatique
- Interface responsive mobile-first
- Monitoring et health checks complets

#### **🎯 Prêt pour Tests d'Intégration**

L'application complète peut maintenant être testée :

1. **Démarrer Backend** : API + Worker + Redis
2. **Servir Frontend** : HTTP server sur port 3000
3. **Tester workflow** : Upload → Progression → Download
4. **Valider WebSocket** : Temps réel, reconnexion
5. **Tester responsive** : Mobile, tablet, desktop

### **🔜 Prochaine Étape : Tests & Finition**
- **Tests d'intégration** frontend/backend
- **Documentation utilisateur** complète
- **Optimisations finales** performance
- **Packaging** pour distribution

**L'application File Optimizer est prête pour utilisation ! 🎉**


================================================
File: backend/Dockerfile
================================================
# Dockerfile
# Multi-stage build pour optimiser la taille et sécurité

# ===========================================
# Stage 1: Base image avec dépendances système
# ===========================================
FROM node:18-alpine AS base

# Installer les dépendances système requises
RUN apk add --no-cache \
    ffmpeg \
    imagemagick \
    curl \
    dumb-init \
    && rm -rf /var/cache/apk/*

# Créer l'utilisateur non-root pour la sécurité
RUN addgroup -g 1001 -S nodejs \
    && adduser -S fileoptimizer -u 1001 -G nodejs

# Définir le répertoire de travail
WORKDIR /app

# Copier les fichiers de configuration des dépendances
COPY package*.json ./

# ===========================================
# Stage 2: Développement
# ===========================================
FROM base AS development

# Installer toutes les dépendances (dev + prod)
RUN npm ci --include=dev

# Copier le code source
COPY . .

# Changer la propriété des fichiers
RUN chown -R fileoptimizer:nodejs /app

# Créer les répertoires nécessaires
RUN mkdir -p /app/uploads /app/logs \
    && chown -R fileoptimizer:nodejs /app/uploads /app/logs

USER fileoptimizer

# Port d'exposition
EXPOSE 8000 9229

# Point d'entrée avec dumb-init pour un arrêt propre
ENTRYPOINT ["dumb-init", "--"]

# Commande par défaut
CMD ["npm", "run", "dev"]

# ===========================================
# Stage 3: Build de production
# ===========================================
FROM base AS builder

# Installer seulement les dépendances de production
RUN npm ci --only=production && npm cache clean --force

# Copier le code source
COPY . .

# Supprimer les fichiers non nécessaires en production
RUN rm -rf \
    tests/ \
    docs/ \
    .git/ \
    .github/ \
    *.md \
    .eslintrc.js \
    .prettierrc \
    docker-compose*.yml \
    Dockerfile*

# ===========================================
# Stage 4: Production finale
# ===========================================
FROM node:18-alpine AS production

# Installer seulement les dépendances système essentielles
RUN apk add --no-cache \
    ffmpeg \
    imagemagick \
    curl \
    dumb-init \
    && rm -rf /var/cache/apk/*

# Créer l'utilisateur non-root
RUN addgroup -g 1001 -S nodejs \
    && adduser -S fileoptimizer -u 1001 -G nodejs

WORKDIR /app

# Copier les fichiers depuis le stage builder
COPY --from=builder --chown=fileoptimizer:nodejs /app ./

# Créer les répertoires avec permissions appropriées
RUN mkdir -p /app/uploads /app/logs /app/tmp \
    && chown -R fileoptimizer:nodejs /app/uploads /app/logs /app/tmp \
    && chmod 755 /app/uploads /app/logs /app/tmp

# Variables d'environnement par défaut
ENV NODE_ENV=production \
    PORT=8000 \
    TEMP_DIR=/app/uploads \
    LOG_DIR=/app/logs \
    NPM_CONFIG_CACHE=/app/tmp/.npm

# Passer à l'utilisateur non-root
USER fileoptimizer

# Port d'exposition
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8000/api/health || exit 1

# Labels pour la métadonnées
LABEL maintainer="File Optimizer Team" \
    version="2.0.0" \
    description="Optimiseur de fichiers multimédia" \
    org.opencontainers.image.source="https://github.com/your-username/file-optimizer"

# Point d'entrée avec dumb-init
ENTRYPOINT ["dumb-init", "--"]

# Commande par défaut
CMD ["npm", "start"]

# ===========================================
# Stage 5: Worker spécialisé
# ===========================================
FROM production AS worker

# Le worker utilise la même base mais une commande différente
CMD ["npm", "run", "worker"]

# ===========================================
# .dockerignore suggestions
# ===========================================
# Créer aussi un fichier .dockerignore avec:
#
# node_modules
# npm-debug.log*
# yarn-debug.log*
# yarn-error.log*
# .git
# .gitignore
# .github
# README.md
# docker-compose*.yml
# Dockerfile*
# .env
# .env.local
# .env.*.local
# coverage/
# .nyc_output
# .cache
# uploads/
# logs/
# tmp/
# *.log
# .DS_Store
# Thumbs.db
# tests/
# docs/
# monitoring/
# nginx/


================================================
File: backend/docker-compose.dev.yml
================================================
# docker-compose.dev.yml - Configuration DÉVELOPPEMENT
version: '3.8'

services:
  # Application en mode développement
  app-dev:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: file-optimizer-dev
    ports:
      - "8000:8000"
      - "9229:9229" # Debug port Node.js
    environment:
      - NODE_ENV=development
      - PORT=8000
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=debug
      - CORS_ORIGIN=http://localhost:3000,http://localhost:8080
      - SKIP_RATE_LIMIT=true
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
      - JWT_SECRET=dev-secret-key
      - CLEANUP_INTERVAL=1800  # 30min en dev
      - FILE_RETENTION=3600    # 1h en dev
      - UPLOAD_MAX_SIZE=1073741824  # 1GB en dev
    volumes:
      # Montage du code source pour hot reload
      - ./backend:/app:cached
      - uploads_dev:/app/uploads
      - logs_dev:/app/logs
      - node_modules:/app/node_modules
    depends_on:
      - redis
    networks:
      - file-optimizer-dev
    command: npm run dev
    # Pas de restart policy en dev
    stdin_open: true
    tty: true

  # Worker en mode développement
  worker-dev:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: file-optimizer-worker-dev
    environment:
      - NODE_ENV=development
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=debug
      - WORKER_CONCURRENCY=1  # Un seul worker en dev
      - JOB_TIMEOUT=900       # 15min timeout en dev
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
    volumes:
      - ./backend:/app:cached
      - uploads_dev:/app/uploads
      - logs_dev:/app/logs
      - node_modules:/app/node_modules
    depends_on:
      - redis
    networks:
      - file-optimizer-dev
    command: npm run worker
    stdin_open: true
    tty: true

  # Redis pour le développement
  redis:
    image: redis:7-alpine
    container_name: file-optimizer-redis-dev
    ports:
      - "6379:6379"  # Port exposé en dev pour debug
    command: redis-server --appendonly yes --loglevel debug
    volumes:
      - redis_data_dev:/data
    networks:
      - file-optimizer-dev

  # Frontend en mode développement
  frontend-dev:
    image: nginx:alpine
    container_name: file-optimizer-frontend-dev
    ports:
      - "3000:80"
    volumes:
      # Montage direct du frontend pour hot reload
      - ./frontend:/usr/share/nginx/html:cached
      - ./nginx/nginx.dev.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app-dev
    networks:
      - file-optimizer-dev

  # Outil de développement : Adminer pour Redis (optionnel)
  redis-gui:
    image: redislabs/redisinsight:latest
    container_name: redis-insight-dev
    ports:
      - "8001:8001"
    volumes:
      - redis_insight_data:/db
    networks:
      - file-optimizer-dev
    profiles:
      - debug

  # MailHog pour capturer emails en dev (optionnel)
  mailhog:
    image: mailhog/mailhog:latest
    container_name: file-optimizer-mailhog-dev
    ports:
      - "1025:1025"  # SMTP port
      - "8025:8025"  # Web UI port
    networks:
      - file-optimizer-dev
    profiles:
      - debug

volumes:
  uploads_dev:
    driver: local
  
  logs_dev:
    driver: local
  
  redis_data_dev:
    driver: local
  
  redis_insight_data:
    driver: local
  
  # Volume pour node_modules (évite conflits avec l'hôte)
  node_modules:
    driver: local

networks:
  file-optimizer-dev:
    driver: bridge
    name: file-optimizer-dev


================================================
File: backend/docker-compose.yml
================================================
# docker-compose.yml - Configuration PRODUCTION
version: '3.8'

services:
  # Application principale
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: file-optimizer-app
    restart: unless-stopped
    ports:
      - "${PORT:-8000}:8000"
    environment:
      - NODE_ENV=production
      - PORT=8000
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=info
      - CORS_ORIGIN=${CORS_ORIGIN:-http://localhost:3000}
      - UPLOAD_MAX_SIZE=${UPLOAD_MAX_SIZE:-5368709120}
      - WORKER_CONCURRENCY=${WORKER_CONCURRENCY:-2}
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
      - JWT_SECRET=${JWT_SECRET:-change-this-in-production}
      - CLEANUP_INTERVAL=3600
      - FILE_RETENTION=86400
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - file-optimizer
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Worker de traitement
  worker:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: file-optimizer-worker
    restart: unless-stopped
    command: npm run worker
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
      - TEMP_DIR=/app/uploads
      - LOG_LEVEL=info
      - WORKER_CONCURRENCY=${WORKER_CONCURRENCY:-2}
      - JOB_TIMEOUT=${JOB_TIMEOUT:-1800}
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - FFPROBE_PATH=/usr/bin/ffprobe
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - file-optimizer
    deploy:
      replicas: ${WORKER_REPLICAS:-1}
      resources:
        limits:
          memory: 2G
        reservations:
          memory: 512M

  # Redis pour la queue et le cache
  redis:
    image: redis:7-alpine
    container_name: file-optimizer-redis
    restart: unless-stopped
    command: >
      redis-server 
      --appendonly yes 
      --appendfsync everysec
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --save 900 1 300 10 60 10000
    volumes:
      - redis_data:/data
    networks:
      - file-optimizer
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 10s

  # Frontend (Nginx serving static files)
  frontend:
    image: nginx:alpine
    container_name: file-optimizer-frontend
    restart: unless-stopped
    ports:
      - "${FRONTEND_PORT:-3000}:80"
    volumes:
      - ./frontend:/usr/share/nginx/html:ro
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - file-optimizer

  # Monitoring avec Prometheus (optionnel)
  prometheus:
    image: prom/prometheus:latest
    container_name: file-optimizer-prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - file-optimizer
    profiles:
      - monitoring

  # Grafana pour la visualisation (optionnel)
  grafana:
    image: grafana/grafana:latest
    container_name: file-optimizer-grafana
    restart: unless-stopped
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning:ro
    networks:
      - file-optimizer
    profiles:
      - monitoring

volumes:
  uploads:
    driver: local
    driver_opts:
      type: none
      device: ${UPLOADS_PATH:-./uploads}
      o: bind
  
  logs:
    driver: local
    driver_opts:
      type: none
      device: ${LOGS_PATH:-./logs}
      o: bind
  
  redis_data:
    driver: local
  
  prometheus_data:
    driver: local
  
  grafana_data:
    driver: local

networks:
  file-optimizer:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16


================================================
File: backend/ecosystem.config.js
================================================
// ecosystem.config.js
// Configuration PM2 pour production et déploiement

module.exports = {
  apps: [
    {
      name: 'file-optimizer-api',
      script: 'src/server.js',
      cwd: '/opt/file-optimizer/backend',
      instances: 'max',
      exec_mode: 'cluster',
      env: {
        NODE_ENV: 'production',
        PORT: 8000
      },
      env_production: {
        NODE_ENV: 'production',
        PORT: 8000,
        LOG_LEVEL: 'info',
        REDIS_URL: 'redis://localhost:6379',
        TEMP_DIR: '/opt/file-optimizer/uploads',
        LOG_DIR: '/opt/file-optimizer/logs'
      },
      env_staging: {
        NODE_ENV: 'staging',
        PORT: 8001,
        LOG_LEVEL: 'debug',
        REDIS_URL: 'redis://localhost:6379',
        TEMP_DIR: '/opt/file-optimizer-staging/uploads'
      },
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      error_file: '/opt/file-optimizer/logs/pm2-api-error.log',
      out_file: '/opt/file-optimizer/logs/pm2-api-out.log',
      log_file: '/opt/file-optimizer/logs/pm2-api-combined.log',
      merge_logs: true,
      max_memory_restart: '1G',
      node_args: '--max-old-space-size=1024',
      restart_delay: 5000,
      max_restarts: 10,
      min_uptime: '10s',
      listen_timeout: 8000,
      kill_timeout: 5000,
      wait_ready: true,
      autorestart: true,
      watch: false,
      ignore_watch: ['logs', 'uploads', 'tmp', 'node_modules'],
      source_map_support: false,
      instance_var: 'INSTANCE_ID'
    },
    {
      name: 'file-optimizer-worker',
      script: 'src/workers/processor.js',
      cwd: '/opt/file-optimizer/backend',
      instances: 2,
      exec_mode: 'fork',
      env: {
        NODE_ENV: 'production',
        WORKER_CONCURRENCY: 2
      },
      env_production: {
        NODE_ENV: 'production',
        LOG_LEVEL: 'info',
        WORKER_CONCURRENCY: 2,
        JOB_TIMEOUT: 1800,
        REDIS_URL: 'redis://localhost:6379',
        TEMP_DIR: '/opt/file-optimizer/uploads'
      },
      env_staging: {
        NODE_ENV: 'staging',
        LOG_LEVEL: 'debug',
        WORKER_CONCURRENCY: 1,
        REDIS_URL: 'redis://localhost:6379'
      },
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      error_file: '/opt/file-optimizer/logs/pm2-worker-error.log',
      out_file: '/opt/file-optimizer/logs/pm2-worker-out.log',
      log_file: '/opt/file-optimizer/logs/pm2-worker-combined.log',
      merge_logs: true,
      max_memory_restart: '2G',
      node_args: '--max-old-space-size=2048',
      restart_delay: 10000,
      max_restarts: 5,
      min_uptime: '30s',
      kill_timeout: 30000,
      autorestart: true,
      watch: false,
      ignore_watch: ['logs', 'uploads', 'tmp', 'node_modules']
    }
  ],

  deploy: {
    production: {
      user: 'deploy',
      host: ['server1.example.com', 'server2.example.com'],
      ref: 'origin/main',
      repo: 'https://github.com/your-username/file-optimizer.git',
      path: '/opt/file-optimizer',
      'pre-deploy-local': '',
      'post-deploy': 'cd backend && npm ci --only=production && pm2 reload ecosystem.config.js --env production',
      'pre-setup': 'mkdir -p /opt/file-optimizer/logs /opt/file-optimizer/uploads',
      'ssh_options': 'ForwardAgent=yes',
      env: {
        NODE_ENV: 'production'
      }
    },
    staging: {
      user: 'deploy',
      host: 'staging.example.com',
      ref: 'origin/develop',
      repo: 'https://github.com/your-username/file-optimizer.git',
      path: '/opt/file-optimizer-staging',
      'post-deploy': 'cd backend && npm ci && pm2 reload ecosystem.config.js --env staging',
      'pre-setup': 'mkdir -p /opt/file-optimizer-staging/logs /opt/file-optimizer-staging/uploads',
      env: {
        NODE_ENV: 'staging'
      }
    }
  }
};


================================================
File: backend/package.json
================================================
{
  "name": "file-optimizer-backend",
  "version": "2.0.0",
  "description": "Backend pour l'optimiseur de fichiers multimédia",
  "main": "src/server.js",
  "keywords": [
    "file-optimization",
    "image-compression",
    "video-compression",
    "multimedia",
    "ffmpeg",
    "sharp"
  ],
  "author": "File Optimizer Team",
  "license": "MIT",
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "worker": "node src/workers/processor.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    "format": "prettier --write src/**/*.js",
    "build": "echo 'No build step required for Node.js'",
    "clean": "rm -rf node_modules package-lock.json",
    "setup": "npm install && cp .env.example .env",
    "docker:build": "docker build -t file-optimizer-backend .",
    "docker:run": "docker run -p 8000:8000 file-optimizer-backend",
    "health": "node scripts/health-check.js",
    "migrate": "node scripts/migrate.js",
    "seed": "node scripts/seed.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "compression": "^1.7.4",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "socket.io": "^4.7.4",
    "redis": "^4.6.12",
    "bull": "^4.12.2",
    "sharp": "^0.33.1",
    "fluent-ffmpeg": "^2.1.2",
    "pdf-lib": "^1.17.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "uuid": "^9.0.1",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "dotenv": "^16.3.1",
    "mime-types": "^2.1.35",
    "file-type": "^18.7.0",
    "crypto": "^1.0.1",
    "fs-extra": "^11.2.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0",
    "supertest": "^6.3.3",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-node": "^11.1.0",
    "prettier": "^3.1.1",
    "@types/jest": "^29.5.8",
    "redis-mock": "^0.56.3"
  },
  "optionalDependencies": {
    "aws-sdk": "^2.1509.0",
    "@google-cloud/storage": "^7.7.0",
    "@sentry/node": "^7.85.0",
    "prom-client": "^15.1.0",
    "nodemailer": "^6.9.7"
  },
  "jest": {
    "testEnvironment": "node",
    "collectCoverageFrom": [
      "src/**/*.js",
      "!src/server.js",
      "!src/workers/**/*.js"
    ],
    "coverageDirectory": "coverage",
    "coverageReporters": [
      "text",
      "lcov",
      "html"
    ],
    "testMatch": [
      "**/tests/**/*.test.js",
      "**/src/**/__tests__/**/*.js"
    ]
  },
  "eslintConfig": {
    "env": {
      "node": true,
      "es2021": true,
      "jest": true
    },
    "extends": [
      "eslint:recommended",
      "plugin:node/recommended",
      "prettier"
    ],
    "parserOptions": {
      "ecmaVersion": 12,
      "sourceType": "module"
    },
    "rules": {
      "no-console": "warn",
      "no-unused-vars": "error",
      "prefer-const": "error",
      "no-var": "error"
    }
  },
  "prettier": {
    "singleQuote": true,
    "trailingComma": "es5",
    "tabWidth": 4,
    "semi": true,
    "printWidth": 100
  },
  "nodemonConfig": {
    "watch": [
      "src"
    ],
    "ext": "js,json",
    "ignore": [
      "src/**/*.test.js",
      "node_modules"
    ],
    "env": {
      "NODE_ENV": "development"
    }
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/your-username/file-optimizer.git"
  },
  "bugs": {
    "url": "https://github.com/your-username/file-optimizer/issues"
  },
  "homepage": "https://github.com/your-username/file-optimizer#readme"
}


================================================
File: backend/.env.example
================================================
# ===========================================
# 🗜️ Optimiseur de Fichiers Multimédia
# Configuration des variables d'environnement
# ===========================================

# =================== SERVEUR ===================
# Port d'écoute du serveur
PORT=8000

# Environnement (development, production, test)
NODE_ENV=development

# URL de base de l'application
APP_URL=http://localhost:8000

# Secret pour JWT et sessions
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production

# =================== REDIS ===================
# URL complète Redis (prioritaire si définie)
REDIS_URL=redis://localhost:6379

# Ou configuration détaillée
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DATABASE=0

# =================== STOCKAGE ===================
# Répertoire temporaire pour les uploads
TEMP_DIR=/tmp/uploads

# Taille maximale des uploads (en bytes)
UPLOAD_MAX_SIZE=5368709120

# Durée de rétention des fichiers temporaires (en secondes)
FILE_RETENTION=86400

# Intervalle de nettoyage automatique (en secondes)
CLEANUP_INTERVAL=3600

# Type de stockage (local, s3, gcs)
STORAGE_TYPE=local

# =================== AWS S3 (si STORAGE_TYPE=s3) ===================
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=eu-west-1
S3_BUCKET=your-bucket-name
S3_ENDPOINT=

# =================== GOOGLE CLOUD (si STORAGE_TYPE=gcs) ===================
GOOGLE_CLOUD_PROJECT_ID=your-project-id
GOOGLE_CLOUD_KEY_FILE=path/to/service-account.json
GCS_BUCKET=your-bucket-name

# =================== FFMPEG ===================
# Chemin vers l'exécutable FFmpeg
FFMPEG_PATH=/usr/bin/ffmpeg

# Chemin vers l'exécutable FFprobe
FFPROBE_PATH=/usr/bin/ffprobe

# Nombre de threads FFmpeg (-1 = auto)
FFMPEG_THREADS=-1

# =================== IMAGEMAGICK ===================
# Chemin vers l'exécutable ImageMagick (optionnel)
IMAGEMAGICK_PATH=/usr/bin/convert

# =================== LOGGING ===================
# Niveau de log (error, warn, info, http, debug)
LOG_LEVEL=info

# Répertoire des logs (production uniquement)
LOG_DIR=./logs

# =================== SÉCURITÉ ===================
# Origines CORS autorisées (séparées par des virgules)
CORS_ORIGIN=http://localhost:3000,http://localhost:8080

# Limite de requêtes par minute par IP
RATE_LIMIT=100

# Taille maximale du body des requêtes
BODY_LIMIT=10mb

# Activer HTTPS en production
HTTPS_ENABLED=false

# Chemins des certificats SSL (si HTTPS_ENABLED=true)
SSL_CERT_PATH=
SSL_KEY_PATH=

# =================== AUTHENTIFICATION ===================
# Activer l'authentification (false pour usage libre)
AUTH_ENABLED=false

# Clé API pour l'accès (si AUTH_ENABLED=true)
API_KEY=your-api-key

# Durée de validité des tokens JWT (en secondes)
JWT_EXPIRES_IN=86400

# =================== MONITORING ===================
# Activer les métriques Prometheus
METRICS_ENABLED=false

# Port pour les métriques (si différent du port principal)
METRICS_PORT=9090

# Activer Sentry pour le monitoring des erreurs
SENTRY_DSN=

# =================== WORKERS ===================
# Nombre de workers pour le traitement
WORKER_CONCURRENCY=2

# Délai maximum pour un job (en secondes)
JOB_TIMEOUT=1800

# Nombre de tentatives en cas d'échec
JOB_ATTEMPTS=3

# =================== COMPRESSION ===================
# ===== Images =====
# Qualité par défaut pour les images (1-100)
DEFAULT_IMAGE_QUALITY=80

# Résolution maximale par défaut
DEFAULT_MAX_WIDTH=1920
DEFAULT_MAX_HEIGHT=1080

# Format par défaut ('auto' pour conserver l'original)
DEFAULT_IMAGE_FORMAT=auto

# ===== Vidéos =====
# Codec vidéo par défaut
DEFAULT_VIDEO_CODEC=h264

# CRF par défaut (18-51, plus bas = meilleure qualité)
DEFAULT_VIDEO_CRF=23

# Preset FFmpeg par défaut
DEFAULT_VIDEO_PRESET=medium

# Bitrate maximum par défaut
DEFAULT_VIDEO_BITRATE=2M

# ===== Audio =====
# Codec audio par défaut
DEFAULT_AUDIO_CODEC=aac

# Bitrate audio par défaut
DEFAULT_AUDIO_BITRATE=128k

# Fréquence d'échantillonnage par défaut
DEFAULT_AUDIO_SAMPLE_RATE=44100

# ===== Documents =====
# Qualité par défaut pour les PDFs (1-100)
DEFAULT_PDF_QUALITY=80

# =================== DÉVELOPPEMENT ===================
# Activer le mode debug
DEBUG=false

# Conserver les fichiers temporaires (utile pour debug)
KEEP_TEMP_FILES=false

# Activer les logs détaillés
VERBOSE_LOGS=false

# Port pour le hot reload (développement)
DEV_PORT=3000

# =================== DOCKER ===================
# Configuration pour Docker Compose
COMPOSE_PROJECT_NAME=file-optimizer

# Version de l'image Docker
DOCKER_TAG=latest

# =================== BACKUP ===================
# Activer les sauvegardes automatiques
BACKUP_ENABLED=false

# Répertoire de sauvegarde
BACKUP_DIR=./backups

# Intervalle de sauvegarde (en secondes)
BACKUP_INTERVAL=86400

# Nombre de sauvegardes à conserver
BACKUP_RETENTION=7

# =================== HEALTH CHECK ===================
# Intervalle de vérification de santé (en secondes)
HEALTH_CHECK_INTERVAL=30

# Timeout pour les vérifications (en secondes)
HEALTH_CHECK_TIMEOUT=5

# =================== PERFORMANCE ===================
# Limite mémoire pour Sharp (en MB)
SHARP_MEMORY_LIMIT=512

# Cache Sharp (true/false)
SHARP_CACHE=true

# Limite de concurrence Sharp
SHARP_CONCURRENCY=4

# =================== WEBHOOKS ===================
# URL de webhook pour notifications (optionnel)
WEBHOOK_URL=

# Secret pour signer les webhooks
WEBHOOK_SECRET=

# =================== NOTIFICATIONS ===================
# Configuration email (pour notifications d'erreurs)
SMTP_HOST=
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
SMTP_FROM=noreply@file-optimizer.local

# Configuration Slack (pour notifications)
SLACK_WEBHOOK_URL=
SLACK_CHANNEL=#file-optimizer

# =================== ANALYTICS ===================
# Google Analytics ID (optionnel)
GA_TRACKING_ID=

# Activer la collecte de statistiques anonymes
ANALYTICS_ENABLED=false

# =================== EXEMPLES DE VALEURS ===================
# Exemple pour un environnement de développement local :
# PORT=8000
# NODE_ENV=development
# REDIS_URL=redis://localhost:6379
# TEMP_DIR=/tmp/uploads
# LOG_LEVEL=debug
# CORS_ORIGIN=http://localhost:3000

# Exemple pour un environnement de production :
# PORT=8000
# NODE_ENV=production
# REDIS_URL=redis://prod-redis:6379
# TEMP_DIR=/app/uploads
# LOG_LEVEL=info
# CORS_ORIGIN=https://your-domain.com
# HTTPS_ENABLED=true
# SSL_CERT_PATH=/etc/ssl/certs/cert.pem
# SSL_KEY_PATH=/etc/ssl/private/key.pem


================================================
File: backend/scripts/deploy-production.sh
================================================
#!/bin/bash
# scripts/deploy-production.sh
# Script de déploiement en production

set -e

echo "🚀 Déploiement File Optimizer en production"

# Configuration
REPO_URL="https://github.com/your-username/file-optimizer.git"
DEPLOY_DIR="/opt/file-optimizer"
BACKUP_DIR="/opt/backups/file-optimizer"
SERVICE_NAME="file-optimizer"
BRANCH="main"

# Couleurs pour les logs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Vérifier les prérequis
check_prerequisites() {
    log_info "Vérification des prérequis..."
    
    # Node.js
    if ! command -v node &> /dev/null; then
        log_error "Node.js n'est pas installé"
        exit 1
    fi
    
    local node_version=$(node --version | cut -d'v' -f2)
    local major_version=$(echo $node_version | cut -d'.' -f1)
    if [ "$major_version" -lt 16 ]; then
        log_error "Node.js version >= 16 requise (actuelle: $node_version)"
        exit 1
    fi
    
    # Docker
    if ! command -v docker &> /dev/null; then
        log_error "Docker n'est pas installé"
        exit 1
    fi
    
    # Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose n'est pas installé"
        exit 1
    fi
    
    # Git
    if ! command -v git &> /dev/null; then
        log_error "Git n'est pas installé"
        exit 1
    fi
    
    # Vérifier l'espace disque (minimum 5GB)
    local available_space=$(df /opt 2>/dev/null | awk 'NR==2 {print $4}' || echo "0")
    if [ "$available_space" -lt 5242880 ]; then # 5GB en KB
        log_warn "Espace disque faible (moins de 5GB disponible)"
    fi
    
    log_success "Prérequis vérifiés"
}

# Créer sauvegarde
create_backup() {
    log_info "Création de la sauvegarde..."
    
    if [ -d "$DEPLOY_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
        BACKUP_FILE="$BACKUP_DIR/backup-$(date +%Y%m%d-%H%M%S).tar.gz"
        
        # Créer la sauvegarde en excluant les gros répertoires
        tar -czf "$BACKUP_FILE" -C "$DEPLOY_DIR" . \
            --exclude=node_modules \
            --exclude=uploads \
            --exclude=logs \
            --exclude=.git \
            --exclude=tmp \
            2>/dev/null || true
        
        if [ -f "$BACKUP_FILE" ]; then
            log_success "Sauvegarde créée: $BACKUP_FILE"
        else
            log_warn "Échec création sauvegarde"
        fi
    else
        log_warn "Aucun déploiement existant à sauvegarder"
    fi
}

# Arrêter les services en cours
stop_services() {
    log_info "Arrêt des services existants..."
    
    # Arrêter Docker Compose si en cours
    if [ -f "$DEPLOY_DIR/docker-compose.yml" ]; then
        cd "$DEPLOY_DIR"
        docker-compose down 2>/dev/null || true
        log_info "Services Docker arrêtés"
    fi
    
    # Arrêter PM2 si en cours
    if command -v pm2 &> /dev/null; then
        pm2 stop ecosystem.config.js 2>/dev/null || true
        log_info "Services PM2 arrêtés"
    fi
}

# Cloner ou mettre à jour le repository
update_code() {
    log_info "Mise à jour du code..."
    
    if [ -d "$DEPLOY_DIR/.git" ]; then
        cd "$DEPLOY_DIR"
        git fetch origin --quiet
        git checkout "$BRANCH" --quiet
        git reset --hard "origin/$BRANCH" --quiet
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Code mis à jour depuis Git (commit: $commit_hash)"
    else
        # Créer le répertoire parent si nécessaire
        mkdir -p "$(dirname "$DEPLOY_DIR")"
        git clone --branch "$BRANCH" "$REPO_URL" "$DEPLOY_DIR" --quiet
        cd "$DEPLOY_DIR"
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Repository cloné (commit: $commit_hash)"
    fi
}

# Installer les dépendances
install_dependencies() {
    log_info "Installation des dépendances..."
    cd "$DEPLOY_DIR/backend"
    
    # Nettoyer node_modules existants
    if [ -d "node_modules" ]; then
        rm -rf node_modules package-lock.json
        log_info "Anciens node_modules supprimés"
    fi
    
    # Installation propre
    npm ci --only=production --silent
    
    log_success "Dépendances installées"
}

# Configuration de l'environnement
setup_environment() {
    log_info "Configuration de l'environnement..."
    cd "$DEPLOY_DIR/backend"
    
    # Copier la configuration si elle n'existe pas
    if [ ! -f ".env" ]; then
        cp .env.example .env
        log_warn "Fichier .env créé depuis .env.example"
        log_warn "⚠️  Configurer manuellement les variables dans .env"
    fi
    
    # Créer les répertoires nécessaires
    mkdir -p uploads logs tmp
    chmod 755 uploads logs tmp
    
    # Créer les répertoires au niveau système si nécessaire
    sudo mkdir -p /opt/file-optimizer/uploads /opt/file-optimizer/logs 2>/dev/null || true
    sudo chown -R $USER:$USER /opt/file-optimizer 2>/dev/null || true
    
    log_success "Environnement configuré"
}

# Démarrer les services
start_services() {
    log_info "Démarrage des services..."
    cd "$DEPLOY_DIR"
    
    # Choisir la méthode de déploiement
    if [ "$DEPLOY_METHOD" = "pm2" ] && command -v pm2 &> /dev/null; then
        start_pm2_services
    else
        start_docker_services
    fi
}

# Démarrer avec Docker Compose
start_docker_services() {
    log_info "Démarrage avec Docker Compose..."
    
    # Pull des dernières images
    docker-compose pull --quiet
    
    # Démarrer les services
    docker-compose up -d
    
    # Attendre que les services soient prêts
    log_info "Attente du démarrage des services..."
    sleep 15
    
    # Vérifier que les conteneurs sont en cours d'exécution
    if docker-compose ps | grep -q "Up"; then
        log_success "Services Docker démarrés"
    else
        log_error "Échec du démarrage des services Docker"
        docker-compose logs
        exit 1
    fi
}

# Démarrer avec PM2
start_pm2_services() {
    log_info "Démarrage avec PM2..."
    cd "$DEPLOY_DIR/backend"
    
    # Démarrer avec PM2
    pm2 start ecosystem.config.js --env production
    
    # Sauvegarder la configuration PM2
    pm2 save
    
    log_success "Services PM2 démarrés"
}

# Tests post-déploiement
run_health_checks() {
    log_info "Tests de santé post-déploiement..."
    
    # Attendre un peu plus pour s'assurer que tout est prêt
    sleep 10
    
    # Déterminer le port selon la méthode de déploiement
    local port=8000
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f "http://localhost:$port/api/health" >/dev/null 2>&1; then
            log_success "API opérationnelle sur le port $port"
            break
        else
            if [ $attempt -eq $max_attempts ]; then
                log_error "API non accessible après $max_attempts tentatives"
                # Afficher les logs pour diagnostic
                if [ "$DEPLOY_METHOD" = "pm2" ]; then
                    pm2 logs --lines 20
                else
                    docker-compose logs --tail=20
                fi
                exit 1
            fi
            log_info "Tentative $attempt/$max_attempts - Attente de l'API..."
            sleep 2
            attempt=$((attempt + 1))
        fi
    done
    
    # Test de santé détaillé
    local health_response=$(curl -s "http://localhost:$port/api/health" 2>/dev/null || echo "")
    if echo "$health_response" | grep -q '"status":"ok"'; then
        log_success "Health check détaillé réussi"
    else
        log_warn "Health check détaillé partiel"
    fi
    
    # Test Redis si Docker
    if [ "$DEPLOY_METHOD" != "pm2" ]; then
        if docker exec file-optimizer-redis redis-cli ping 2>/dev/null | grep -q "PONG"; then
            log_success "Redis opérationnel"
        else
            log_warn "Redis non accessible (peut être normal si externe)"
        fi
    fi
    
    log_success "Tous les tests de santé essentiels passés"
}

# Nettoyage post-déploiement
cleanup() {
    log_info "Nettoyage post-déploiement..."
    
    # Nettoyer les anciennes images Docker
    if [ "$DEPLOY_METHOD" != "pm2" ]; then
        docker image prune -f >/dev/null 2>&1 || true
    fi
    
    # Nettoyer les anciennes sauvegardes (garder les 5 dernières)
    if [ -d "$BACKUP_DIR" ]; then
        ls -t "$BACKUP_DIR"/backup-*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm
    fi
    
    log_success "Nettoyage terminé"
}

# Afficher les informations finales
show_deployment_info() {
    log_success "🎉 Déploiement production terminé avec succès!"
    echo ""
    echo "📍 Informations de déploiement:"
    echo "   Application: http://localhost:8000"
    echo "   Health check: http://localhost:8000/api/health"
    echo "   API Documentation: http://localhost:8000/docs"
    echo ""
    echo "📋 Commandes utiles:"
    if [ "$DEPLOY_METHOD" = "pm2" ]; then
        echo "   Logs: pm2 logs"
        echo "   Status: pm2 status"
        echo "   Restart: pm2 restart ecosystem.config.js"
    else
        echo "   Logs: docker-compose logs -f"
        echo "   Status: docker-compose ps"
        echo "   Restart: docker-compose restart"
    fi
    echo "   Health: curl http://localhost:8000/api/health"
    echo ""
}

# Fonction de rollback en cas d'erreur
rollback() {
    log_error "Erreur détectée, tentative de rollback..."
    
    # Trouver la dernière sauvegarde
    if [ -d "$BACKUP_DIR" ]; then
        local latest_backup=$(ls -t "$BACKUP_DIR"/backup-*.tar.gz 2>/dev/null | head -n1)
        if [ -n "$latest_backup" ]; then
            log_info "Restauration depuis: $latest_backup"
            cd "$DEPLOY_DIR"
            tar -xzf "$latest_backup" 2>/dev/null || true
            start_services
            log_warn "Rollback effectué, vérifiez l'état du service"
        fi
    fi
}

# Fonction principale
main() {
    log_info "Début du déploiement production"
    echo "========================================"
    
    # Déterminer la méthode de déploiement
    DEPLOY_METHOD=${DEPLOY_METHOD:-docker}
    log_info "Méthode de déploiement: $DEPLOY_METHOD"
    
    check_prerequisites
    create_backup
    stop_services
    update_code
    install_dependencies
    setup_environment
    start_services
    run_health_checks
    cleanup
    show_deployment_info
}

# Gestion des erreurs avec rollback
trap 'rollback; exit 1' ERR

# Parse des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --method)
            DEPLOY_METHOD="$2"
            shift 2
            ;;
        --branch)
            BRANCH="$2"
            shift 2
            ;;
        --help)
            echo "Usage: $0 [--method docker|pm2] [--branch main|develop]"
            echo "  --method: Méthode de déploiement (default: docker)"
            echo "  --branch: Branche Git à déployer (default: main)"
            exit 0
            ;;
        *)
            log_warn "Option inconnue: $1"
            shift
            ;;
    esac
done

# Exécution
main "$@"


================================================
File: backend/scripts/deploy-staging.sh
================================================
#!/bin/bash
# scripts/deploy-staging.sh
# Script de déploiement en staging pour tests

set -e

echo "🔧 Déploiement File Optimizer en staging"

# Configuration staging
REPO_URL="https://github.com/your-username/file-optimizer.git"
DEPLOY_DIR="/opt/file-optimizer-staging"
BRANCH="develop"
PORT="8001"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() {
    echo -e "${BLUE}[STAGING]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Vérification des prérequis simplifiée
check_prerequisites() {
    log_info "Vérification des prérequis staging..."
    
    if ! command -v node &> /dev/null; then
        log_error "Node.js non installé"
        exit 1
    fi
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker non installé"
        exit 1
    fi
    
    if ! command -v git &> /dev/null; then
        log_error "Git non installé"
        exit 1
    fi
    
    log_success "Prérequis OK"
}

# Nettoyer l'environnement staging précédent
cleanup_previous() {
    log_info "Nettoyage environnement staging précédent..."
    
    if [ -d "$DEPLOY_DIR" ]; then
        cd "$DEPLOY_DIR"
        
        # Arrêter les conteneurs staging
        docker-compose -f docker-compose.dev.yml down 2>/dev/null || true
        
        # Nettoyer les volumes staging (optionnel)
        docker volume rm file-optimizer-staging_uploads_dev 2>/dev/null || true
        docker volume rm file-optimizer-staging_redis_data_dev 2>/dev/null || true
        
        log_info "Environnement précédent nettoyé"
    fi
}

# Mettre à jour le code
update_code() {
    log_info "Mise à jour du code depuis la branche $BRANCH..."
    
    if [ -d "$DEPLOY_DIR/.git" ]; then
        cd "$DEPLOY_DIR"
        git fetch origin --quiet
        git checkout "$BRANCH" --quiet
        git reset --hard "origin/$BRANCH" --quiet
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Code mis à jour (commit: $commit_hash)"
    else
        mkdir -p "$(dirname "$DEPLOY_DIR")"
        git clone -b "$BRANCH" "$REPO_URL" "$DEPLOY_DIR" --quiet
        cd "$DEPLOY_DIR"
        local commit_hash=$(git rev-parse --short HEAD)
        log_success "Repository cloné (commit: $commit_hash)"
    fi
}

# Configuration de l'environnement staging
setup_staging_environment() {
    log_info "Configuration environnement staging..."
    cd "$DEPLOY_DIR/backend"
    
    # Créer un .env spécifique au staging
    cat > .env << EOF
# Configuration Staging
NODE_ENV=staging
PORT=$PORT
LOG_LEVEL=debug

# Redis
REDIS_URL=redis://redis:6379

# Stockage
TEMP_DIR=/app/uploads
UPLOAD_MAX_SIZE=1073741824

# CORS permissif pour staging
CORS_ORIGIN=*

# Rate limiting désactivé en staging
SKIP_RATE_LIMIT=true

# Nettoyage plus fréquent
CLEANUP_INTERVAL=1800
FILE_RETENTION=3600

# Worker
WORKER_CONCURRENCY=1
JOB_TIMEOUT=900
EOF
    
    # Créer les répertoires
    mkdir -p uploads logs tmp
    chmod 755 uploads logs tmp
    
    log_success "Environnement staging configuré"
}

# Démarrer les services staging
start_staging_services() {
    log_info "Démarrage des services staging..."
    cd "$DEPLOY_DIR"
    
    # Modifier le docker-compose.dev.yml pour staging
    export COMPOSE_PROJECT_NAME=file-optimizer-staging
    export PORT=$PORT
    
    # Démarrer avec Docker Compose développement
    docker-compose -f docker-compose.dev.yml up -d
    
    log_info "Attente du démarrage des services..."
    sleep 20
}

# Tests de santé staging
run_staging_tests() {
    log_info "Tests de santé staging..."
    
    local max_attempts=20
    local attempt=1
    
    # Test de l'API
    while [ $attempt -le $max_attempts ]; do
        if curl -f "http://localhost:$PORT/api/health" >/dev/null 2>&1; then
            log_success "API staging opérationnelle sur le port $PORT"
            break
        else
            if [ $attempt -eq $max_attempts ]; then
                log_error "API staging non accessible après $max_attempts tentatives"
                
                # Afficher les logs pour diagnostic
                log_info "Logs des conteneurs staging:"
                docker-compose -f docker-compose.dev.yml logs --tail=20
                exit 1
            fi
            log_info "Tentative $attempt/$max_attempts..."
            sleep 3
            attempt=$((attempt + 1))
        fi
    done
    
    # Test de santé détaillé
    local health_response=$(curl -s "http://localhost:$PORT/api/health" 2>/dev/null)
    if echo "$health_response" | grep -q '"status":"ok"'; then
        log_success "Health check détaillé réussi"
        
        # Afficher quelques infos de la réponse
        echo "$health_response" | jq -r '.checks | to_entries[] | "\(.key): \(.value.status)"' 2>/dev/null || true
    else
        log_warn "Health check partiel"
    fi
    
    # Test d'upload simple
    test_upload_functionality
}

# Test d'upload simple pour validation
test_upload_functionality() {
    log_info "Test de fonctionnalité upload..."
    
    # Créer un fichier de test temporaire
    local test_file="/tmp/test-staging-$(date +%s).txt"
    echo "Test file for staging deployment" > "$test_file"
    
    # Tester l'upload
    local upload_response=$(curl -s -X POST \
        -F "file=@$test_file" \
        -F 'settings={"quality":80}' \
        "http://localhost:$PORT/api/upload" 2>/dev/null || echo "")
    
    if echo "$upload_response" | grep -q '"success":true'; then
        local job_id=$(echo "$upload_response" | jq -r '.jobId' 2>/dev/null || echo "")
        log_success "Upload test réussi (jobId: ${job_id:0:8}...)"
        
        # Test de récupération du statut
        if [ -n "$job_id" ]; then
            sleep 2
            local status_response=$(curl -s "http://localhost:$PORT/api/status/$job_id" 2>/dev/null || echo "")
            if echo "$status_response" | grep -q '"success":true'; then
                log_success "API status opérationnelle"
            fi
        fi
    else
        log_warn "Test upload échoué (peut être normal selon la configuration)"
    fi
    
    # Nettoyer
    rm -f "$test_file"
}

# Afficher les informations de staging
show_staging_info() {
    log_success "🎉 Déploiement staging terminé!"
    echo ""
    echo "📍 Informations staging:"
    echo "   Application: http://localhost:$PORT"
    echo "   Health check: http://localhost:$PORT/api/health"
    echo "   API Upload: http://localhost:$PORT/api/upload"
    echo "   Branche: $BRANCH"
    echo ""
    echo "📋 Commandes utiles staging:"
    echo "   Logs: docker-compose -f docker-compose.dev.yml logs -f"
    echo "   Status: docker-compose -f docker-compose.dev.yml ps"
    echo "   Stop: docker-compose -f docker-compose.dev.yml down"
    echo "   Restart: docker-compose -f docker-compose.dev.yml restart"
    echo ""
    echo "🧪 Tests rapides:"
    echo "   curl http://localhost:$PORT/api/health"
    echo "   curl http://localhost:$PORT/api/upload/info"
    echo ""
}

# Fonction principale
main() {
    log_info "Début du déploiement staging"
    echo "========================================"
    
    check_prerequisites
    cleanup_previous
    update_code
    setup_staging_environment
    start_staging_services
    run_staging_tests
    show_staging_info
    
    log_success "✨ Staging prêt pour les tests!"
}

# Gestion des erreurs
trap 'log_error "Erreur lors du déploiement staging ligne $LINENO"; exit 1' ERR

# Parse des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --branch)
            BRANCH="$2"
            shift 2
            ;;
        --port)
            PORT="$2"
            shift 2
            ;;
        --clean)
            log_info "Nettoyage complet demandé"
            docker-compose -f docker-compose.dev.yml down -v 2>/dev/null || true
            docker system prune -f >/dev/null 2>&1 || true
            shift
            ;;
        --help)
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  --branch BRANCH    Branche à déployer (default: develop)"
            echo "  --port PORT        Port d'écoute (default: 8001)" 
            echo "  --clean            Nettoyage complet avant déploiement"
            echo "  --help             Afficher cette aide"
            exit 0
            ;;
        *)
            log_warn "Option inconnue: $1"
            shift
            ;;
    esac
done

# Exécution
main "$@"


================================================
File: backend/scripts/health-check.sh
================================================
#!/bin/bash
# scripts/health-check.sh
# Script de vérification de santé complète du système

set -e

# Configuration
API_URL="${API_URL:-http://localhost:8000}"
VERBOSE="${1:-false}"
TIMEOUT=10
REDIS_HOST="${REDIS_HOST:-localhost}"
REDIS_PORT="${REDIS_PORT:-6379}"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Variables globales pour le résultat
OVERALL_STATUS=0
CHECKS_PERFORMED=0
CHECKS_PASSED=0

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[✓]${NC} $1"
    CHECKS_PASSED=$((CHECKS_PASSED + 1))
}

log_warn() {
    echo -e "${YELLOW}[⚠]${NC} $1"
}

log_error() {
    echo -e "${RED}[✗]${NC} $1"
    OVERALL_STATUS=1
}

log_check() {
    echo -e "${PURPLE}[CHECK]${NC} $1"
    CHECKS_PERFORMED=$((CHECKS_PERFORMED + 1))
}

# Vérifier l'API principale
check_api() {
    log_check "API principale"
    
    local response
    local http_code
    local response_time
    
    # Mesurer le temps de réponse
    local start_time=$(date +%s%N)
    response=$(curl -s -w "%{http_code}" --max-time $TIMEOUT "$API_URL/api/health" 2>/dev/null || echo "000")
    local end_time=$(date +%s%N)
    response_time=$(( (end_time - start_time) / 1000000 )) # en millisecondes
    
    http_code="${response: -3}"
    local body="${response%???}"
    
    if [ "$http_code" = "200" ]; then
        log_success "API opérationnelle (${response_time}ms)"
        
        # Analyser la réponse si verbose
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Response body:"
            echo "$body" | jq . 2>/dev/null || echo "   $body"
            
            # Extraire des métriques de la réponse
            local status=$(echo "$body" | jq -r '.status' 2>/dev/null || echo "unknown")
            local uptime=$(echo "$body" | jq -r '.uptime' 2>/dev/null || echo "unknown")
            echo "   Status: $status, Uptime: ${uptime}s"
        fi
        
        # Vérifier que le statut est "ok"
        if echo "$body" | grep -q '"status":"ok"'; then
            log_success "Health check interne: OK"
        else
            log_warn "Health check interne: État dégradé"
        fi
        
        return 0
    else
        log_error "API non opérationnelle (HTTP $http_code)"
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   URL testée: $API_URL/api/health"
            echo "   Réponse: $response"
        fi
        return 1
    fi
}

# Vérifier Redis
check_redis() {
    log_check "Redis"
    
    # Essayer avec redis-cli local d'abord
    if command -v redis-cli &> /dev/null; then
        if timeout $TIMEOUT redis-cli -h $REDIS_HOST -p $REDIS_PORT ping 2>/dev/null | grep -q "PONG"; then
            log_success "Redis opérationnel (redis-cli)"
            
            if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
                local redis_info=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT info server 2>/dev/null | head -5)
                echo "   Redis info:"
                echo "$redis_info" | sed 's/^/   /'
            fi
            return 0
        fi
    fi
    
    # Essayer avec Docker si redis-cli non disponible
    if command -v docker &> /dev/null; then
        if docker exec file-optimizer-redis redis-cli ping 2>/dev/null | grep -q "PONG"; then
            log_success "Redis opérationnel (Docker)"
            return 0
        fi
    fi
    
    # Essayer avec netcat pour tester la connectivité
    if command -v nc &> /dev/null; then
        if timeout $TIMEOUT nc -z $REDIS_HOST $REDIS_PORT 2>/dev/null; then
            log_warn "Redis port accessible mais ping échoué"
            return 1
        fi
    fi
    
    log_error "Redis non opérationnel"
    return 1
}

# Vérifier Docker
check_docker() {
    log_check "Services Docker"
    
    if ! command -v docker &> /dev/null; then
        log_warn "Docker non installé (normal si déploiement PM2)"
        return 0
    fi
    
    # Vérifier que Docker est en cours d'exécution
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker daemon non accessible"
        return 1
    fi
    
    # Vérifier les conteneurs file-optimizer
    local containers=$(docker ps --filter "name=file-optimizer" --format "{{.Names}}" 2>/dev/null || echo "")
    
    if [ -n "$containers" ]; then
        log_success "Conteneurs Docker actifs"
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Conteneurs trouvés:"
            echo "$containers" | sed 's/^/   - /'
            
            # Status détaillé des conteneurs
            docker ps --filter "name=file-optimizer" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | sed 's/^/   /'
        fi
        
        # Vérifier que les conteneurs sont "healthy" si health check configuré
        local unhealthy=$(docker ps --filter "name=file-optimizer" --filter "health=unhealthy" --format "{{.Names}}" 2>/dev/null || echo "")
        if [ -n "$unhealthy" ]; then
            log_warn "Conteneurs en mauvaise santé: $unhealthy"
            return 1
        fi
        
        return 0
    else
        log_warn "Aucun conteneur file-optimizer actif"
        return 1
    fi
}

# Vérifier l'espace disque
check_disk_space() {
    log_check "Espace disque"
    
    # Vérifier le répertoire de déploiement
    local deploy_paths=("/opt/file-optimizer" "/opt/file-optimizer-staging" ".")
    
    for path in "${deploy_paths[@]}"; do
        if [ -d "$path" ]; then
            local usage=$(df "$path" 2>/dev/null | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
            local available=$(df -h "$path" 2>/dev/null | awk 'NR==2 {print $4}' || echo "unknown")
            
            if [ "$usage" -lt 80 ]; then
                log_success "Espace disque OK: ${usage}% utilisé ($available disponible) - $path"
            elif [ "$usage" -lt 90 ]; then
                log_warn "Espace disque élevé: ${usage}% utilisé ($available disponible) - $path"
            else
                log_error "Espace disque critique: ${usage}% utilisé ($available disponible) - $path"
                return 1
            fi
            
            if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
                echo "   Détails $path:"
                df -h "$path" | sed 's/^/   /'
            fi
            break
        fi
    done
    
    return 0
}

# Vérifier la mémoire système
check_memory() {
    log_check "Utilisation mémoire"
    
    if [ -f /proc/meminfo ]; then
        local total_mem=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        local available_mem=$(grep MemAvailable /proc/meminfo | awk '{print $2}' 2>/dev/null || grep MemFree /proc/meminfo | awk '{print $2}')
        local used_mem=$((total_mem - available_mem))
        local usage_percent=$((used_mem * 100 / total_mem))
        
        # Convertir en GB pour affichage
        local total_gb=$((total_mem / 1024 / 1024))
        local used_gb=$((used_mem / 1024 / 1024))
        local available_gb=$((available_mem / 1024 / 1024))
        
        if [ "$usage_percent" -lt 80 ]; then
            log_success "Mémoire OK: ${usage_percent}% utilisé (${used_gb}G/${total_gb}G)"
        elif [ "$usage_percent" -lt 90 ]; then
            log_warn "Mémoire élevée: ${usage_percent}% utilisé (${used_gb}G/${total_gb}G)"
        else
            log_error "Mémoire critique: ${usage_percent}% utilisé (${used_gb}G/${total_gb}G)"
            return 1
        fi
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Total: ${total_gb}G, Utilisé: ${used_gb}G, Disponible: ${available_gb}G"
        fi
    else
        log_warn "Impossible de lire /proc/meminfo"
    fi
    
    return 0
}

# Vérifier les processus PM2
check_pm2() {
    log_check "Processus PM2"
    
    if ! command -v pm2 &> /dev/null; then
        log_warn "PM2 non installé (normal si déploiement Docker)"
        return 0
    fi
    
    local pm2_list=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name | test("file-optimizer")) | "\(.name): \(.pm2_env.status)"' 2>/dev/null || echo "")
    
    if [ -n "$pm2_list" ]; then
        local all_online=true
        while IFS= read -r line; do
            if echo "$line" | grep -q ": online"; then
                log_success "PM2 process: $line"
            else
                log_error "PM2 process: $line"
                all_online=false
            fi
        done <<< "$pm2_list"
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   PM2 status détaillé:"
            pm2 status | grep -E "(file-optimizer|Process)" | sed 's/^/   /'
        fi
        
        if $all_online; then
            return 0
        else
            return 1
        fi
    else
        log_warn "Aucun processus file-optimizer dans PM2"
        return 1
    fi
}

# Vérifier les endpoints critiques
check_endpoints() {
    log_check "Endpoints critiques"
    
    local endpoints=(
        "/api/health"
        "/api/upload/info"
        "/"
    )
    
    local failed_endpoints=()
    
    for endpoint in "${endpoints[@]}"; do
        local url="$API_URL$endpoint"
        local http_code=$(curl -s -w "%{http_code}" --max-time $TIMEOUT "$url" -o /dev/null 2>/dev/null || echo "000")
        
        if [ "$http_code" = "200" ]; then
            log_success "Endpoint OK: $endpoint (HTTP $http_code)"
        else
            log_error "Endpoint KO: $endpoint (HTTP $http_code)"
            failed_endpoints+=("$endpoint")
        fi
    done
    
    if [ ${#failed_endpoints[@]} -eq 0 ]; then
        return 0
    else
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Endpoints en échec: ${failed_endpoints[*]}"
        fi
        return 1
    fi
}

# Test de performance simple
check_performance() {
    log_check "Performance API"
    
    local total_time=0
    local requests=5
    local failed=0
    
    for i in $(seq 1 $requests); do
        local start_time=$(date +%s%N)
        local http_code=$(curl -s -w "%{http_code}" --max-time $TIMEOUT "$API_URL/api/health" -o /dev/null 2>/dev/null || echo "000")
        local end_time=$(date +%s%N)
        local response_time=$(( (end_time - start_time) / 1000000 ))
        
        if [ "$http_code" = "200" ]; then
            total_time=$((total_time + response_time))
        else
            failed=$((failed + 1))
        fi
    done
    
    if [ $failed -lt $((requests / 2)) ]; then
        local avg_time=$((total_time / (requests - failed)))
        if [ $avg_time -lt 1000 ]; then
            log_success "Performance OK: ${avg_time}ms moyenne ($failed échecs sur $requests)"
        elif [ $avg_time -lt 3000 ]; then
            log_warn "Performance lente: ${avg_time}ms moyenne ($failed échecs sur $requests)"
        else
            log_error "Performance critique: ${avg_time}ms moyenne ($failed échecs sur $requests)"
            return 1
        fi
        
        if [ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ]; then
            echo "   Tests: $requests, Échecs: $failed, Temps moyen: ${avg_time}ms"
        fi
        return 0
    else
        log_error "Performance critique: trop d'échecs ($failed sur $requests)"
        return 1
    fi
}

# Afficher le résumé final
show_summary() {
    echo ""
    echo "========================================"
    echo "📊 RÉSUMÉ DU HEALTH CHECK"
    echo "========================================"
    echo "Checks effectués: $CHECKS_PERFORMED"
    echo "Checks réussis: $CHECKS_PASSED"
    echo "Checks échoués: $((CHECKS_PERFORMED - CHECKS_PASSED))"
    echo ""
    
    if [ $OVERALL_STATUS -eq 0 ]; then
        log_success "🎉 Tous les services sont opérationnels"
        echo ""
        echo "✅ Le système File Optimizer fonctionne correctement"
        echo "📍 Application accessible sur: $API_URL"
    else
        log_error "⚠️  Certains services ont des problèmes"
        echo ""
        echo "❌ Des problèmes ont été détectés"
        echo "🔧 Vérifiez les logs et corrigez les erreurs signalées"
        echo ""
        echo "🆘 Commandes de diagnostic utiles:"
        echo "   - Logs Docker: docker-compose logs -f"
        echo "   - Logs PM2: pm2 logs"
        echo "   - Status conteneurs: docker ps"
        echo "   - Test manuel API: curl $API_URL/api/health"
    fi
    
    echo "========================================"
}

# Fonction principale
main() {
    echo "🏥 File Optimizer Health Check"
    echo "======================================="
    echo "URL testée: $API_URL"
    echo "Mode: $([ "$VERBOSE" = "--verbose" ] || [ "$VERBOSE" = "-v" ] && echo "Verbose" || echo "Standard")"
    echo "======================================="
    echo ""
    
    # Exécuter tous les checks
    check_api || true
    check_redis || true
    check_docker || true
    check_disk_space || true
    check_memory || true
    check_pm2 || true
    check_endpoints || true
    check_performance || true
    
    # Afficher le résumé
    show_summary
    
    # Retourner le code d'erreur global
    exit $OVERALL_STATUS
}

# Parse des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose|-v)
            VERBOSE="--verbose"
            shift
            ;;
        --url)
            API_URL="$2"
            shift 2
            ;;
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --redis-host)
            REDIS_HOST="$2"
            shift 2
            ;;
        --redis-port)
            REDIS_PORT="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --verbose, -v         Mode verbeux avec détails"
            echo "  --url URL             URL de l'API (default: http://localhost:8000)"
            echo "  --timeout SECONDS     Timeout des requêtes (default: 10)"
            echo "  --redis-host HOST     Host Redis (default: localhost)"
            echo "  --redis-port PORT     Port Redis (default: 6379)"
            echo "  --help, -h            Afficher cette aide"
            echo ""
            echo "Exemples:"
            echo "  $0                    Health check standard"
            echo "  $0 --verbose          Health check détaillé"
            echo "  $0 --url http://localhost:8001  Test staging"
            echo ""
            exit 0
            ;;
        *)
            log_warn "Option inconnue: $1"
            shift
            ;;
    esac
done

# Exécution
main "$@"


================================================
File: backend/src/server.js
================================================
// backend/src/server.js
require('dotenv').config();

const express = require('express');
const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const compression = require('compression');
const morgan = require('morgan');
const { Server } = require('socket.io');

// Services et utilitaires
const logger = require('./utils/logger');
const { getRedisClient } = require('./utils/redis');
const { cleanQueue } = require('./services/queueService');
const FileService = require('./services/fileService');

// Routes
const apiRoutes = require('./routes');

/**
 * Classe principale du serveur
 */
class FileOptimizerServer {
    constructor() {
        this.app = express();
        this.server = null;
        this.io = null;
        this.redis = null;
        this.isShuttingDown = false;
        this.connections = new Set();
        this.startTime = Date.now();
    }

    /**
     * Initialiser le serveur
     */
    async init() {
        try {
            logger.info('🚀 Initialisation du serveur File Optimizer');

            // Vérifier les prérequis
            await this.checkPrerequisites();

            // Configuration de l'application Express
            await this.configureApp();

            // Configuration des routes
            this.configureRoutes();

            // Création du serveur HTTP/HTTPS
            await this.createServer();

            // Configuration WebSocket
            this.configureWebSocket();

            // Gestion gracieuse de l'arrêt
            this.setupGracefulShutdown();

            // Nettoyage périodique
            this.setupPeriodicCleanup();

            logger.info('✅ Serveur initialisé avec succès');
        } catch (error) {
            logger.error('❌ Erreur initialisation serveur:', error);
            throw error;
        }
    }

    /**
     * Vérifier les prérequis système
     */
    async checkPrerequisites() {
        logger.info('🔍 Vérification des prérequis...');

        try {
            // Vérifier Redis
            this.redis = await getRedisClient();
            await this.redis.ping();
            logger.info('✅ Redis connecté');

            // Vérifier les répertoires
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            await FileService.ensureDirectoryExists(tempDir);
            await FileService.ensureDirectoryExists(path.join(tempDir, 'output'));
            logger.info('✅ Répertoires créés');

            // Vérifier Sharp
            const sharp = require('sharp');
            const sharpVersion = sharp.versions;
            logger.info(`✅ Sharp v${sharpVersion.sharp} disponible`);

            // Vérifier FFmpeg (optionnel)
            if (process.env.FFMPEG_PATH) {
                const { exec } = require('child_process');
                const { promisify } = require('util');
                const execAsync = promisify(exec);
                
                try {
                    await execAsync(`${process.env.FFMPEG_PATH} -version`);
                    logger.info('✅ FFmpeg disponible');
                } catch (error) {
                    logger.warn('⚠️ FFmpeg non disponible (traitement vidéo/audio limité)');
                }
            }

        } catch (error) {
            logger.error('❌ Prérequis non satisfaits:', error);
            throw new Error(`Prérequis manquants: ${error.message}`);
        }
    }

    /**
     * Configuration de l'application Express
     */
    async configureApp() {
        logger.info('⚙️ Configuration Express...');

        // Middleware de base
        this.app.use(compression({
            threshold: 1024,
            level: 6,
            filter: (req, res) => {
                // Ne pas compresser les streams de fichiers
                if (req.path.includes('/download/')) return false;
                return compression.filter(req, res);
            }
        }));

        // Body parsing avec limites
        this.app.use(express.json({ 
            limit: process.env.BODY_LIMIT || '10mb',
            verify: (req, res, buf) => {
                // Vérification intégrité JSON
                req.rawBody = buf;
            }
        }));

        this.app.use(express.urlencoded({ 
            extended: true, 
            limit: process.env.BODY_LIMIT || '10mb' 
        }));

        // Trust proxy si nécessaire (pour rate limiting)
        if (process.env.TRUST_PROXY === 'true') {
            this.app.set('trust proxy', true);
        }

        // Logging HTTP avec Morgan
        const morganFormat = process.env.NODE_ENV === 'production' 
            ? 'combined' 
            : 'dev';
        
        this.app.use(morgan(morganFormat, { 
            stream: logger.stream(),
            skip: (req) => {
                // Skip health checks pour éviter spam
                return req.path.startsWith('/api/health');
            }
        }));

        // Middleware pour injecter Socket.IO dans les requêtes
        this.app.use((req, res, next) => {
            req.io = this.io;
            req.startTime = Date.now();
            next();
        });

        // Gestion des connexions pour graceful shutdown
        this.app.use((req, res, next) => {
            this.connections.add(res);
            res.on('close', () => this.connections.delete(res));
            next();
        });

        // Headers de sécurité supplémentaires
        this.app.use((req, res, next) => {
            res.setHeader('X-Powered-By', 'File Optimizer v2.0.0');
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.setHeader('X-Frame-Options', 'DENY');
            res.setHeader('X-XSS-Protection', '1; mode=block');
            
            if (process.env.HTTPS_ENABLED === 'true') {
                res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
            }
            
            next();
        });

        logger.info('✅ Express configuré');
    }

    /**
     * Configuration des routes
     */
    configureRoutes() {
        logger.info('🛣️ Configuration des routes...');

        // Route racine avec informations serveur
        this.app.get('/', (req, res) => {
            const uptime = Math.floor((Date.now() - this.startTime) / 1000);
            
            res.json({
                success: true,
                service: 'File Optimizer API',
                version: process.env.npm_package_version || '2.0.0',
                environment: process.env.NODE_ENV || 'development',
                uptime: uptime,
                uptimeFormatted: this.formatUptime(uptime),
                timestamp: new Date().toISOString(),
                endpoints: {
                    api: '/api',
                    health: '/api/health',
                    docs: '/docs',
                    metrics: '/api/health/metrics'
                },
                features: {
                    upload: true,
                    websockets: true,
                    compression: true,
                    monitoring: true,
                    authentication: process.env.AUTH_ENABLED === 'true'
                }
            });
        });

        // Routes API
        this.app.use('/api', apiRoutes);

        // Servir la documentation statique (si elle existe)
        const docsPath = path.join(__dirname, '../docs');
        if (fs.existsSync(docsPath)) {
            this.app.use('/docs', express.static(docsPath));
        }

        // Servir le frontend (si il existe)
        const frontendPath = path.join(__dirname, '../public');
        if (fs.existsSync(frontendPath)) {
            this.app.use('/app', express.static(frontendPath));
            
            // SPA fallback
            this.app.get('/app/*', (req, res) => {
                res.sendFile(path.join(frontendPath, 'index.html'));
            });
        }

        // Route pour les téléchargements directs (alias)
        this.app.get('/download/:jobId', (req, res) => {
            res.redirect(307, `/api/download/${req.params.jobId}`);
        });

        // Middleware 404 pour toutes les routes non trouvées
        this.app.use('*', (req, res) => {
            logger.warn('Route non trouvée', {
                method: req.method,
                path: req.originalUrl,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });

            res.status(404).json({
                success: false,
                error: 'Route non trouvée',
                path: req.originalUrl,
                suggestion: 'Consultez /api pour les endpoints disponibles'
            });
        });

        // Gestionnaire d'erreurs global
        this.app.use((error, req, res, next) => {
            const duration = Date.now() - req.startTime;
            
            logger.error('Erreur non gérée:', error, {
                method: req.method,
                path: req.path,
                ip: req.ip,
                userAgent: req.get('User-Agent'),
                duration: `${duration}ms`
            });

            // Ne pas exposer les détails d'erreur en production
            const isDev = process.env.NODE_ENV === 'development';
            
            res.status(error.status || 500).json({
                success: false,
                error: 'Erreur interne du serveur',
                message: isDev ? error.message : undefined,
                stack: isDev ? error.stack : undefined,
                timestamp: new Date().toISOString()
            });
        });

        logger.info('✅ Routes configurées');
    }

    /**
     * Créer le serveur HTTP ou HTTPS
     */
    async createServer() {
        logger.info('🌐 Création du serveur...');

        const port = parseInt(process.env.PORT) || 8000;
        const host = process.env.HOST || '0.0.0.0';

        if (process.env.HTTPS_ENABLED === 'true') {
            // Serveur HTTPS
            const sslOptions = {
                key: fs.readFileSync(process.env.SSL_KEY_PATH),
                cert: fs.readFileSync(process.env.SSL_CERT_PATH)
            };
            
            this.server = https.createServer(sslOptions, this.app);
            logger.info(`🔒 Serveur HTTPS configuré`);
        } else {
            // Serveur HTTP
            this.server = http.createServer(this.app);
        }

        // Gestion des connexions pour graceful shutdown
        this.server.on('connection', (connection) => {
            this.connections.add(connection);
            connection.on('close', () => this.connections.delete(connection));
        });

        // Démarrer l'écoute
        await new Promise((resolve, reject) => {
            this.server.listen(port, host, (error) => {
                if (error) {
                    reject(error);
                } else {
                    const protocol = process.env.HTTPS_ENABLED === 'true' ? 'https' : 'http';
                    logger.info(`🚀 Serveur démarré sur ${protocol}://${host}:${port}`);
                    resolve();
                }
            });
        });
    }

    /**
     * Configuration WebSocket avec Socket.IO
     */
    configureWebSocket() {
        logger.info('🔌 Configuration WebSocket...');

        this.io = new Server(this.server, {
            cors: {
                origin: (process.env.CORS_ORIGIN || 'http://localhost:3000').split(','),
                methods: ['GET', 'POST'],
                credentials: true
            },
            transports: ['websocket', 'polling'],
            pingTimeout: 60000,
            pingInterval: 25000
        });

        // Middleware d'authentification WebSocket (optionnel)
        if (process.env.AUTH_ENABLED === 'true') {
            this.io.use((socket, next) => {
                const token = socket.handshake.auth.token || socket.handshake.query.token;
                
                if (!token || token !== process.env.API_KEY) {
                    logger.security('WebSocket connexion non autorisée', {
                        socketId: socket.id,
                        ip: socket.handshake.address
                    });
                    return next(new Error('Authentication failed'));
                }
                
                next();
            });
        }

        // Gestion des connexions WebSocket
        this.io.on('connection', (socket) => {
            logger.info('WebSocket connecté', {
                socketId: socket.id,
                ip: socket.handshake.address,
                userAgent: socket.handshake.headers['user-agent']
            });

            // Rejoindre une room pour un job spécifique
            socket.on('join-job', (jobId) => {
                if (this.isValidJobId(jobId)) {
                    socket.join(`job-${jobId}`);
                    socket.emit('joined-job', { jobId });
                    logger.debug(`Socket ${socket.id} rejoint job ${jobId}`);
                } else {
                    socket.emit('error', { message: 'Job ID invalide' });
                }
            });

            // Quitter une room de job
            socket.on('leave-job', (jobId) => {
                socket.leave(`job-${jobId}`);
                socket.emit('left-job', { jobId });
                logger.debug(`Socket ${socket.id} quitte job ${jobId}`);
            });

            // Demander le statut d'un job
            socket.on('get-status', async (jobId) => {
                try {
                    const JobService = require('./services/jobService');
                    const job = await JobService.getJob(jobId);
                    
                    if (job) {
                        socket.emit('job-status', {
                            jobId,
                            status: job.status,
                            progress: job.progress || 0,
                            timestamp: new Date().toISOString()
                        });
                    } else {
                        socket.emit('error', { 
                            message: 'Job non trouvé',
                            jobId 
                        });
                    }
                } catch (error) {
                    logger.error('Erreur get-status WebSocket:', error);
                    socket.emit('error', { 
                        message: 'Erreur récupération statut' 
                    });
                }
            });

            // Gestion déconnexion
            socket.on('disconnect', (reason) => {
                logger.info('WebSocket déconnecté', {
                    socketId: socket.id,
                    reason,
                    ip: socket.handshake.address
                });
            });

            // Gestion des erreurs
            socket.on('error', (error) => {
                logger.error('Erreur WebSocket:', error, {
                    socketId: socket.id,
                    ip: socket.handshake.address
                });
            });
        });

        // Méthodes utilitaires pour émettre des événements
        this.io.emitJobUpdate = (jobId, data) => {
            this.io.to(`job-${jobId}`).emit('job-update', {
                jobId,
                ...data,
                timestamp: new Date().toISOString()
            });
        };

        this.io.emitJobProgress = (jobId, progress) => {
            this.io.to(`job-${jobId}`).emit('job-progress', {
                jobId,
                progress,
                timestamp: new Date().toISOString()
            });
        };

        this.io.emitJobCompleted = (jobId, result) => {
            this.io.to(`job-${jobId}`).emit('job-completed', {
                jobId,
                ...result,
                timestamp: new Date().toISOString()
            });
        };

        this.io.emitJobError = (jobId, error) => {
            this.io.to(`job-${jobId}`).emit('job-error', {
                jobId,
                error: error.message || error,
                timestamp: new Date().toISOString()
            });
        };

        logger.info('✅ WebSocket configuré');
    }

    /**
     * Configuration de l'arrêt gracieux
     */
    setupGracefulShutdown() {
        logger.info('🛡️ Configuration arrêt gracieux...');

        const shutdown = async (signal) => {
            if (this.isShuttingDown) return;
            this.isShuttingDown = true;

            logger.info(`🛑 Arrêt gracieux démarré (${signal})`);

            try {
                // 1. Arrêter d'accepter de nouvelles connexions
                this.server.close();

                // 2. Notifier les clients WebSocket
                if (this.io) {
                    this.io.emit('server-shutdown', {
                        message: 'Serveur en cours d\'arrêt',
                        timestamp: new Date().toISOString()
                    });

                    // Fermer les connexions WebSocket
                    setTimeout(() => {
                        this.io.close();
                    }, 1000);
                }

                // 3. Attendre la fin des requêtes en cours (max 30s)
                await this.waitForConnectionsToClose(30000);

                // 4. Nettoyer la queue
                await cleanQueue();

                // 5. Fermer Redis
                if (this.redis) {
                    await this.redis.quit();
                }

                logger.info('✅ Arrêt gracieux terminé');
                process.exit(0);

            } catch (error) {
                logger.error('❌ Erreur arrêt gracieux:', error);
                process.exit(1);
            }
        };

        // Signaux d'arrêt
        process.on('SIGTERM', () => shutdown('SIGTERM'));
        process.on('SIGINT', () => shutdown('SIGINT'));
        process.on('SIGUSR2', () => shutdown('SIGUSR2')); // Nodemon

        // Erreurs non gérées
        process.on('uncaughtException', (error) => {
            logger.error('Exception non gérée:', error);
            shutdown('uncaughtException');
        });

        process.on('unhandledRejection', (reason, promise) => {
            logger.error('Rejection non gérée:', reason, { promise });
            shutdown('unhandledRejection');
        });

        logger.info('✅ Arrêt gracieux configuré');
    }

    /**
     * Configuration du nettoyage périodique
     */
    setupPeriodicCleanup() {
        logger.info('🧹 Configuration nettoyage périodique...');

        const cleanupInterval = parseInt(process.env.CLEANUP_INTERVAL) || 3600; // 1h par défaut

        setInterval(async () => {
            try {
                logger.info('🧹 Nettoyage périodique démarré');

                // Nettoyer les fichiers temporaires
                const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
                const maxAge = parseInt(process.env.FILE_RETENTION) || 86400; // 24h par défaut
                
                const cleaned = await FileService.cleanupTempFiles(tempDir, maxAge * 1000);
                if (cleaned.count > 0) {
                    logger.info(`🧹 ${cleaned.count} fichiers nettoyés (${FileService.formatFileSize(cleaned.size)} libérés)`);
                }

                // Nettoyer les jobs expirés
                const JobService = require('./services/jobService');
                const jobsCleaned = await JobService.cleanupExpiredJobs();
                if (jobsCleaned > 0) {
                    logger.info(`🧹 ${jobsCleaned} jobs expirés supprimés`);
                }

                // Nettoyer la queue
                await cleanQueue();

                logger.info('✅ Nettoyage périodique terminé');

            } catch (error) {
                logger.error('❌ Erreur nettoyage périodique:', error);
            }
        }, cleanupInterval * 1000);

        logger.info(`✅ Nettoyage configuré (intervalle: ${cleanupInterval}s)`);
    }

    /**
     * Attendre la fermeture des connexions
     */
    async waitForConnectionsToClose(timeout = 30000) {
        return new Promise((resolve) => {
            const startTime = Date.now();

            const checkConnections = () => {
                if (this.connections.size === 0) {
                    logger.info('✅ Toutes les connexions fermées');
                    resolve();
                } else if (Date.now() - startTime >= timeout) {
                    logger.warn(`⚠️ Timeout atteint, fermeture forcée (${this.connections.size} connexions restantes)`);
                    // Fermer les connexions restantes
                    for (const connection of this.connections) {
                        connection.destroy();
                    }
                    resolve();
                } else {
                    setTimeout(checkConnections, 100);
                }
            };

            checkConnections();
        });
    }

    /**
     * Valider un ID de job
     */
    isValidJobId(jobId) {
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(jobId);
    }

    /**
     * Formater la durée d'uptime
     */
    formatUptime(seconds) {
        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (days > 0) {
            return `${days}j ${hours}h ${minutes}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes}m ${secs}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${secs}s`;
        } else {
            return `${secs}s`;
        }
    }

    /**
     * Obtenir les statistiques du serveur
     */
    getServerStats() {
        const uptime = Math.floor((Date.now() - this.startTime) / 1000);
        const memUsage = process.memoryUsage();

        return {
            uptime,
            uptimeFormatted: this.formatUptime(uptime),
            connections: this.connections.size,
            memory: {
                rss: memUsage.rss,
                heapTotal: memUsage.heapTotal,
                heapUsed: memUsage.heapUsed,
                external: memUsage.external
            },
            websocket: {
                connected: this.io ? this.io.engine.clientsCount : 0
            },
            process: {
                pid: process.pid,
                platform: process.platform,
                nodeVersion: process.version
            }
        };
    }
}

/**
 * Fonction principale de démarrage
 */
async function main() {
    try {
        logger.info('🎯 File Optimizer Server v2.0.0');
        logger.info(`📍 Environnement: ${process.env.NODE_ENV || 'development'}`);
        logger.info(`🔧 Node.js: ${process.version}`);
        logger.info(`📂 Répertoire: ${process.cwd()}`);

        const server = new FileOptimizerServer();
        await server.init();

        // Exposer les stats serveur
        global.getServerStats = () => server.getServerStats();

        logger.info('🎉 File Optimizer Server démarré avec succès !');
        logger.info('📖 Documentation API: http://localhost:8000/docs');
        logger.info('🏥 Health check: http://localhost:8000/api/health');

    } catch (error) {
        logger.error('💥 Échec démarrage serveur:', error);
        process.exit(1);
    }
}

// Démarrer le serveur si ce fichier est exécuté directement
if (require.main === module) {
    main();
}

module.exports = { FileOptimizerServer, main };



================================================
File: backend/src/routes/download.js
================================================
// backend/src/routes/download.js
const express = require('express');
const fs = require('fs');
const path = require('path');
const rateLimit = require('express-rate-limit');

const JobService = require('../services/jobService');
const FileService = require('../services/fileService');
const { ValidationService, validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * Rate limiting pour les téléchargements
 */
const downloadRateLimit = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: parseInt(process.env.DOWNLOAD_RATE_LIMIT) || 20, // 20 téléchargements par minute
    message: {
        success: false,
        error: 'Trop de téléchargements, veuillez attendre'
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Rate limit par IP
        return req.ip;
    },
    skip: (req) => {
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    },
    onLimitReached: (req) => {
        logger.security('Rate limit download atteint', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            jobId: req.params.jobId
        });
    }
});

/**
 * Middleware de validation d'accès au téléchargement
 */
const validateDownloadAccess = async (req, res, next) => {
    try {
        const { jobId } = req.params;
        
        // Vérifier que le job existe
        const job = await JobService.getJob(jobId);
        if (!job) {
            return res.status(404).json({
                success: false,
                error: 'Job non trouvé'
            });
        }

        // Vérifier que le job est terminé
        if (job.status !== 'completed') {
            return res.status(400).json({
                success: false,
                error: 'Le fichier n\'est pas encore prêt',
                status: job.status,
                progress: job.progress || 0
            });
        }

        // Vérifier que le fichier de sortie existe
        if (!job.outputPath) {
            return res.status(500).json({
                success: false,
                error: 'Chemin de fichier manquant'
            });
        }

        const fileStats = await FileService.getFileStats(job.outputPath);
        if (!fileStats) {
            logger.error(`Fichier de sortie introuvable: ${job.outputPath}`, { jobId });
            return res.status(404).json({
                success: false,
                error: 'Fichier non trouvé sur le serveur'
            });
        }

        // Ajouter les informations à la requête
        req.job = job;
        req.fileStats = fileStats;
        
        next();

    } catch (error) {
        logger.error('Erreur validation accès download:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
};

/**
 * GET /api/download/:jobId
 * Télécharger le fichier traité
 */
router.get('/:jobId',
    downloadRateLimit,
    validateRequest.jobId,
    validateDownloadAccess,
    async (req, res) => {
        const { jobId } = req.params;
        const { job, fileStats } = req;
        
        const downloadLogger = logger.withContext({
            jobId,
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });

        try {
            downloadLogger.info('Téléchargement démarré', {
                filename: job.originalName,
                outputPath: job.outputPath,
                size: fileStats.size
            });

            // Déterminer le nom de fichier pour le téléchargement
            const originalExt = path.extname(job.originalName);
            const baseName = path.basename(job.originalName, originalExt);
            
            // Ajouter un suffixe pour indiquer la compression
            let downloadFilename;
            if (job.compressionRatio && job.compressionRatio > 0) {
                downloadFilename = `${baseName}_optimized${originalExt}`;
            } else {
                downloadFilename = job.originalName;
            }

            // Nettoyer le nom de fichier pour le téléchargement
            downloadFilename = ValidationService.sanitizeFilename(downloadFilename) || 'file';

            // Déterminer le type MIME
            const mimeType = require('mime-types').lookup(job.outputPath) || 'application/octet-stream';

            // Configurer les headers de réponse
            res.setHeader('Content-Type', mimeType);
            res.setHeader('Content-Length', fileStats.size);
            res.setHeader('Content-Disposition', `attachment; filename="${downloadFilename}"`);
            res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
            res.setHeader('Pragma', 'no-cache');
            res.setHeader('Expires', '0');
            
            // Headers personnalisés avec informations sur le traitement
            res.setHeader('X-Original-Size', job.size);
            res.setHeader('X-Compressed-Size', job.compressedSize || job.size);
            res.setHeader('X-Compression-Ratio', job.compressionRatio || 0);
            res.setHeader('X-File-Type', job.type);
            res.setHeader('X-Processing-Time', new Date(job.updatedAt) - new Date(job.createdAt));

            // Support du Range (téléchargement partiel)
            const range = req.headers.range;
            
            if (range) {
                const ranges = parseRange(fileStats.size, range);
                
                if (ranges && ranges.length === 1 && ranges[0].start < fileStats.size) {
                    const { start, end } = ranges[0];
                    const contentLength = (end - start) + 1;
                    
                    res.status(206); // Partial Content
                    res.setHeader('Content-Range', `bytes ${start}-${end}/${fileStats.size}`);
                    res.setHeader('Content-Length', contentLength);
                    res.setHeader('Accept-Ranges', 'bytes');
                    
                    // Stream partiel
                    const stream = fs.createReadStream(job.outputPath, { start, end });
                    streamFile(stream, res, downloadLogger, job, true);
                } else {
                    // Range invalide
                    res.status(416); // Range Not Satisfiable
                    res.setHeader('Content-Range', `bytes */${fileStats.size}`);
                    res.end();
                }
            } else {
                // Téléchargement complet
                res.setHeader('Accept-Ranges', 'bytes');
                const stream = fs.createReadStream(job.outputPath);
                streamFile(stream, res, downloadLogger, job, false);
            }

        } catch (error) {
            downloadLogger.error('Erreur téléchargement:', error);
            
            if (!res.headersSent) {
                res.status(500).json({
                    success: false,
                    error: 'Erreur téléchargement fichier'
                });
            }
        }
    }
);

/**
 * GET /api/download/:jobId/info
 * Informations sur le fichier à télécharger
 */
router.get('/:jobId/info',
    downloadRateLimit,
    validateRequest.jobId,
    validateDownloadAccess,
    async (req, res) => {
        try {
            const { job, fileStats } = req;
            
            // Calculer les métriques
            const compressionRatio = parseInt(job.compressionRatio) || 0;
            const savedBytes = parseInt(job.size) - parseInt(job.compressedSize || job.size);
            const processingTime = new Date(job.updatedAt) - new Date(job.createdAt);

            res.json({
                success: true,
                file: {
                    jobId: job.id,
                    originalName: job.originalName,
                    type: job.type,
                    originalSize: parseInt(job.size),
                    originalSizeFormatted: FileService.formatFileSize(parseInt(job.size)),
                    compressedSize: parseInt(job.compressedSize || job.size),
                    compressedSizeFormatted: FileService.formatFileSize(parseInt(job.compressedSize || job.size)),
                    compressionRatio,
                    savedBytes,
                    savedBytesFormatted: FileService.formatFileSize(savedBytes),
                    processingTime: Math.floor(processingTime / 1000), // en secondes
                    mimeType: require('mime-types').lookup(job.outputPath) || 'application/octet-stream',
                    settings: job.settings,
                    createdAt: job.createdAt,
                    completedAt: job.updatedAt
                }
            });

        } catch (error) {
            logger.error('Erreur info download:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur récupération informations'
            });
        }
    }
);

/**
 * GET /api/download/:jobId/preview
 * Prévisualisation du fichier (pour les images)
 */
router.get('/:jobId/preview',
    downloadRateLimit,
    validateRequest.jobId,
    validateDownloadAccess,
    async (req, res) => {
        try {
            const { job } = req;
            
            // Vérifier que c'est une image
            if (job.type !== 'image') {
                return res.status(400).json({
                    success: false,
                    error: 'Prévisualisation disponible uniquement pour les images'
                });
            }

            const { size = 'medium' } = req.query;
            const maxSizes = {
                small: 150,
                medium: 300,
                large: 600
            };

            const maxSize = maxSizes[size] || 300;

            // Générer une vignette temporaire
            const ImageService = require('../services/imageService');
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            const thumbnailPath = path.join(tempDir, `preview_${job.id}_${maxSize}.jpg`);

            // Vérifier si la vignette existe déjà
            let thumbExists = await FileService.getFileStats(thumbnailPath);
            
            if (!thumbExists) {
                // Créer la vignette
                await ImageService.createThumbnail(job.outputPath, thumbnailPath, maxSize);
                thumbExists = await FileService.getFileStats(thumbnailPath);
            }

            if (!thumbExists) {
                return res.status(500).json({
                    success: false,
                    error: 'Impossible de générer la prévisualisation'
                });
            }

            // Servir la vignette
            res.setHeader('Content-Type', 'image/jpeg');
            res.setHeader('Content-Length', thumbExists.size);
            res.setHeader('Cache-Control', 'public, max-age=3600'); // Cache 1h
            
            const stream = fs.createReadStream(thumbnailPath);
            stream.pipe(res);

            // Nettoyer la vignette après envoi (optionnel)
            stream.on('end', () => {
                setTimeout(() => {
                    FileService.deleteFile(thumbnailPath).catch(() => {});
                }, 5000); // Attendre 5s avant suppression
            });

        } catch (error) {
            logger.error('Erreur preview:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur génération prévisualisation'
            });
        }
    }
);

/**
 * Fonction pour streamer un fichier avec gestion d'erreurs
 */
function streamFile(stream, res, downloadLogger, job, isPartial = false) {
    let bytesStreamed = 0;
    const startTime = Date.now();

    stream.on('data', (chunk) => {
        bytesStreamed += chunk.length;
    });

    stream.on('end', () => {
        const duration = Date.now() - startTime;
        const speed = bytesStreamed / (duration / 1000); // bytes/sec
        
        downloadLogger.info('Téléchargement terminé', {
            bytesStreamed,
            duration,
            speedBps: Math.round(speed),
            speedFormatted: FileService.formatFileSize(speed) + '/s',
            isPartial
        });

        downloadLogger.metric('download_completed', 1, 'count', {
            jobId: job.id,
            fileType: job.type,
            size: bytesStreamed
        });
    });

    stream.on('error', (error) => {
        downloadLogger.error('Erreur stream fichier:', error);
        
        if (!res.headersSent) {
            res.status(500).json({
                success: false,
                error: 'Erreur lecture fichier'
            });
        }
    });

    res.on('close', () => {
        // Client a fermé la connexion
        downloadLogger.info('Connexion fermée par le client', {
            bytesStreamed,
            isComplete: res.writableEnded
        });
        
        // Nettoyer le stream
        if (stream.readable) {
            stream.destroy();
        }
    });

    // Pipe le stream vers la réponse
    stream.pipe(res);
}

/**
 * Parser les headers Range pour le download partiel
 */
function parseRange(size, rangeHeader) {
    if (!rangeHeader || !rangeHeader.startsWith('bytes=')) {
        return null;
    }

    const ranges = [];
    const rangeSpecs = rangeHeader.substring(6).split(',');

    for (const rangeSpec of rangeSpecs) {
        const rangeParts = rangeSpec.trim().split('-');
        
        if (rangeParts.length !== 2) continue;

        let start = parseInt(rangeParts[0]) || 0;
        let end = parseInt(rangeParts[1]) || (size - 1);

        // Validation
        if (start < 0) start = 0;
        if (end >= size) end = size - 1;
        if (start > end) continue;

        ranges.push({ start, end });
    }

    return ranges.length > 0 ? ranges : null;
}

module.exports = router;


================================================
File: backend/src/routes/health.js
================================================
// backend/src/routes/health.js
const express = require('express');
const os = require('os');
const fs = require('fs').promises;
const path = require('path');

const { healthCheck: redisHealthCheck, getMetrics: getRedisMetrics } = require('../utils/redis');
const { getQueueStats } = require('../services/queueService');
const JobService = require('../services/jobService');
const FileService = require('../services/fileService');
const { validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * GET /api/health
 * Vérification de santé basique
 */
router.get('/', async (req, res) => {
    try {
        const startTime = Date.now();
        
        // Tests de base
        const checks = {
            server: await checkServer(),
            redis: await checkRedis(),
            filesystem: await checkFilesystem(),
            memory: await checkMemory()
        };

        // Déterminer le statut global
        const allHealthy = Object.values(checks).every(check => check.status === 'ok');
        const responseTime = Date.now() - startTime;

        const response = {
            status: allHealthy ? 'ok' : 'error',
            timestamp: new Date().toISOString(),
            responseTime: `${responseTime}ms`,
            checks,
            version: process.env.npm_package_version || '2.0.0',
            uptime: Math.floor(process.uptime()),
            environment: process.env.NODE_ENV || 'development'
        };

        // Log si problème détecté
        if (!allHealthy) {
            logger.warn('Health check failed', { checks, responseTime });
        }

        res.status(allHealthy ? 200 : 503).json(response);

    } catch (error) {
        logger.error('Erreur health check:', error);
        res.status(503).json({
            status: 'error',
            timestamp: new Date().toISOString(),
            error: 'Health check failed',
            message: error.message
        });
    }
});

/**
 * GET /api/health/detailed
 * Vérification de santé détaillée
 */
router.get('/detailed',
    validateRequest.healthCheck,
    async (req, res) => {
        try {
            const { includeMetrics, includeRedis, includeQueue } = req.query;
            const startTime = Date.now();

            // Tests détaillés
            const checks = {
                server: await checkServerDetailed(),
                redis: includeRedis ? await checkRedisDetailed() : await checkRedis(),
                filesystem: await checkFilesystemDetailed(),
                memory: await checkMemoryDetailed(),
                queue: includeQueue ? await checkQueue() : null,
                dependencies: await checkDependencies()
            };

            // Métriques optionnelles
            let metrics = null;
            if (includeMetrics) {
                metrics = await collectMetrics();
            }

            // Supprimer les checks null
            Object.keys(checks).forEach(key => {
                if (checks[key] === null) delete checks[key];
            });

            const allHealthy = Object.values(checks).every(check => check.status === 'ok');
            const responseTime = Date.now() - startTime;

            const response = {
                status: allHealthy ? 'ok' : 'error',
                timestamp: new Date().toISOString(),
                responseTime: `${responseTime}ms`,
                checks,
                system: {
                    platform: os.platform(),
                    arch: os.arch(),
                    nodeVersion: process.version,
                    uptime: Math.floor(process.uptime()),
                    pid: process.pid
                }
            };

            if (metrics) {
                response.metrics = metrics;
            }

            res.status(allHealthy ? 200 : 503).json(response);

        } catch (error) {
            logger.error('Erreur health check détaillé:', error);
            res.status(503).json({
                status: 'error',
                timestamp: new Date().toISOString(),
                error: 'Detailed health check failed',
                message: error.message
            });
        }
    }
);

/**
 * GET /api/health/readiness
 * Vérification de disponibilité (pour Kubernetes)
 */
router.get('/readiness', async (req, res) => {
    try {
        const checks = {
            redis: await checkRedis(),
            filesystem: await checkFilesystem()
        };

        const isReady = Object.values(checks).every(check => check.status === 'ok');

        res.status(isReady ? 200 : 503).json({
            status: isReady ? 'ready' : 'not ready',
            timestamp: new Date().toISOString(),
            checks
        });

    } catch (error) {
        res.status(503).json({
            status: 'not ready',
            timestamp: new Date().toISOString(),
            error: error.message
        });
    }
});

/**
 * GET /api/health/liveness
 * Vérification de vivacité (pour Kubernetes)
 */
router.get('/liveness', (req, res) => {
    // Test simple : le serveur répond
    res.status(200).json({
        status: 'alive',
        timestamp: new Date().toISOString(),
        uptime: Math.floor(process.uptime())
    });
});

/**
 * Vérifications de santé individuelles
 */

async function checkServer() {
    try {
        return {
            status: 'ok',
            uptime: Math.floor(process.uptime()),
            pid: process.pid,
            nodeVersion: process.version
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkServerDetailed() {
    try {
        const loadAvg = os.loadavg();
        const cpuCount = os.cpus().length;
        
        return {
            status: 'ok',
            uptime: Math.floor(process.uptime()),
            pid: process.pid,
            nodeVersion: process.version,
            platform: os.platform(),
            arch: os.arch(),
            cpuCount,
            loadAverage: {
                '1min': loadAvg[0].toFixed(2),
                '5min': loadAvg[1].toFixed(2),
                '15min': loadAvg[2].toFixed(2)
            },
            hostname: os.hostname()
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkRedis() {
    try {
        const health = await redisHealthCheck();
        return health;
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkRedisDetailed() {
    try {
        const health = await redisHealthCheck();
        
        if (health.status === 'ok') {
            const metrics = await getRedisMetrics();
            return {
                ...health,
                metrics
            };
        }
        
        return health;
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkFilesystem() {
    try {
        const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
        
        // Tester l'écriture
        const testFile = path.join(tempDir, `health-check-${Date.now()}.tmp`);
        await fs.writeFile(testFile, 'health check');
        await fs.unlink(testFile);
        
        return {
            status: 'ok',
            tempDir,
            writable: true
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message,
            writable: false
        };
    }
}

async function checkFilesystemDetailed() {
    try {
        const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
        
        // Tester l'écriture
        const testFile = path.join(tempDir, `health-check-${Date.now()}.tmp`);
        const testData = 'health check test data';
        
        const writeStart = Date.now();
        await fs.writeFile(testFile, testData);
        const writeTime = Date.now() - writeStart;
        
        const readStart = Date.now();
        const readData = await fs.readFile(testFile, 'utf8');
        const readTime = Date.now() - readStart;
        
        await fs.unlink(testFile);
        
        // Obtenir l'usage disque
        const dirStats = await FileService.getDirectorySize(tempDir);
        
        return {
            status: 'ok',
            tempDir,
            writable: true,
            readable: true,
            writeTime: `${writeTime}ms`,
            readTime: `${readTime}ms`,
            dataIntegrity: readData === testData,
            diskUsage: {
                files: dirStats.fileCount,
                size: dirStats.size,
                sizeFormatted: dirStats.sizeFormatted
            }
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message,
            writable: false
        };
    }
}

async function checkMemory() {
    try {
        const memUsage = process.memoryUsage();
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        const usedMem = totalMem - freeMem;
        
        // Seuils d'alerte (configurable)
        const memoryThreshold = 0.9; // 90%
        const heapThreshold = 0.8; // 80%
        
        const memoryUsagePercent = usedMem / totalMem;
        const heapUsagePercent = memUsage.heapUsed / memUsage.heapTotal;
        
        let status = 'ok';
        const warnings = [];
        
        if (memoryUsagePercent > memoryThreshold) {
            status = 'warning';
            warnings.push('High system memory usage');
        }
        
        if (heapUsagePercent > heapThreshold) {
            status = 'warning';
            warnings.push('High heap usage');
        }
        
        return {
            status,
            warnings: warnings.length > 0 ? warnings : undefined,
            system: {
                total: FileService.formatFileSize(totalMem),
                free: FileService.formatFileSize(freeMem),
                used: FileService.formatFileSize(usedMem),
                usagePercent: Math.round(memoryUsagePercent * 100)
            }
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkMemoryDetailed() {
    try {
        const memUsage = process.memoryUsage();
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        const usedMem = totalMem - freeMem;
        
        const memoryUsagePercent = usedMem / totalMem;
        const heapUsagePercent = memUsage.heapUsed / memUsage.heapTotal;
        
        let status = 'ok';
        const warnings = [];
        
        if (memoryUsagePercent > 0.9) {
            status = 'warning';
            warnings.push('High system memory usage');
        }
        
        if (heapUsagePercent > 0.8) {
            status = 'warning';
            warnings.push('High heap usage');
        }
        
        return {
            status,
            warnings: warnings.length > 0 ? warnings : undefined,
            system: {
                total: FileService.formatFileSize(totalMem),
                free: FileService.formatFileSize(freeMem),
                used: FileService.formatFileSize(usedMem),
                usagePercent: Math.round(memoryUsagePercent * 100)
            },
            process: {
                heapTotal: FileService.formatFileSize(memUsage.heapTotal),
                heapUsed: FileService.formatFileSize(memUsage.heapUsed),
                heapUsagePercent: Math.round(heapUsagePercent * 100),
                external: FileService.formatFileSize(memUsage.external),
                arrayBuffers: FileService.formatFileSize(memUsage.arrayBuffers || 0),
                rss: FileService.formatFileSize(memUsage.rss)
            }
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkQueue() {
    try {
        const queueStats = await getQueueStats();
        
        if (!queueStats) {
            return {
                status: 'error',
                error: 'Unable to get queue stats'
            };
        }
        
        // Vérifier s'il y a trop de jobs en échec
        const failureRate = queueStats.total > 0 ? 
            (queueStats.failed / queueStats.total) * 100 : 0;
        
        let status = 'ok';
        const warnings = [];
        
        if (failureRate > 20) { // Plus de 20% d'échecs
            status = 'warning';
            warnings.push('High job failure rate');
        }
        
        if (queueStats.waiting > 100) { // Plus de 100 jobs en attente
            status = 'warning';
            warnings.push('High number of waiting jobs');
        }
        
        return {
            status,
            warnings: warnings.length > 0 ? warnings : undefined,
            stats: queueStats,
            failureRate: Math.round(failureRate)
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function checkDependencies() {
    try {
        const dependencies = {};
        
        // Vérifier Sharp
        try {
            const sharp = require('sharp');
            const sharpVersion = sharp.versions;
            dependencies.sharp = {
                status: 'ok',
                version: sharpVersion
            };
        } catch (error) {
            dependencies.sharp = {
                status: 'error',
                error: 'Sharp not available'
            };
        }
        
        // Vérifier FFmpeg (si configuré)
        const ffmpegPath = process.env.FFMPEG_PATH;
        if (ffmpegPath) {
            try {
                const { exec } = require('child_process');
                const { promisify } = require('util');
                const execAsync = promisify(exec);
                
                const { stdout } = await execAsync(`${ffmpegPath} -version`);
                const versionMatch = stdout.match(/ffmpeg version ([^\s]+)/);
                
                dependencies.ffmpeg = {
                    status: 'ok',
                    path: ffmpegPath,
                    version: versionMatch ? versionMatch[1] : 'unknown'
                };
            } catch (error) {
                dependencies.ffmpeg = {
                    status: 'error',
                    path: ffmpegPath,
                    error: 'FFmpeg not available or invalid path'
                };
            }
        }
        
        // Déterminer le statut global
        const allOk = Object.values(dependencies).every(dep => dep.status === 'ok');
        
        return {
            status: allOk ? 'ok' : 'warning',
            dependencies
        };
    } catch (error) {
        return {
            status: 'error',
            error: error.message
        };
    }
}

async function collectMetrics() {
    try {
        // Métriques des jobs
        const jobStats = await JobService.getJobStats();
        
        // Métriques de la queue
        const queueStats = await getQueueStats();
        
        // Métriques système
        const memUsage = process.memoryUsage();
        const cpuUsage = process.cpuUsage();
        
        // Métriques de performance récentes
        const recentJobs = await JobService.getAllJobs(100);
        const last24h = new Date(Date.now() - 24 * 60 * 60 * 1000);
        const jobs24h = recentJobs.filter(job => 
            new Date(job.createdAt) >= last24h
        );
        
        const completedJobs24h = jobs24h.filter(job => job.status === 'completed');
        
        // Calculs de performance
        const totalProcessed24h = completedJobs24h.reduce((sum, job) => 
            sum + (parseInt(job.size) || 0), 0
        );
        
        const avgProcessingTime = completedJobs24h.length > 0 ?
            completedJobs24h.reduce((sum, job) => {
                const processingTime = new Date(job.updatedAt) - new Date(job.createdAt);
                return sum + processingTime;
            }, 0) / completedJobs24h.length : 0;
        
        return {
            jobs: jobStats,
            queue: queueStats,
            performance: {
                jobs24h: jobs24h.length,
                completed24h: completedJobs24h.length,
                totalProcessed24h,
                totalProcessed24hFormatted: FileService.formatFileSize(totalProcessed24h),
                avgProcessingTime: Math.round(avgProcessingTime / 1000), // en secondes
                throughput: Math.round(completedJobs24h.length / 24 * 100) / 100 // jobs/heure
            },
            system: {
                memory: {
                    heapUsed: memUsage.heapUsed,
                    heapTotal: memUsage.heapTotal,
                    external: memUsage.external,
                    rss: memUsage.rss
                },
                cpu: {
                    user: cpuUsage.user,
                    system: cpuUsage.system
                },
                uptime: process.uptime(),
                loadAverage: os.loadavg()
            }
        };
    } catch (error) {
        logger.error('Erreur collecte métriques:', error);
        return {
            error: 'Unable to collect metrics',
            message: error.message
        };
    }
}

/**
 * GET /api/health/metrics
 * Métriques système pour monitoring externe (Prometheus, etc.)
 */
router.get('/metrics', async (req, res) => {
    try {
        const metrics = await collectMetrics();
        
        // Format Prometheus (optionnel)
        if (req.get('Accept') === 'text/plain') {
            const prometheusMetrics = convertToPrometheusFormat(metrics);
            res.setHeader('Content-Type', 'text/plain; version=0.0.4');
            res.send(prometheusMetrics);
        } else {
            res.json({
                success: true,
                timestamp: new Date().toISOString(),
                metrics
            });
        }
    } catch (error) {
        logger.error('Erreur métriques:', error);
        res.status(500).json({
            success: false,
            error: 'Unable to collect metrics'
        });
    }
});

/**
 * Convertir les métriques au format Prometheus
 */
function convertToPrometheusFormat(metrics) {
    let output = '';
    
    // Métriques des jobs
    if (metrics.jobs) {
        output += `# HELP file_optimizer_jobs_total Total number of jobs by status\n`;
        output += `# TYPE file_optimizer_jobs_total counter\n`;
        Object.entries(metrics.jobs).forEach(([status, count]) => {
            if (typeof count === 'number') {
                output += `file_optimizer_jobs_total{status="${status}"} ${count}\n`;
            }
        });
    }
    
    // Métriques de performance
    if (metrics.performance) {
        output += `# HELP file_optimizer_throughput_jobs_per_hour Jobs processed per hour\n`;
        output += `# TYPE file_optimizer_throughput_jobs_per_hour gauge\n`;
        output += `file_optimizer_throughput_jobs_per_hour ${metrics.performance.throughput || 0}\n`;
        
        output += `# HELP file_optimizer_avg_processing_time_seconds Average processing time in seconds\n`;
        output += `# TYPE file_optimizer_avg_processing_time_seconds gauge\n`;
        output += `file_optimizer_avg_processing_time_seconds ${metrics.performance.avgProcessingTime || 0}\n`;
    }
    
    // Métriques système
    if (metrics.system && metrics.system.memory) {
        output += `# HELP process_resident_memory_bytes Resident memory size in bytes\n`;
        output += `# TYPE process_resident_memory_bytes gauge\n`;
        output += `process_resident_memory_bytes ${metrics.system.memory.rss}\n`;
        
        output += `# HELP nodejs_heap_size_used_bytes Process heap space used in bytes\n`;
        output += `# TYPE nodejs_heap_size_used_bytes gauge\n`;
        output += `nodejs_heap_size_used_bytes ${metrics.system.memory.heapUsed}\n`;
    }
    
    return output;
}

module.exports = router;


================================================
File: backend/src/routes/index.js
================================================
// backend/src/routes/index.js
const express = require('express');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const cors = require('cors');

const uploadRoutes = require('./upload');
const statusRoutes = require('./status');
const downloadRoutes = require('./download');
const processRoutes = require('./process');
const healthRoutes = require('./health');

const logger = require('../utils/logger');

const router = express.Router();

/**
 * Configuration CORS
 */
const corsOptions = {
    origin: function (origin, callback) {
        // Permettre les requêtes sans origin (apps mobiles, Postman, etc.)
        if (!origin) return callback(null, true);
        
        const allowedOrigins = (process.env.CORS_ORIGIN || 'http://localhost:3000').split(',');
        
        if (allowedOrigins.indexOf(origin) !== -1 || allowedOrigins.includes('*')) {
            callback(null, true);
        } else {
            logger.security('CORS origin bloqué', { origin, allowedOrigins });
            callback(new Error('Non autorisé par CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
    exposedHeaders: ['X-Total-Count', 'X-Original-Size', 'X-Compressed-Size', 'X-Compression-Ratio']
};

/**
 * Rate limiting global
 */
const globalRateLimit = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: parseInt(process.env.RATE_LIMIT) || 100, // 100 requêtes par 15min
    message: {
        success: false,
        error: 'Trop de requêtes, veuillez ralentir',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Utiliser l'IP comme clé
        return req.ip;
    },
    skip: (req) => {
        // Skip rate limiting pour les health checks
        if (req.path.startsWith('/api/health')) return true;
        
        // Skip en développement si configuré
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    },
    onLimitReached: (req) => {
        logger.security('Rate limit global atteint', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            path: req.path,
            method: req.method
        });
    }
});

/**
 * Middleware de logging des requêtes
 */
const requestLogger = (req, res, next) => {
    const start = Date.now();
    
    // Log de la requête entrante
    logger.http('Requête entrante', {
        method: req.method,
        path: req.path,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        contentLength: req.get('Content-Length'),
        contentType: req.get('Content-Type')
    });

    // Override de res.end pour logger la réponse
    const originalEnd = res.end;
    res.end = function(...args) {
        const duration = Date.now() - start;
        
        logger.http('Réponse envoyée', {
            method: req.method,
            path: req.path,
            statusCode: res.statusCode,
            duration: `${duration}ms`,
            contentLength: res.get('Content-Length'),
            ip: req.ip
        });

        // Métriques de performance
        if (duration > 5000) { // Plus de 5 secondes
            logger.performance('Requête lente détectée', duration, {
                method: req.method,
                path: req.path,
                statusCode: res.statusCode
            });
        }

        originalEnd.apply(this, args);
    };

    next();
};

/**
 * Middleware de validation des headers
 */
const validateHeaders = (req, res, next) => {
    // Vérifier Content-Type pour les requêtes POST/PUT
    if (['POST', 'PUT'].includes(req.method)) {
        const contentType = req.get('Content-Type');
        
        if (req.path.includes('/upload')) {
            // Les uploads doivent être multipart/form-data
            if (!contentType || !contentType.includes('multipart/form-data')) {
                logger.security('Content-Type invalide pour upload', {
                    contentType,
                    path: req.path,
                    ip: req.ip
                });
                return res.status(400).json({
                    success: false,
                    error: 'Content-Type multipart/form-data requis pour les uploads'
                });
            }
        } else if (!req.path.includes('/upload')) {
            // Les autres requêtes doivent être JSON
            if (contentType && !contentType.includes('application/json')) {
                logger.security('Content-Type invalide', {
                    contentType,
                    path: req.path,
                    ip: req.ip
                });
                return res.status(400).json({
                    success: false,
                    error: 'Content-Type application/json requis'
                });
            }
        }
    }

    next();
};

/**
 * Middleware d'authentification (optionnel)
 */
const authenticate = (req, res, next) => {
    // Si l'authentification est désactivée, passer
    if (process.env.AUTH_ENABLED !== 'true') {
        return next();
    }

    const apiKey = req.get('Authorization') || req.query.api_key;
    const expectedKey = process.env.API_KEY;

    if (!expectedKey) {
        logger.error('API_KEY non configurée mais AUTH_ENABLED=true');
        return res.status(500).json({
            success: false,
            error: 'Configuration d\'authentification incorrecte'
        });
    }

    if (!apiKey || apiKey.replace('Bearer ', '') !== expectedKey) {
        logger.security('Tentative d\'accès non autorisé', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            path: req.path,
            providedKey: apiKey ? 'présente' : 'absente'
        });
        
        return res.status(401).json({
            success: false,
            error: 'Clé API invalide ou manquante'
        });
    }

    next();
};

/**
 * Middleware de gestion d'erreurs
 */
const errorHandler = (error, req, res, next) => {
    logger.error('Erreur non gérée dans les routes:', error, {
        method: req.method,
        path: req.path,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });

    // Erreurs spécifiques
    if (error.code === 'LIMIT_FILE_SIZE') {
        return res.status(413).json({
            success: false,
            error: 'Fichier trop volumineux'
        });
    }

    if (error.message === 'Non autorisé par CORS') {
        return res.status(403).json({
            success: false,
            error: 'Origine non autorisée'
        });
    }

    // Erreur générique
    res.status(500).json({
        success: false,
        error: 'Erreur interne du serveur',
        message: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
};

/**
 * Configuration des middlewares globaux
 */
router.use(helmet({
    crossOriginEmbedderPolicy: false, // Nécessaire pour les uploads
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "blob:"],
            connectSrc: ["'self'", "ws:", "wss:"]
        }
    }
}));

router.use(cors(corsOptions));
router.use(globalRateLimit);
router.use(requestLogger);
router.use(validateHeaders);
router.use(authenticate);

/**
 * Routes principales
 */

// Health checks (sans authentification pour les load balancers)
router.use('/health', healthRoutes);

// API v1
router.use('/upload', uploadRoutes);
router.use('/status', statusRoutes);
router.use('/download', downloadRoutes);
router.use('/process', processRoutes);

/**
 * Route d'information générale
 */
router.get('/', (req, res) => {
    res.json({
        success: true,
        message: 'API Optimiseur de Fichiers Multimédia',
        version: process.env.npm_package_version || '2.0.0',
        endpoints: {
            upload: '/api/upload',
            status: '/api/status',
            download: '/api/download',
            process: '/api/process',
            health: '/api/health'
        },
        documentation: 'https://github.com/your-username/file-optimizer/wiki/API',
        support: 'https://github.com/your-username/file-optimizer/issues',
        timestamp: new Date().toISOString()
    });
});

/**
 * Route 404 pour les endpoints non trouvés
 */
router.use('*', (req, res) => {
    logger.warn('Endpoint non trouvé', {
        method: req.method,
        path: req.originalUrl,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });

    res.status(404).json({
        success: false,
        error: 'Endpoint non trouvé',
        path: req.originalUrl,
        availableEndpoints: [
            '/api/upload',
            '/api/status',
            '/api/download',
            '/api/process',
            '/api/health'
        ]
    });
});

/**
 * Gestionnaire d'erreurs global
 */
router.use(errorHandler);

module.exports = router;


================================================
File: backend/src/routes/process.js
================================================
// backend/src/routes/process.js
const express = require('express');
const rateLimit = require('express-rate-limit');

const JobService = require('../services/jobService');
const ProcessingService = require('../services/processingService');
const { addJobToQueue, getQueueStats } = require('../services/queueService');
const { ValidationService, validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * Rate limiting pour les routes de traitement
 */
const processRateLimit = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: parseInt(process.env.PROCESS_RATE_LIMIT) || 30, // 30 requêtes par minute
    message: {
        success: false,
        error: 'Trop de requêtes de traitement'
    },
    standardHeaders: true,
    legacyHeaders: false,
    skip: (req) => {
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    }
});

/**
 * POST /api/process/:jobId
 * Démarrer le traitement d'un job spécifique
 */
router.post('/:jobId',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            const { priority = 'normal', settings = {} } = req.body;
            
            const requestLogger = logger.withContext({ 
                jobId, 
                ip: req.ip,
                action: 'manual_process'
            });

            requestLogger.info('Demande traitement manuel', { priority, settings });

            // Récupérer le job
            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouvé'
                });
            }

            // Vérifier l'état du job
            if (job.status === 'processing') {
                return res.status(400).json({
                    success: false,
                    error: 'Job déjà en cours de traitement',
                    status: job.status,
                    progress: job.progress
                });
            }

            if (job.status === 'completed') {
                return res.status(400).json({
                    success: false,
                    error: 'Job déjà terminé',
                    status: job.status
                });
            }

            // Valider les nouveaux paramètres si fournis
            if (Object.keys(settings).length > 0) {
                const fileType = job.type;
                const currentSettings = { ...job.settings, ...settings };
                
                const validation = ValidationService.validateSettings(fileType, currentSettings);
                if (!validation.isValid) {
                    return res.status(400).json({
                        success: false,
                        error: 'Paramètres invalides',
                        details: validation.errors
                    });
                }

                // Mettre à jour les paramètres du job
                await JobService.updateJob(jobId, {
                    settings: validation.validatedSettings,
                    status: 'uploaded',
                    progress: 0,
                    error: null,
                    updatedAt: new Date().toISOString()
                });
                
                job.settings = validation.validatedSettings;
            }

            // Calculer la priorité
            let queuePriority = 5; // Normal
            switch (priority) {
                case 'low':
                    queuePriority = 1;
                    break;
                case 'high':
                    queuePriority = 10;
                    break;
                case 'urgent':
                    queuePriority = 15;
                    break;
            }

            // Ajouter à la queue avec priorité
            await addJobToQueue(job, { priority: queuePriority });
            await JobService.updateJob(jobId, { status: 'queued' });

            requestLogger.job(jobId, 'Job ajouté à la queue manuellement', { priority });

            // Estimer le temps de traitement
            const estimatedTime = ProcessingService.estimateProcessingTime(job.type, job.size);

            res.json({
                success: true,
                message: 'Job ajouté à la queue de traitement',
                jobId,
                status: 'queued',
                priority,
                estimatedTime,
                queuePosition: await getQueuePosition(jobId)
            });

        } catch (error) {
            logger.error(`Erreur traitement job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/batch
 * Traitement par lot de plusieurs jobs
 */
router.post('/batch',
    processRateLimit,
    async (req, res) => {
        try {
            const { jobIds, settings = {}, priority = 'normal' } = req.body;
            
            if (!Array.isArray(jobIds) || jobIds.length === 0) {
                return res.status(400).json({
                    success: false,
                    error: 'Liste de jobs requise'
                });
            }

            if (jobIds.length > 10) {
                return res.status(400).json({
                    success: false,
                    error: 'Maximum 10 jobs par batch'
                });
            }

            const requestLogger = logger.withContext({ 
                ip: req.ip,
                action: 'batch_process',
                jobCount: jobIds.length
            });

            requestLogger.info('Demande traitement batch', { jobIds, priority });

            const results = [];
            const errors = [];

            // Traiter chaque job
            for (const jobId of jobIds) {
                try {
                    // Validation de l'ID
                    const validation = ValidationService.validateJobId(jobId);
                    if (!validation.isValid) {
                        errors.push({
                            jobId,
                            error: 'ID de job invalide'
                        });
                        continue;
                    }

                    // Récupérer le job
                    const job = await JobService.getJob(jobId);
                    if (!job) {
                        errors.push({
                            jobId,
                            error: 'Job non trouvé'
                        });
                        continue;
                    }

                    // Vérifier l'état
                    if (['processing', 'completed'].includes(job.status)) {
                        errors.push({
                            jobId,
                            error: `Job ${job.status}`,
                            status: job.status
                        });
                        continue;
                    }

                    // Appliquer les paramètres globaux si fournis
                    if (Object.keys(settings).length > 0) {
                        const currentSettings = { ...job.settings, ...settings };
                        const settingsValidation = ValidationService.validateSettings(job.type, currentSettings);
                        
                        if (settingsValidation.isValid) {
                            await JobService.updateJob(jobId, {
                                settings: settingsValidation.validatedSettings,
                                status: 'uploaded',
                                progress: 0
                            });
                        }
                    }

                    // Ajouter à la queue
                    await addJobToQueue(job, { priority: priority === 'high' ? 10 : 5 });
                    await JobService.updateJob(jobId, { status: 'queued' });

                    results.push({
                        jobId,
                        status: 'queued',
                        message: 'Ajouté à la queue'
                    });

                } catch (error) {
                    errors.push({
                        jobId,
                        error: error.message
                    });
                }
            }

            requestLogger.info('Traitement batch terminé', {
                processed: results.length,
                errors: errors.length
            });

            res.json({
                success: true,
                message: `${results.length} jobs traités`,
                results,
                errors: errors.length > 0 ? errors : undefined,
                summary: {
                    total: jobIds.length,
                    processed: results.length,
                    failed: errors.length
                }
            });

        } catch (error) {
            logger.error('Erreur traitement batch:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/:jobId/pause
 * Mettre en pause un job en cours (si possible)
 */
router.post('/:jobId/pause',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande pause job ${jobId}`, { ip: req.ip });

            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouvé'
                });
            }

            if (job.status !== 'processing') {
                return res.status(400).json({
                    success: false,
                    error: 'Seuls les jobs en cours peuvent être mis en pause',
                    status: job.status
                });
            }

            // Note: La mise en pause dépend de l'implémentation du worker
            // Pour l'instant, on marque le job comme "paused" dans Redis
            await JobService.updateJob(jobId, {
                status: 'paused',
                pausedAt: new Date().toISOString()
            });

            res.json({
                success: true,
                message: 'Job mis en pause',
                jobId,
                status: 'paused'
            });

        } catch (error) {
            logger.error(`Erreur pause job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/:jobId/resume
 * Reprendre un job en pause
 */
router.post('/:jobId/resume',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande reprise job ${jobId}`, { ip: req.ip });

            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouvé'
                });
            }

            if (job.status !== 'paused') {
                return res.status(400).json({
                    success: false,
                    error: 'Seuls les jobs en pause peuvent être repris',
                    status: job.status
                });
            }

            // Remettre en queue
            await addJobToQueue(job);
            await JobService.updateJob(jobId, {
                status: 'queued',
                pausedAt: null,
                resumedAt: new Date().toISOString()
            });

            res.json({
                success: true,
                message: 'Job repris',
                jobId,
                status: 'queued'
            });

        } catch (error) {
            logger.error(`Erreur reprise job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/:jobId/cancel
 * Annuler un job en attente ou en cours
 */
router.post('/:jobId/cancel',
    processRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande annulation job ${jobId}`, { ip: req.ip });

            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouvé'
                });
            }

            if (job.status === 'completed') {
                return res.status(400).json({
                    success: false,
                    error: 'Job déjà terminé, impossible d\'annuler',
                    status: job.status
                });
            }

            if (job.status === 'cancelled') {
                return res.status(400).json({
                    success: false,
                    error: 'Job déjà annulé',
                    status: job.status
                });
            }

            // Marquer comme annulé
            await JobService.updateJob(jobId, {
                status: 'cancelled',
                cancelledAt: new Date().toISOString(),
                progress: 0
            });

            // TODO: Si en cours de traitement, envoyer signal d'arrêt au worker

            logger.job(jobId, 'Job annulé');

            res.json({
                success: true,
                message: 'Job annulé',
                jobId,
                status: 'cancelled'
            });

        } catch (error) {
            logger.error(`Erreur annulation job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/process/queue
 * Informations sur la queue de traitement
 */
router.get('/queue', processRateLimit, async (req, res) => {
    try {
        const queueStats = await getQueueStats();
        
        if (!queueStats) {
            return res.status(500).json({
                success: false,
                error: 'Impossible de récupérer les stats de la queue'
            });
        }

        // Récupérer quelques jobs récents en attente
        const recentJobs = await JobService.getAllJobs(20);
        const queuedJobs = recentJobs
            .filter(job => job.status === 'queued')
            .slice(0, 10)
            .map(job => ({
                id: job.id,
                originalName: job.originalName,
                type: job.type,
                size: parseInt(job.size),
                sizeFormatted: require('../services/fileService').formatFileSize(parseInt(job.size)),
                createdAt: job.createdAt,
                estimatedTime: ProcessingService.estimateProcessingTime(job.type, parseInt(job.size))
            }));

        res.json({
            success: true,
            queue: {
                stats: queueStats,
                jobs: queuedJobs,
                timestamp: new Date().toISOString()
            }
        });

    } catch (error) {
        logger.error('Erreur récupération queue:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * GET /api/process/settings/:type
 * Obtenir les paramètres par défaut pour un type de fichier
 */
router.get('/settings/:type',
    processRateLimit,
    async (req, res) => {
        try {
            const { type } = req.params;
            
            // Valider le type
            const validTypes = ['image', 'video', 'audio', 'document'];
            if (!validTypes.includes(type)) {
                return res.status(400).json({
                    success: false,
                    error: 'Type de fichier invalide',
                    validTypes
                });
            }

            const defaultSettings = ProcessingService.getDefaultSettings(type);
            
            // Ajouter des informations sur les options disponibles
            const settingsInfo = getSettingsInfo(type);

            res.json({
                success: true,
                type,
                defaultSettings,
                options: settingsInfo,
                description: getTypeDescription(type)
            });

        } catch (error) {
            logger.error('Erreur récupération paramètres:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/process/validate-settings
 * Valider des paramètres sans créer de job
 */
router.post('/validate-settings',
    processRateLimit,
    async (req, res) => {
        try {
            const { type, settings } = req.body;
            
            if (!type || !settings) {
                return res.status(400).json({
                    success: false,
                    error: 'Type et paramètres requis'
                });
            }

            const validation = ValidationService.validateSettings(type, settings);
            
            if (validation.isValid) {
                res.json({
                    success: true,
                    message: 'Paramètres valides',
                    validatedSettings: validation.validatedSettings
                });
            } else {
                res.status(400).json({
                    success: false,
                    error: 'Paramètres invalides',
                    details: validation.errors
                });
            }

        } catch (error) {
            logger.error('Erreur validation paramètres:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/process/estimate
 * Estimation du temps de traitement
 */
router.get('/estimate',
    processRateLimit,
    async (req, res) => {
        try {
            const { type, size } = req.query;
            
            if (!type || !size) {
                return res.status(400).json({
                    success: false,
                    error: 'Type et taille requis'
                });
            }

            const fileSize = parseInt(size);
            if (isNaN(fileSize) || fileSize <= 0) {
                return res.status(400).json({
                    success: false,
                    error: 'Taille invalide'
                });
            }

            const estimatedTime = ProcessingService.estimateProcessingTime(type, fileSize);
            const queueStats = await getQueueStats();
            
            // Estimation de l'attente en queue
            let queueWaitTime = 0;
            if (queueStats && queueStats.waiting > 0) {
                // Approximation: 30 secondes par job en attente
                queueWaitTime = queueStats.waiting * 30;
            }

            const totalTime = estimatedTime + queueWaitTime;

            res.json({
                success: true,
                estimation: {
                    processingTime: estimatedTime,
                    queueWaitTime,
                    totalTime,
                    queuePosition: queueStats ? queueStats.waiting + 1 : 1,
                    fileSize,
                    fileSizeFormatted: require('../services/fileService').formatFileSize(fileSize),
                    type
                }
            });

        } catch (error) {
            logger.error('Erreur estimation:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * Fonction utilitaire pour obtenir la position dans la queue
 */
async function getQueuePosition(jobId) {
    try {
        const queueStats = await getQueueStats();
        return queueStats ? queueStats.waiting : 0;
    } catch (error) {
        logger.error('Erreur position queue:', error);
        return 0;
    }
}

/**
 * Informations détaillées sur les paramètres par type
 */
function getSettingsInfo(type) {
    const settingsInfo = {
        image: {
            quality: {
                type: 'number',
                min: 1,
                max: 100,
                default: 80,
                description: 'Qualité de compression (1-100)'
            },
            maxWidth: {
                type: 'number',
                min: 100,
                max: 8000,
                default: 1920,
                description: 'Largeur maximale en pixels'
            },
            maxHeight: {
                type: 'number',
                min: 100,
                max: 8000,
                default: 1080,
                description: 'Hauteur maximale en pixels'
            },
            format: {
                type: 'string',
                options: ['auto', 'jpeg', 'png', 'webp', 'avif'],
                default: 'auto',
                description: 'Format de sortie'
            },
            removeMetadata: {
                type: 'boolean',
                default: true,
                description: 'Supprimer les métadonnées EXIF'
            }
        },
        video: {
            codec: {
                type: 'string',
                options: ['h264', 'h265', 'vp9', 'av1'],
                default: 'h264',
                description: 'Codec vidéo'
            },
            crf: {
                type: 'number',
                min: 18,
                max: 51,
                default: 23,
                description: 'Facteur de compression (plus bas = meilleure qualité)'
            },
            preset: {
                type: 'string',
                options: ['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'],
                default: 'medium',
                description: 'Vitesse d\'encodage vs compression'
            }
        },
        audio: {
            codec: {
                type: 'string',
                options: ['aac', 'mp3', 'ogg', 'flac'],
                default: 'aac',
                description: 'Codec audio'
            },
            bitrate: {
                type: 'string',
                options: ['64k', '128k', '192k', '256k', '320k'],
                default: '128k',
                description: 'Débit binaire'
            },
            sampleRate: {
                type: 'number',
                options: [22050, 44100, 48000],
                default: 44100,
                description: 'Fréquence d\'échantillonnage'
            }
        },
        document: {
            compress: {
                type: 'boolean',
                default: true,
                description: 'Activer la compression'
            },
            quality: {
                type: 'number',
                min: 1,
                max: 100,
                default: 80,
                description: 'Qualité des images intégrées'
            },
            removeMetadata: {
                type: 'boolean',
                default: true,
                description: 'Supprimer les métadonnées'
            }
        }
    };

    return settingsInfo[type] || {};
}

/**
 * Description des types de fichiers
 */
function getTypeDescription(type) {
    const descriptions = {
        image: 'Compression et optimisation d\'images avec redimensionnement automatique',
        video: 'Compression vidéo avec codecs modernes et optimisation pour le streaming',
        audio: 'Compression audio avec normalisation et conversion de format',
        document: 'Optimisation de documents PDF avec compression des images intégrées'
    };

    return descriptions[type] || 'Type de fichier supporté';
}

module.exports = router;


================================================
File: backend/src/routes/status.js
================================================
// backend/src/routes/status.js
const express = require('express');
const rateLimit = require('express-rate-limit');

const JobService = require('../services/jobService');
const { getQueueStats, getActiveJobs } = require('../services/queueService');
const { ValidationService, validateRequest } = require('../utils/validation');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * Rate limiting pour les routes de statut
 */
const statusRateLimit = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: parseInt(process.env.STATUS_RATE_LIMIT) || 60, // 60 requêtes par minute
    message: {
        success: false,
        error: 'Trop de requêtes de statut'
    },
    standardHeaders: true,
    legacyHeaders: false,
    skip: (req) => {
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    }
});

/**
 * GET /api/status/:jobId
 * Obtenir le statut d'un job spécifique
 */
router.get('/:jobId', 
    statusRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.debug('Demande statut job', { jobId, ip: req.ip });

            // Récupérer le job
            const job = await JobService.getJob(jobId);
            
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouvé',
                    jobId
                });
            }

            // Calculer des métriques additionnelles
            const currentTime = new Date();
            const createdTime = new Date(job.createdAt);
            const updatedTime = new Date(job.updatedAt);
            
            const timeElapsed = Math.floor((currentTime - createdTime) / 1000); // en secondes
            const timeSinceUpdate = Math.floor((currentTime - updatedTime) / 1000);

            // Calculer l'ETA si en cours de traitement
            let eta = null;
            if (job.status === 'processing' && job.progress > 0) {
                const remainingProgress = 100 - job.progress;
                const progressRate = job.progress / timeElapsed; // progress par seconde
                if (progressRate > 0) {
                    eta = Math.floor(remainingProgress / progressRate);
                }
            }

            // Préparer la réponse
            const response = {
                success: true,
                job: {
                    id: job.id,
                    originalName: job.originalName,
                    type: job.type,
                    status: job.status,
                    progress: parseInt(job.progress) || 0,
                    size: parseInt(job.size),
                    sizeFormatted: job.size ? require('../services/fileService').formatFileSize(parseInt(job.size)) : null,
                    settings: job.settings,
                    createdAt: job.createdAt,
                    updatedAt: job.updatedAt,
                    timeElapsed,
                    timeSinceUpdate,
                    eta
                }
            };

            // Ajouter des informations spécifiques au statut
            switch (job.status) {
                case 'completed':
                    response.job.compressedSize = parseInt(job.compressedSize);
                    response.job.compressedSizeFormatted = job.compressedSize ? 
                        require('../services/fileService').formatFileSize(parseInt(job.compressedSize)) : null;
                    response.job.compressionRatio = parseInt(job.compressionRatio) || 0;
                    response.job.outputPath = job.outputPath;
                    
                    // Calcul des économies
                    if (job.size && job.compressedSize) {
                        const savedBytes = parseInt(job.size) - parseInt(job.compressedSize);
                        response.job.savedBytes = savedBytes;
                        response.job.savedBytesFormatted = require('../services/fileService').formatFileSize(savedBytes);
                    }
                    break;

                case 'error':
                    response.job.error = job.error;
                    break;

                case 'processing':
                    // Informations de progression détaillées
                    if (eta) {
                        response.job.etaFormatted = formatDuration(eta);
                    }
                    break;
            }

            res.json(response);

        } catch (error) {
            logger.error(`Erreur récupération statut job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/status
 * Obtenir la liste des jobs avec pagination et filtres
 */
router.get('/',
    statusRateLimit,
    validateRequest.pagination,
    validateRequest.jobFilters,
    async (req, res) => {
        try {
            const { page, limit, sortBy, sortOrder } = req.query;
            const filters = {
                status: req.query.status,
                type: req.query.type,
                dateFrom: req.query.dateFrom,
                dateTo: req.query.dateTo,
                minSize: req.query.minSize,
                maxSize: req.query.maxSize
            };

            logger.debug('Liste jobs demandée', { 
                page, limit, sortBy, sortOrder, filters, ip: req.ip 
            });

            // Récupérer tous les jobs (à optimiser avec vraie pagination plus tard)
            let jobs = await JobService.getAllJobs(limit * 10); // Buffer pour filtrage

            // Appliquer les filtres
            if (filters.status) {
                jobs = jobs.filter(job => job.status === filters.status);
            }
            
            if (filters.type) {
                jobs = jobs.filter(job => job.type === filters.type);
            }

            if (filters.dateFrom) {
                const fromDate = new Date(filters.dateFrom);
                jobs = jobs.filter(job => new Date(job.createdAt) >= fromDate);
            }

            if (filters.dateTo) {
                const toDate = new Date(filters.dateTo);
                jobs = jobs.filter(job => new Date(job.createdAt) <= toDate);
            }

            if (filters.minSize) {
                jobs = jobs.filter(job => parseInt(job.size) >= parseInt(filters.minSize));
            }

            if (filters.maxSize) {
                jobs = jobs.filter(job => parseInt(job.size) <= parseInt(filters.maxSize));
            }

            // Tri
            jobs.sort((a, b) => {
                let valueA = a[sortBy];
                let valueB = b[sortBy];

                // Conversion pour les champs numériques
                if (['size', 'progress'].includes(sortBy)) {
                    valueA = parseInt(valueA) || 0;
                    valueB = parseInt(valueB) || 0;
                }

                // Conversion pour les dates
                if (['createdAt', 'updatedAt'].includes(sortBy)) {
                    valueA = new Date(valueA);
                    valueB = new Date(valueB);
                }

                if (sortOrder === 'asc') {
                    return valueA > valueB ? 1 : -1;
                } else {
                    return valueA < valueB ? 1 : -1;
                }
            });

            // Pagination
            const startIndex = (page - 1) * limit;
            const endIndex = startIndex + limit;
            const paginatedJobs = jobs.slice(startIndex, endIndex);

            // Enrichir les jobs avec des informations calculées
            const enrichedJobs = paginatedJobs.map(job => {
                const currentTime = new Date();
                const createdTime = new Date(job.createdAt);
                
                return {
                    ...job,
                    size: parseInt(job.size),
                    progress: parseInt(job.progress) || 0,
                    sizeFormatted: job.size ? require('../services/fileService').formatFileSize(parseInt(job.size)) : null,
                    timeElapsed: Math.floor((currentTime - createdTime) / 1000),
                    compressedSize: job.compressedSize ? parseInt(job.compressedSize) : null,
                    compressionRatio: job.compressionRatio ? parseInt(job.compressionRatio) : null
                };
            });

            // Métadonnées de pagination
            const totalJobs = jobs.length;
            const totalPages = Math.ceil(totalJobs / limit);
            const hasNextPage = page < totalPages;
            const hasPrevPage = page > 1;

            res.json({
                success: true,
                jobs: enrichedJobs,
                pagination: {
                    page,
                    limit,
                    total: totalJobs,
                    pages: totalPages,
                    hasNext: hasNextPage,
                    hasPrev: hasPrevPage
                },
                filters: filters,
                sort: { sortBy, sortOrder }
            });

        } catch (error) {
            logger.error('Erreur récupération liste jobs:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/status/stats
 * Statistiques globales du système
 */
router.get('/stats/global', statusRateLimit, async (req, res) => {
    try {
        logger.debug('Statistiques globales demandées', { ip: req.ip });

        // Récupérer les stats des jobs
        const jobStats = await JobService.getJobStats();
        
        // Récupérer les stats de la queue
        const queueStats = await getQueueStats();
        
        // Récupérer les jobs actifs
        const activeJobs = await getActiveJobs();

        // Calculer des métriques additionnelles
        const currentTime = new Date();
        const last24h = new Date(currentTime.getTime() - 24 * 60 * 60 * 1000);
        
        // Récupérer les jobs des dernières 24h
        const recentJobs = await JobService.getAllJobs(1000);
        const jobs24h = recentJobs.filter(job => 
            new Date(job.createdAt) >= last24h
        );

        // Calculer les métriques de performance
        const completedJobs24h = jobs24h.filter(job => job.status === 'completed');
        const totalSizeProcessed = completedJobs24h.reduce((sum, job) => 
            sum + (parseInt(job.size) || 0), 0
        );
        const totalSizeSaved = completedJobs24h.reduce((sum, job) => {
            const original = parseInt(job.size) || 0;
            const compressed = parseInt(job.compressedSize) || original;
            return sum + (original - compressed);
        }, 0);

        const avgCompressionRatio = completedJobs24h.length > 0 ?
            completedJobs24h.reduce((sum, job) => 
                sum + (parseInt(job.compressionRatio) || 0), 0
            ) / completedJobs24h.length : 0;

        // Calculer les temps de traitement moyens
        const avgProcessingTimes = {};
        const jobsByType = completedJobs24h.reduce((acc, job) => {
            if (!acc[job.type]) acc[job.type] = [];
            
            const created = new Date(job.createdAt);
            const updated = new Date(job.updatedAt);
            const processingTime = Math.floor((updated - created) / 1000);
            
            acc[job.type].push(processingTime);
            return acc;
        }, {});

        Object.keys(jobsByType).forEach(type => {
            const times = jobsByType[type];
            avgProcessingTimes[type] = times.length > 0 ?
                Math.floor(times.reduce((a, b) => a + b, 0) / times.length) : 0;
        });

        res.json({
            success: true,
            stats: {
                jobs: {
                    total: jobStats.total,
                    uploaded: jobStats.uploaded || 0,
                    queued: jobStats.queued || 0,
                    processing: jobStats.processing || 0,
                    completed: jobStats.completed || 0,
                    error: jobStats.error || 0,
                    last24h: jobs24h.length,
                    completed24h: completedJobs24h.length
                },
                queue: queueStats || {
                    waiting: 0,
                    active: 0,
                    completed: 0,
                    failed: 0,
                    delayed: 0
                },
                performance: {
                    totalSizeProcessed,
                    totalSizeProcessedFormatted: require('../services/fileService').formatFileSize(totalSizeProcessed),
                    totalSizeSaved,
                    totalSizeSavedFormatted: require('../services/fileService').formatFileSize(totalSizeSaved),
                    avgCompressionRatio: Math.round(avgCompressionRatio),
                    avgProcessingTimes
                },
                activeJobs: activeJobs || [],
                timestamp: currentTime.toISOString()
            }
        });

    } catch (error) {
        logger.error('Erreur récupération statistiques:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * DELETE /api/status/:jobId
 * Supprimer un job et ses fichiers associés
 */
router.delete('/:jobId',
    statusRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande suppression job ${jobId}`, { ip: req.ip });

            // Vérifier que le job existe
            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouvé'
                });
            }

            // Ne pas permettre la suppression des jobs en cours de traitement
            if (job.status === 'processing') {
                return res.status(400).json({
                    success: false,
                    error: 'Impossible de supprimer un job en cours de traitement'
                });
            }

            // Supprimer les fichiers associés
            const FileService = require('../services/fileService');
            
            if (job.filePath) {
                await FileService.deleteFile(job.filePath);
                logger.file(`Fichier source supprimé: ${job.filePath}`);
            }

            if (job.outputPath) {
                await FileService.deleteFile(job.outputPath);
                logger.file(`Fichier de sortie supprimé: ${job.outputPath}`);
            }

            // Supprimer le job de Redis
            await JobService.deleteJob(jobId);

            logger.info(`Job ${jobId} supprimé avec succès`);

            res.json({
                success: true,
                message: 'Job supprimé avec succès',
                jobId
            });

        } catch (error) {
            logger.error(`Erreur suppression job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * POST /api/status/:jobId/retry
 * Relancer un job en erreur
 */
router.post('/:jobId/retry',
    statusRateLimit,
    validateRequest.jobId,
    async (req, res) => {
        try {
            const { jobId } = req.params;
            
            logger.info(`Demande retry job ${jobId}`, { ip: req.ip });

            // Vérifier que le job existe
            const job = await JobService.getJob(jobId);
            if (!job) {
                return res.status(404).json({
                    success: false,
                    error: 'Job non trouvé'
                });
            }

            // Vérifier que le job est en erreur
            if (job.status !== 'error') {
                return res.status(400).json({
                    success: false,
                    error: 'Seuls les jobs en erreur peuvent être relancés'
                });
            }

            // Vérifier que le fichier source existe encore
            const FileService = require('../services/fileService');
            const fileExists = await FileService.getFileStats(job.filePath);
            if (!fileExists) {
                return res.status(400).json({
                    success: false,
                    error: 'Fichier source introuvable, impossible de relancer'
                });
            }

            // Remettre le job en état initial
            await JobService.updateJob(jobId, {
                status: 'uploaded',
                progress: 0,
                error: null,
                outputPath: null,
                compressedSize: null,
                compressionRatio: null,
                updatedAt: new Date().toISOString()
            });

            // Remettre en queue
            const { addJobToQueue } = require('../services/queueService');
            await addJobToQueue(job);
            
            await JobService.updateJob(jobId, { status: 'queued' });

            logger.job(jobId, 'Job relancé avec succès');

            res.json({
                success: true,
                message: 'Job relancé avec succès',
                jobId,
                status: 'queued'
            });

        } catch (error) {
            logger.error(`Erreur retry job ${req.params.jobId}:`, error);
            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur'
            });
        }
    }
);

/**
 * GET /api/status/types/stats
 * Statistiques par type de fichier
 */
router.get('/types/stats', statusRateLimit, async (req, res) => {
    try {
        logger.debug('Statistiques par type demandées', { ip: req.ip });

        // Récupérer tous les jobs récents
        const jobs = await JobService.getAllJobs(1000);
        
        // Grouper par type
        const statsByType = {};
        const FileService = require('../services/fileService');
        
        jobs.forEach(job => {
            const type = job.type || 'unknown';
            
            if (!statsByType[type]) {
                statsByType[type] = {
                    total: 0,
                    uploaded: 0,
                    queued: 0,
                    processing: 0,
                    completed: 0,
                    error: 0,
                    totalSize: 0,
                    totalCompressed: 0,
                    totalSaved: 0,
                    avgCompressionRatio: 0,
                    processingTimes: []
                };
            }

            const stats = statsByType[type];
            stats.total++;
            stats[job.status]++;
            
            const size = parseInt(job.size) || 0;
            stats.totalSize += size;
            
            if (job.status === 'completed') {
                const compressed = parseInt(job.compressedSize) || size;
                stats.totalCompressed += compressed;
                stats.totalSaved += (size - compressed);
                
                // Calculer le temps de traitement
                if (job.createdAt && job.updatedAt) {
                    const processingTime = new Date(job.updatedAt) - new Date(job.createdAt);
                    stats.processingTimes.push(Math.floor(processingTime / 1000));
                }
            }
        });

        // Calculer les moyennes
        Object.keys(statsByType).forEach(type => {
            const stats = statsByType[type];
            
            // Ratio de compression moyen
            if (stats.totalSize > 0) {
                stats.avgCompressionRatio = Math.round(
                    ((stats.totalSize - stats.totalCompressed) / stats.totalSize) * 100
                );
            }
            
            // Temps de traitement moyen
            if (stats.processingTimes.length > 0) {
                stats.avgProcessingTime = Math.floor(
                    stats.processingTimes.reduce((a, b) => a + b, 0) / stats.processingTimes.length
                );
            } else {
                stats.avgProcessingTime = 0;
            }
            
            // Formater les tailles
            stats.totalSizeFormatted = FileService.formatFileSize(stats.totalSize);
            stats.totalCompressedFormatted = FileService.formatFileSize(stats.totalCompressed);
            stats.totalSavedFormatted = FileService.formatFileSize(stats.totalSaved);
            
            // Supprimer les temps bruts
            delete stats.processingTimes;
        });

        res.json({
            success: true,
            statsByType,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        logger.error('Erreur statistiques par type:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * Fonction utilitaire pour formater une durée en secondes
 */
function formatDuration(seconds) {
    if (seconds < 60) {
        return `${seconds}s`;
    } else if (seconds < 3600) {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}m ${secs}s`;
    } else {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${minutes}m`;
    }
}

module.exports = router;


================================================
File: backend/src/routes/upload.js
================================================
// backend/src/routes/upload.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const rateLimit = require('express-rate-limit');

const FileService = require('../services/fileService');
const JobService = require('../services/jobService');
const ProcessingService = require('../services/processingService');
const { ValidationService } = require('../utils/validation');
const logger = require('../utils/logger');
const { addJobToQueue } = require('../services/queueService');

const router = express.Router();

/**
 * Configuration de Multer pour l'upload de fichiers
 */
const uploadConfig = multer({
    storage: multer.memoryStorage(), // Stockage en mémoire pour validation
    limits: {
        fileSize: parseInt(process.env.UPLOAD_MAX_SIZE) || 5 * 1024 * 1024 * 1024, // 5GB par défaut
        files: 1, // Un seul fichier à la fois
        fields: 10, // Limite des champs supplémentaires
        fieldNameSize: 100, // Limite nom de champ
        fieldSize: 1024 * 1024 // 1MB pour les champs texte
    },
    fileFilter: (req, file, cb) => {
        // Validation préliminaire du fichier
        const isValidType = FileService.isValidFileType(file.originalname);
        
        if (!isValidType) {
            logger.security('Tentative upload type invalide', {
                filename: file.originalname,
                mimetype: file.mimetype,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });
            return cb(new Error('Type de fichier non supporté'), false);
        }
        
        cb(null, true);
    }
});

/**
 * Rate limiting spécifique aux uploads
 */
const uploadRateLimit = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: parseInt(process.env.UPLOAD_RATE_LIMIT) || 10, // 10 uploads par 15min
    message: {
        success: false,
        error: 'Trop d\'uploads, veuillez attendre avant de réessayer',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Rate limit par IP + User-Agent pour éviter les contournements
        return `${req.ip}-${req.get('User-Agent') || 'unknown'}`;
    },
    skip: (req) => {
        // Skip rate limiting en développement si configuré
        return process.env.NODE_ENV === 'development' && 
               process.env.SKIP_RATE_LIMIT === 'true';
    },
    onLimitReached: (req) => {
        logger.security('Rate limit upload atteint', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            path: req.path
        });
    }
});

/**
 * Middleware de validation de sécurité upload
 */
const securityValidation = async (req, res, next) => {
    try {
        const file = req.file;
        if (!file) {
            return res.status(400).json({
                success: false,
                error: 'Aucun fichier fourni'
            });
        }

        // Validation de sécurité avancée
        const securityCheck = ValidationService.validateUploadSecurity(file, req);
        if (!securityCheck.isValid) {
            logger.security('Upload bloqué par sécurité', {
                filename: file.originalname,
                errors: securityCheck.errors,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });
            
            return res.status(400).json({
                success: false,
                error: 'Fichier rejeté par les contrôles de sécurité',
                details: securityCheck.errors
            });
        }

        next();
    } catch (error) {
        logger.error('Erreur validation sécurité upload:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne de validation'
        });
    }
};

/**
 * POST /api/upload
 * Upload d'un fichier avec validation complète
 */
router.post('/', 
    uploadRateLimit,
    uploadConfig.single('file'),
    securityValidation,
    async (req, res) => {
        const requestLogger = logger.withContext({ 
            requestId: uuidv4(),
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });

        try {
            const file = req.file;
            const settings = req.body.settings ? JSON.parse(req.body.settings) : {};

            requestLogger.info('Upload démarré', {
                filename: file.originalname,
                size: file.size,
                mimetype: file.mimetype
            });

            // Validation complète du fichier et des paramètres
            const validation = await ValidationService.validateUpload(file, settings);
            if (!validation.isValid) {
                requestLogger.warn('Validation upload échouée', {
                    errors: validation.errors
                });
                
                return res.status(400).json({
                    success: false,
                    error: 'Fichier ou paramètres invalides',
                    details: validation.errors
                });
            }

            // Nettoyer le nom de fichier
            const sanitizedFilename = ValidationService.sanitizeFilename(file.originalname);
            if (!sanitizedFilename) {
                return res.status(400).json({
                    success: false,
                    error: 'Nom de fichier invalide'
                });
            }

            // Créer le répertoire temporaire
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            await FileService.ensureDirectoryExists(tempDir);

            // Générer un nom de fichier unique
            const uniqueFilename = FileService.generateUniqueFilename(sanitizedFilename);
            const filePath = path.join(tempDir, uniqueFilename);

            // Sauvegarder le fichier
            const fs = require('fs').promises;
            await fs.writeFile(filePath, file.buffer);

            requestLogger.info('Fichier sauvegardé', { filePath });

            // Obtenir les paramètres validés avec valeurs par défaut
            const fileType = FileService.getFileType(sanitizedFilename);
            const defaultSettings = ProcessingService.getDefaultSettings(fileType);
            const finalSettings = { ...defaultSettings, ...validation.validatedData.settings };

            // Valider les paramètres finaux
            const settingsValidation = ValidationService.validateSettings(fileType, finalSettings);
            if (!settingsValidation.isValid) {
                // Nettoyer le fichier en cas d'erreur
                await FileService.deleteFile(filePath);
                
                return res.status(400).json({
                    success: false,
                    error: 'Paramètres invalides',
                    details: settingsValidation.errors
                });
            }

            // Créer le job
            const jobId = uuidv4();
            const jobData = {
                id: jobId,
                originalName: sanitizedFilename,
                filePath,
                size: file.size,
                type: fileType,
                settings: settingsValidation.validatedSettings,
                status: 'uploaded',
                progress: 0,
                createdAt: new Date().toISOString()
            };

            // Validation finale du job
            const jobValidation = ValidationService.validateJob(jobData);
            if (!jobValidation.isValid) {
                await FileService.deleteFile(filePath);
                
                return res.status(400).json({
                    success: false,
                    error: 'Job invalide',
                    details: jobValidation.errors
                });
            }

            // Sauvegarder le job
            await JobService.createJob(jobValidation.validatedJob);

            requestLogger.job(jobId, 'Job créé avec succès');

            // Estimer le temps de traitement
            const estimatedTime = ProcessingService.estimateProcessingTime(fileType, file.size);

            // Réponse immédiate
            res.status(201).json({
                success: true,
                jobId,
                message: 'Fichier uploadé avec succès',
                file: {
                    originalName: sanitizedFilename,
                    size: file.size,
                    sizeFormatted: FileService.formatFileSize(file.size),
                    type: fileType
                },
                settings: settingsValidation.validatedSettings,
                estimatedTime,
                status: 'uploaded'
            });

            // Ajouter à la queue de traitement (asynchrone)
            setImmediate(async () => {
                try {
                    await addJobToQueue(jobValidation.validatedJob);
                    await JobService.updateJob(jobId, { status: 'queued' });
                    
                    requestLogger.job(jobId, 'Job ajouté à la queue');
                    
                    // Notifier via WebSocket si disponible
                    if (req.io) {
                        req.io.emit('job-queued', {
                            jobId,
                            status: 'queued',
                            timestamp: new Date().toISOString()
                        });
                    }
                } catch (error) {
                    requestLogger.error('Erreur ajout queue', error, { jobId });
                    
                    await JobService.updateJob(jobId, { 
                        status: 'error',
                        error: 'Erreur ajout à la queue'
                    });
                }
            });

        } catch (error) {
            requestLogger.error('Erreur upload:', error);
            
            // Nettoyer le fichier en cas d'erreur
            if (req.file && req.filePath) {
                await FileService.deleteFile(req.filePath).catch(() => {});
            }

            res.status(500).json({
                success: false,
                error: 'Erreur interne du serveur',
                message: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }
);

/**
 * POST /api/upload/batch
 * Upload de plusieurs fichiers (limité)
 */
router.post('/batch',
    uploadRateLimit,
    uploadConfig.array('files', 5), // Maximum 5 fichiers
    async (req, res) => {
        const requestLogger = logger.withContext({ 
            requestId: uuidv4(),
            ip: req.ip
        });

        try {
            const files = req.files;
            if (!files || files.length === 0) {
                return res.status(400).json({
                    success: false,
                    error: 'Aucun fichier fourni'
                });
            }

            requestLogger.info('Upload batch démarré', {
                fileCount: files.length,
                totalSize: files.reduce((sum, f) => sum + f.size, 0)
            });

            const results = [];
            const errors = [];

            // Traiter chaque fichier
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                try {
                    // Simulation de l'upload individuel
                    // (logique similaire à l'upload simple)
                    const jobId = uuidv4();
                    const sanitizedFilename = ValidationService.sanitizeFilename(file.originalname);
                    
                    if (!sanitizedFilename) {
                        errors.push({
                            file: file.originalname,
                            error: 'Nom de fichier invalide'
                        });
                        continue;
                    }

                    results.push({
                        jobId,
                        filename: sanitizedFilename,
                        size: file.size,
                        status: 'uploaded'
                    });

                } catch (error) {
                    errors.push({
                        file: file.originalname,
                        error: error.message
                    });
                }
            }

            res.json({
                success: true,
                message: `${results.length} fichiers traités`,
                results,
                errors: errors.length > 0 ? errors : undefined,
                total: files.length,
                processed: results.length,
                failed: errors.length
            });

        } catch (error) {
            requestLogger.error('Erreur upload batch:', error);
            res.status(500).json({
                success: false,
                error: 'Erreur traitement batch'
            });
        }
    }
);

/**
 * GET /api/upload/info
 * Informations sur les limites d'upload
 */
router.get('/info', (req, res) => {
    res.json({
        success: true,
        limits: {
            maxFileSize: parseInt(process.env.UPLOAD_MAX_SIZE) || 5 * 1024 * 1024 * 1024,
            maxFileSizeFormatted: FileService.formatFileSize(
                parseInt(process.env.UPLOAD_MAX_SIZE) || 5 * 1024 * 1024 * 1024
            ),
            maxFiles: 1,
            maxFilesBatch: 5,
            rateLimit: parseInt(process.env.UPLOAD_RATE_LIMIT) || 10,
            rateLimitWindow: '15 minutes'
        },
        supportedFormats: FileService.getSupportedFormats(),
        defaultSettings: {
            image: ProcessingService.getDefaultSettings('image'),
            video: ProcessingService.getDefaultSettings('video'),
            audio: ProcessingService.getDefaultSettings('audio'),
            document: ProcessingService.getDefaultSettings('document')
        }
    });
});

/**
 * Middleware de gestion d'erreurs Multer
 */
router.use((error, req, res, next) => {
    if (error instanceof multer.MulterError) {
        logger.warn('Erreur Multer:', {
            code: error.code,
            field: error.field,
            message: error.message,
            ip: req.ip
        });

        const errorMessages = {
            'LIMIT_FILE_SIZE': 'Fichier trop volumineux',
            'LIMIT_FILE_COUNT': 'Trop de fichiers',
            'LIMIT_FIELD_KEY': 'Nom de champ trop long',
            'LIMIT_FIELD_VALUE': 'Valeur de champ trop longue',
            'LIMIT_FIELD_COUNT': 'Trop de champs',
            'LIMIT_UNEXPECTED_FILE': 'Fichier inattendu'
        };

        return res.status(400).json({
            success: false,
            error: errorMessages[error.code] || 'Erreur upload',
            code: error.code
        });
    }

    if (error.message === 'Type de fichier non supporté') {
        return res.status(400).json({
            success: false,
            error: 'Type de fichier non supporté'
        });
    }

    logger.error('Erreur route upload:', error);
    res.status(500).json({
        success: false,
        error: 'Erreur interne du serveur'
    });
});

module.exports = router;


================================================
File: backend/src/services/fileService.js
================================================
// backend/src/services/fileService.js
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const logger = require('../utils/logger');

/**
 * Service de gestion des fichiers
 */
class FileService {
    /**
     * Formats supportés par type
     */
    static SUPPORTED_FORMATS = {
        images: ['.jpg', '.jpeg', '.png', '.webp', '.avif', '.heic', '.tiff', '.bmp'],
        videos: ['.mp4', '.avi', '.mkv', '.webm', '.mov', '.flv', '.m4v'],
        audio: ['.mp3', '.flac', '.wav', '.aac', '.ogg', '.m4a', '.wma'],
        documents: ['.pdf']
    };

    /**
     * Obtenir tous les formats supportés
     */
    static getSupportedFormats() {
        return this.SUPPORTED_FORMATS;
    }

    /**
     * Déterminer le type d'un fichier basé sur son extension
     */
    static getFileType(filename) {
        const ext = path.extname(filename).toLowerCase();
        
        for (const [type, extensions] of Object.entries(this.SUPPORTED_FORMATS)) {
            if (extensions.includes(ext)) {
                return type.slice(0, -1); // Retire le 's' final (images -> image)
            }
        }
        
        return 'unknown';
    }

    /**
     * Vérifier si un fichier est supporté
     */
    static isValidFileType(filename) {
        const ext = path.extname(filename).toLowerCase();
        return Object.values(this.SUPPORTED_FORMATS).flat().includes(ext);
    }

    /**
     * Générer un nom de fichier unique
     */
    static generateUniqueFilename(originalName) {
        const ext = path.extname(originalName);
        const name = path.basename(originalName, ext);
        const timestamp = Date.now();
        const random = crypto.randomBytes(4).toString('hex');
        
        // Nettoyer le nom original (caractères spéciaux)
        const cleanName = name.replace(/[^a-zA-Z0-9-_]/g, '_');
        
        return `${cleanName}_${timestamp}_${random}${ext}`;
    }

    /**
     * Créer un répertoire s'il n'existe pas
     */
    static async ensureDirectoryExists(dirPath) {
        try {
            await fs.access(dirPath);
        } catch (error) {
            await fs.mkdir(dirPath, { recursive: true });
            logger.info(`Dossier créé: ${dirPath}`);
        }
    }

    /**
     * Obtenir les statistiques d'un fichier
     */
    static async getFileStats(filePath) {
        try {
            const stats = await fs.stat(filePath);
            return {
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                isFile: stats.isFile(),
                isDirectory: stats.isDirectory()
            };
        } catch (error) {
            logger.error(`Erreur stats fichier ${filePath}:`, error);
            return null;
        }
    }

    /**
     * Supprimer un fichier
     */
    static async deleteFile(filePath) {
        try {
            await fs.unlink(filePath);
            logger.info(`Fichier supprimé: ${filePath}`);
            return true;
        } catch (error) {
            logger.error(`Erreur suppression ${filePath}:`, error);
            return false;
        }
    }

    /**
     * Copier un fichier
     */
    static async copyFile(sourcePath, destPath) {
        try {
            await fs.copyFile(sourcePath, destPath);
            logger.info(`Fichier copié: ${sourcePath} -> ${destPath}`);
            return true;
        } catch (error) {
            logger.error(`Erreur copie ${sourcePath} -> ${destPath}:`, error);
            return false;
        }
    }

    /**
     * Déplacer un fichier
     */
    static async moveFile(sourcePath, destPath) {
        try {
            await fs.rename(sourcePath, destPath);
            logger.info(`Fichier déplacé: ${sourcePath} -> ${destPath}`);
            return true;
        } catch (error) {
            logger.error(`Erreur déplacement ${sourcePath} -> ${destPath}:`, error);
            return false;
        }
    }

    /**
     * Formater la taille d'un fichier
     */
    static formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Calculer le ratio de compression
     */
    static calculateCompressionRatio(originalSize, compressedSize) {
        if (originalSize === 0) return 0;
        return Math.round(((originalSize - compressedSize) / originalSize) * 100);
    }

    /**
     * Vérifier l'intégrité d'un fichier via checksum
     */
    static async calculateChecksum(filePath, algorithm = 'md5') {
        try {
            const fileBuffer = await fs.readFile(filePath);
            const hashSum = crypto.createHash(algorithm);
            hashSum.update(fileBuffer);
            
            return hashSum.digest('hex');
        } catch (error) {
            logger.error(`Erreur calcul checksum ${filePath}:`, error);
            return null;
        }
    }

    /**
     * Obtenir les informations détaillées d'un fichier
     */
    static async getFileInfo(filePath) {
        try {
            const stats = await this.getFileStats(filePath);
            if (!stats) return null;

            const filename = path.basename(filePath);
            const ext = path.extname(filename).toLowerCase();
            const type = this.getFileType(filename);
            const checksum = await this.calculateChecksum(filePath);

            return {
                path: filePath,
                filename,
                extension: ext,
                type,
                size: stats.size,
                sizeFormatted: this.formatFileSize(stats.size),
                created: stats.created,
                modified: stats.modified,
                checksum,
                isValid: this.isValidFileType(filename)
            };
        } catch (error) {
            logger.error(`Erreur info fichier ${filePath}:`, error);
            return null;
        }
    }

    /**
     * Nettoyer les fichiers temporaires
     */
    static async cleanupTempFiles(tempDir, maxAge = 24 * 60 * 60 * 1000) { // 24h par défaut
        try {
            const files = await fs.readdir(tempDir);
            const now = Date.now();
            let cleanedCount = 0;
            let totalSize = 0;
            
            for (const file of files) {
                const filePath = path.join(tempDir, file);
                const stats = await this.getFileStats(filePath);
                
                if (stats && stats.isFile) {
                    const age = now - stats.created.getTime();
                    
                    if (age > maxAge) {
                        totalSize += stats.size;
                        if (await this.deleteFile(filePath)) {
                            cleanedCount++;
                        }
                    }
                }
            }
            
            if (cleanedCount > 0) {
                logger.info(`Nettoyage: ${cleanedCount} fichiers supprimés (${this.formatFileSize(totalSize)} libérés)`);
            }
            
            return { count: cleanedCount, size: totalSize };
        } catch (error) {
            logger.error('Erreur nettoyage fichiers temporaires:', error);
            return { count: 0, size: 0 };
        }
    }

    /**
     * Lister les fichiers d'un répertoire avec filtres
     */
    static async listFiles(directory, options = {}) {
        try {
            const {
                extension = null,
                type = null,
                maxSize = null,
                minSize = null,
                recursive = false
            } = options;

            const files = [];
            const entries = await fs.readdir(directory, { withFileTypes: true });

            for (const entry of entries) {
                const fullPath = path.join(directory, entry.name);

                if (entry.isFile()) {
                    const fileInfo = await this.getFileInfo(fullPath);
                    if (!fileInfo) continue;

                    // Appliquer les filtres
                    if (extension && fileInfo.extension !== extension) continue;
                    if (type && fileInfo.type !== type) continue;
                    if (maxSize && fileInfo.size > maxSize) continue;
                    if (minSize && fileInfo.size < minSize) continue;

                    files.push(fileInfo);
                } else if (entry.isDirectory() && recursive) {
                    const subFiles = await this.listFiles(fullPath, options);
                    files.push(...subFiles);
                }
            }

            return files;
        } catch (error) {
            logger.error(`Erreur listage fichiers ${directory}:`, error);
            return [];
        }
    }

    /**
     * Obtenir l'usage disque d'un répertoire
     */
    static async getDirectorySize(directory) {
        try {
            let totalSize = 0;
            let fileCount = 0;

            const calculateSize = async (dir) => {
                const entries = await fs.readdir(dir, { withFileTypes: true });

                for (const entry of entries) {
                    const fullPath = path.join(dir, entry.name);

                    if (entry.isFile()) {
                        const stats = await this.getFileStats(fullPath);
                        if (stats) {
                            totalSize += stats.size;
                            fileCount++;
                        }
                    } else if (entry.isDirectory()) {
                        await calculateSize(fullPath);
                    }
                }
            };

            await calculateSize(directory);

            return {
                size: totalSize,
                sizeFormatted: this.formatFileSize(totalSize),
                fileCount
            };
        } catch (error) {
            logger.error(`Erreur calcul taille répertoire ${directory}:`, error);
            return { size: 0, sizeFormatted: '0 B', fileCount: 0 };
        }
    }
}

module.exports = FileService;


================================================
File: backend/src/services/imageService.js
================================================
// backend/src/services/imageService.js
const sharp = require('sharp');
const path = require('path');
const FileService = require('./fileService');
const logger = require('../utils/logger');

/**
 * Service de traitement d'images
 */
class ImageService {
    /**
     * Traiter une image selon les paramètres fournis
     */
    static async processImage(inputPath, outputPath, settings = {}) {
        try {
            logger.info(`Traitement image: ${path.basename(inputPath)}`);

            // Paramètres par défaut
            const config = {
                quality: settings.quality || 80,
                maxWidth: settings.maxWidth || 1920,
                maxHeight: settings.maxHeight || 1080,
                format: settings.format || 'auto',
                removeMetadata: settings.removeMetadata !== false,
                progressive: settings.progressive !== false,
                ...settings
            };

            // Créer le processeur Sharp
            let processor = sharp(inputPath);

            // Obtenir les métadonnées de l'image originale
            const metadata = await processor.metadata();
            logger.debug(`Image originale: ${metadata.width}x${metadata.height}, format: ${metadata.format}`);

            // Redimensionnement si nécessaire
            if (this.shouldResize(metadata, config)) {
                processor = processor.resize(config.maxWidth, config.maxHeight, {
                    fit: 'inside',
                    withoutEnlargement: true
                });
                logger.debug(`Redimensionnement: ${config.maxWidth}x${config.maxHeight}`);
            }

            // Suppression des métadonnées EXIF
            if (config.removeMetadata) {
                processor = processor.removeMetadata();
            }

            // Rotation automatique basée sur EXIF
            if (metadata.orientation) {
                processor = processor.rotate();
            }

            // Configuration du format de sortie
            processor = this.configureOutputFormat(processor, config, metadata);

            // Traitement et sauvegarde
            await processor.toFile(outputPath);

            // Calculer les statistiques
            const originalStats = await FileService.getFileStats(inputPath);
            const processedStats = await FileService.getFileStats(outputPath);
            
            const result = {
                success: true,
                originalSize: originalStats.size,
                processedSize: processedStats.size,
                compressionRatio: FileService.calculateCompressionRatio(originalStats.size, processedStats.size),
                originalDimensions: { width: metadata.width, height: metadata.height },
                processedDimensions: await this.getImageDimensions(outputPath),
                outputPath
            };

            logger.info(`Image traitée: ${FileService.formatFileSize(originalStats.size)} -> ${FileService.formatFileSize(processedStats.size)} (${result.compressionRatio}%)`);

            return result;
        } catch (error) {
            logger.error('Erreur traitement image:', error);
            throw new Error(`Erreur traitement image: ${error.message}`);
        }
    }

    /**
     * Déterminer si l'image doit être redimensionnée
     */
    static shouldResize(metadata, config) {
        if (!metadata.width || !metadata.height) return false;
        if (!config.maxWidth && !config.maxHeight) return false;

        return metadata.width > config.maxWidth || metadata.height > config.maxHeight;
    }

    /**
     * Configurer le format de sortie
     */
    static configureOutputFormat(processor, config, metadata) {
        const format = config.format === 'auto' ? metadata.format : config.format;

        switch (format?.toLowerCase()) {
            case 'jpeg':
            case 'jpg':
                return processor.jpeg({
                    quality: config.quality,
                    progressive: config.progressive,
                    mozjpeg: true // Utiliser mozjpeg pour une meilleure compression
                });

            case 'png':
                return processor.png({
                    quality: config.quality,
                    progressive: config.progressive,
                    compressionLevel: Math.round(9 - (config.quality / 100) * 9)
                });

            case 'webp':
                return processor.webp({
                    quality: config.quality,
                    effort: 6 // Niveau d'effort de compression (0-6)
                });

            case 'avif':
                return processor.avif({
                    quality: config.quality,
                    effort: 4 // Niveau d'effort de compression (0-9)
                });

            case 'tiff':
                return processor.tiff({
                    quality: config.quality,
                    compression: 'lzw'
                });

            default:
                // Format par défaut: JPEG
                return processor.jpeg({
                    quality: config.quality,
                    progressive: config.progressive,
                    mozjpeg: true
                });
        }
    }

    /**
     * Obtenir les dimensions d'une image
     */
    static async getImageDimensions(imagePath) {
        try {
            const metadata = await sharp(imagePath).metadata();
            return {
                width: metadata.width,
                height: metadata.height
            };
        } catch (error) {
            logger.error(`Erreur lecture dimensions ${imagePath}:`, error);
            return { width: 0, height: 0 };
        }
    }

    /**
     * Obtenir les métadonnées détaillées d'une image
     */
    static async getImageMetadata(imagePath) {
        try {
            const metadata = await sharp(imagePath).metadata();
            return {
                format: metadata.format,
                width: metadata.width,
                height: metadata.height,
                channels: metadata.channels,
                depth: metadata.depth,
                density: metadata.density,
                hasAlpha: metadata.hasAlpha,
                orientation: metadata.orientation,
                colorSpace: metadata.space,
                exif: metadata.exif ? this.parseExifData(metadata.exif) : null
            };
        } catch (error) {
            logger.error(`Erreur lecture métadonnées ${imagePath}:`, error);
            return null;
        }
    }

    /**
     * Parser les données EXIF (basique)
     */
    static parseExifData(exifBuffer) {
        try {
            // Ici on pourrait utiliser une lib comme exif-parser pour plus de détails
            return {
                hasExif: true,
                size: exifBuffer.length
            };
        } catch (error) {
            return { hasExif: false };
        }
    }

    /**
     * Créer une vignette
     */
    static async createThumbnail(inputPath, outputPath, size = 200) {
        try {
            await sharp(inputPath)
                .resize(size, size, {
                    fit: 'cover',
                    position: 'center'
                })
                .jpeg({ quality: 80 })
                .toFile(outputPath);

            logger.debug(`Vignette créée: ${outputPath}`);
            return outputPath;
        } catch (error) {
            logger.error(`Erreur création vignette:`, error);
            throw error;
        }
    }

    /**
     * Optimiser une image pour le web
     */
    static async optimizeForWeb(inputPath, outputPath) {
        try {
            const metadata = await sharp(inputPath).metadata();
            
            // Paramètres optimisés pour le web
            const webSettings = {
                quality: 85,
                maxWidth: 1920,
                maxHeight: 1920,
                format: this.getBestWebFormat(metadata.format),
                progressive: true,
                removeMetadata: true
            };

            return await this.processImage(inputPath, outputPath, webSettings);
        } catch (error) {
            logger.error('Erreur optimisation web:', error);
            throw error;
        }
    }

    /**
     * Déterminer le meilleur format pour le web
     */
    static getBestWebFormat(originalFormat) {
        // Priorité: WebP > AVIF > JPEG > PNG
        const supportModern = true; // À adapter selon le support navigateur

        if (supportModern) {
            if (originalFormat === 'png') {
                return 'webp'; // Garde la transparence
            }
            return 'webp'; // Meilleure compression générale
        }

        // Fallback pour anciens navigateurs
        return originalFormat === 'png' ? 'png' : 'jpeg';
    }

    /**
     * Redimensionner par lot
     */
    static async batchResize(inputPaths, outputDir, settings = {}) {
        const results = [];
        
        for (const inputPath of inputPaths) {
            try {
                const filename = path.basename(inputPath);
                const outputPath = path.join(outputDir, filename);
                
                const result = await this.processImage(inputPath, outputPath, settings);
                results.push({ ...result, inputPath });
            } catch (error) {
                logger.error(`Erreur traitement ${inputPath}:`, error);
                results.push({
                    success: false,
                    inputPath,
                    error: error.message
                });
            }
        }

        return results;
    }

    /**
     * Valider qu'un fichier est bien une image
     */
    static async validateImage(imagePath) {
        try {
            const metadata = await sharp(imagePath).metadata();
            return {
                isValid: true,
                format: metadata.format,
                width: metadata.width,
                height: metadata.height
            };
        } catch (error) {
            return {
                isValid: false,
                error: error.message
            };
        }
    }
}

module.exports = ImageService;


================================================
File: backend/src/services/jobService.js
================================================
// backend/src/services/jobService.js
const { getRedisClient } = require('../utils/redis');
const logger = require('../utils/logger');

const JOB_PREFIX = 'job:';
const JOB_INDEX = 'jobs:index';

/**
 * Service de gestion des jobs de traitement de fichiers
 */
class JobService {
    /**
     * Créer un nouveau job
     */
    static async createJob(jobData) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobData.id}`;
            
            // Sérialiser les données complexes
            const serializedData = {
                ...jobData,
                settings: JSON.stringify(jobData.settings),
                createdAt: jobData.createdAt || new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            // Stocker le job dans Redis
            await redis.hSet(jobKey, serializedData);
            
            // Ajouter à l'index des jobs
            await redis.sAdd(JOB_INDEX, jobData.id);
            
            // Expiration après 7 jours
            await redis.expire(jobKey, 7 * 24 * 60 * 60);
            
            logger.info(`Job créé: ${jobData.id}`);
            return jobData;
        } catch (error) {
            logger.error('Erreur création job:', error);
            throw error;
        }
    }

    /**
     * Récupérer un job par son ID
     */
    static async getJob(jobId) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobId}`;
            const jobData = await redis.hGetAll(jobKey);
            
            if (!jobData || Object.keys(jobData).length === 0) {
                return null;
            }
            
            // Désérialiser les données JSON
            if (jobData.settings) {
                jobData.settings = JSON.parse(jobData.settings);
            }
            
            // Convertir les nombres
            if (jobData.size) jobData.size = parseInt(jobData.size);
            if (jobData.compressedSize) jobData.compressedSize = parseInt(jobData.compressedSize);
            if (jobData.progress) jobData.progress = parseInt(jobData.progress);
            if (jobData.compressionRatio) jobData.compressionRatio = parseInt(jobData.compressionRatio);
            
            return jobData;
        } catch (error) {
            logger.error(`Erreur récupération job ${jobId}:`, error);
            throw error;
        }
    }

    /**
     * Mettre à jour un job
     */
    static async updateJob(jobId, updates) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobId}`;
            
            // Sérialiser les objets complexes
            const serializedUpdates = {
                ...updates,
                updatedAt: new Date().toISOString()
            };
            
            // Sérialiser les objets si nécessaire
            for (const [key, value] of Object.entries(serializedUpdates)) {
                if (typeof value === 'object' && value !== null && key !== 'updatedAt') {
                    serializedUpdates[key] = JSON.stringify(value);
                }
            }
            
            await redis.hSet(jobKey, serializedUpdates);
            logger.debug(`Job mis à jour: ${jobId}`);
            
            return true;
        } catch (error) {
            logger.error(`Erreur mise à jour job ${jobId}:`, error);
            throw error;
        }
    }

    /**
     * Supprimer un job
     */
    static async deleteJob(jobId) {
        try {
            const redis = getRedisClient();
            const jobKey = `${JOB_PREFIX}${jobId}`;
            
            await redis.del(jobKey);
            await redis.sRem(JOB_INDEX, jobId);
            
            logger.info(`Job supprimé: ${jobId}`);
            return true;
        } catch (error) {
            logger.error(`Erreur suppression job ${jobId}:`, error);
            throw error;
        }
    }

    /**
     * Récupérer tous les jobs
     */
    static async getAllJobs(limit = 100) {
        try {
            const redis = getRedisClient();
            const jobIds = await redis.sMembers(JOB_INDEX);
            
            const jobs = [];
            for (const jobId of jobIds.slice(0, limit)) {
                const job = await this.getJob(jobId);
                if (job) {
                    jobs.push(job);
                }
            }
            
            // Trier par date de création (plus récent en premier)
            jobs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            
            return jobs;
        } catch (error) {
            logger.error('Erreur récupération jobs:', error);
            throw error;
        }
    }

    /**
     * Récupérer les statistiques des jobs
     */
    static async getJobStats() {
        try {
            const redis = getRedisClient();
            const jobIds = await redis.sMembers(JOB_INDEX);
            
            const stats = {
                total: jobIds.length,
                uploaded: 0,
                queued: 0,
                processing: 0,
                completed: 0,
                error: 0
            };
            
            for (const jobId of jobIds) {
                const job = await this.getJob(jobId);
                if (job && job.status) {
                    stats[job.status] = (stats[job.status] || 0) + 1;
                }
            }
            
            return stats;
        } catch (error) {
            logger.error('Erreur stats jobs:', error);
            throw error;
        }
    }

    /**
     * Nettoyer les jobs expirés
     */
    static async cleanupExpiredJobs(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 jours par défaut
        try {
            const redis = getRedisClient();
            const jobIds = await redis.sMembers(JOB_INDEX);
            const now = new Date();
            let cleanedCount = 0;
            
            for (const jobId of jobIds) {
                const job = await this.getJob(jobId);
                if (job) {
                    const createdAt = new Date(job.createdAt);
                    if (now - createdAt > maxAge) {
                        await this.deleteJob(jobId);
                        cleanedCount++;
                    }
                }
            }
            
            if (cleanedCount > 0) {
                logger.info(`Jobs nettoyés: ${cleanedCount}`);
            }
            
            return cleanedCount;
        } catch (error) {
            logger.error('Erreur nettoyage jobs:', error);
            throw error;
        }
    }
}

module.exports = JobService;


================================================
File: backend/src/services/processingService.js
================================================
// backend/src/services/processingService.js
const path = require('path');
const JobService = require('./jobService');
const FileService = require('./fileService');
const ImageService = require('./imageService');
const logger = require('../utils/logger');

/**
 * Service principal de traitement des fichiers
 */
class ProcessingService {
    /**
     * Traiter un fichier selon son type
     */
    static async processFile(jobData, progressCallback) {
        const fileType = FileService.getFileType(jobData.originalName);
        
        try {
            // Mettre à jour le statut à "processing"
            await JobService.updateJob(jobData.id, { 
                status: 'processing',
                progress: 5
            });
            
            progressCallback(10);
            
            let result;
            switch (fileType) {
                case 'image':
                    result = await this.processImage(jobData, progressCallback);
                    break;
                case 'video':
                    result = await this.processVideo(jobData, progressCallback);
                    break;
                case 'audio':
                    result = await this.processAudio(jobData, progressCallback);
                    break;
                case 'document':
                    result = await this.processDocument(jobData, progressCallback);
                    break;
                default:
                    throw new Error(`Type de fichier non supporté: ${fileType}`);
            }
            
            progressCallback(100);
            
            // Mettre à jour le job avec les résultats
            await JobService.updateJob(jobData.id, {
                status: 'completed',
                outputPath: result.outputPath,
                compressedSize: result.compressedSize,
                compressionRatio: result.compressionRatio,
                progress: 100
            });
            
            logger.info(`Traitement terminé pour job ${jobData.id}`);
            return result;
            
        } catch (error) {
            logger.error(`Erreur traitement job ${jobData.id}:`, error);
            
            await JobService.updateJob(jobData.id, {
                status: 'error',
                error: error.message,
                progress: 0
            });
            
            throw error;
        }
    }

    /**
     * Traiter une image
     */
    static async processImage(jobData, progressCallback) {
        try {
            logger.info(`Traitement image: ${jobData.originalName}`);
            
            // Préparer les chemins
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            // Déterminer l'extension de sortie
            const outputExt = jobData.settings.format === 'auto' 
                ? path.extname(jobData.filePath) 
                : `.${jobData.settings.format}`;
            
            const outputPath = path.join(outputDir, `${jobData.id}${outputExt}`);
            
            progressCallback(20);
            
            // Traiter l'image avec ImageService
            const result = await ImageService.processImage(
                jobData.filePath, 
                outputPath, 
                jobData.settings
            );
            
            progressCallback(80);
            
            // Vérifier que le fichier de sortie existe
            const outputStats = await FileService.getFileStats(outputPath);
            if (!outputStats) {
                throw new Error('Fichier de sortie non créé');
            }
            
            logger.info(`Image traitée: ${jobData.originalName} -> ${FileService.formatFileSize(outputStats.size)}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: FileService.calculateCompressionRatio(jobData.size, outputStats.size)
            };
            
        } catch (error) {
            logger.error(`Erreur traitement image ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Traiter une vidéo (implémentation basique)
     */
    static async processVideo(jobData, progressCallback) {
        try {
            logger.info(`Traitement vidéo: ${jobData.originalName}`);
            
            // Pour le moment, copie simple du fichier
            // TODO: Implémenter FFmpeg pour compression vidéo
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            const outputPath = path.join(outputDir, `${jobData.id}_processed${path.extname(jobData.filePath)}`);
            
            progressCallback(30);
            
            // Copie temporaire (à remplacer par traitement FFmpeg)
            await FileService.copyFile(jobData.filePath, outputPath);
            
            progressCallback(90);
            
            const outputStats = await FileService.getFileStats(outputPath);
            
            logger.info(`Vidéo "traitée": ${jobData.originalName}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: 0 // Pas de compression pour le moment
            };
            
        } catch (error) {
            logger.error(`Erreur traitement vidéo ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Traiter un fichier audio (implémentation basique)
     */
    static async processAudio(jobData, progressCallback) {
        try {
            logger.info(`Traitement audio: ${jobData.originalName}`);
            
            // Pour le moment, copie simple du fichier
            // TODO: Implémenter FFmpeg pour compression audio
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            const outputPath = path.join(outputDir, `${jobData.id}_processed${path.extname(jobData.filePath)}`);
            
            progressCallback(40);
            
            // Copie temporaire (à remplacer par traitement FFmpeg)
            await FileService.copyFile(jobData.filePath, outputPath);
            
            progressCallback(90);
            
            const outputStats = await FileService.getFileStats(outputPath);
            
            logger.info(`Audio "traité": ${jobData.originalName}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: 0 // Pas de compression pour le moment
            };
            
        } catch (error) {
            logger.error(`Erreur traitement audio ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Traiter un document (implémentation basique)
     */
    static async processDocument(jobData, progressCallback) {
        try {
            logger.info(`Traitement document: ${jobData.originalName}`);
            
            // Pour le moment, copie simple du fichier
            // TODO: Implémenter compression PDF
            const outputDir = path.join(process.env.TEMP_DIR || '/tmp/uploads', 'output');
            await FileService.ensureDirectoryExists(outputDir);
            
            const outputPath = path.join(outputDir, `${jobData.id}_processed.pdf`);
            
            progressCallback(50);
            
            // Copie temporaire (à remplacer par traitement PDF)
            await FileService.copyFile(jobData.filePath, outputPath);
            
            progressCallback(90);
            
            const outputStats = await FileService.getFileStats(outputPath);
            
            logger.info(`Document "traité": ${jobData.originalName}`);
            
            return {
                outputPath,
                compressedSize: outputStats.size,
                compressionRatio: 0 // Pas de compression pour le moment
            };
            
        } catch (error) {
            logger.error(`Erreur traitement document ${jobData.id}:`, error);
            throw error;
        }
    }

    /**
     * Valider un job avant traitement
     */
    static async validateJob(jobData) {
        const errors = [];

        // Vérifier que le fichier existe
        const fileStats = await FileService.getFileStats(jobData.filePath);
        if (!fileStats) {
            errors.push('Fichier source introuvable');
        }

        // Vérifier le type de fichier
        if (!FileService.isValidFileType(jobData.originalName)) {
            errors.push('Type de fichier non supporté');
        }

        // Vérifier les paramètres selon le type
        const fileType = FileService.getFileType(jobData.originalName);
        const validationErrors = this.validateSettings(fileType, jobData.settings);
        errors.push(...validationErrors);

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Valider les paramètres selon le type de fichier
     */
    static validateSettings(fileType, settings) {
        const errors = [];

        switch (fileType) {
            case 'image':
                if (settings.quality && (settings.quality < 1 || settings.quality > 100)) {
                    errors.push('Qualité doit être entre 1 et 100');
                }
                if (settings.maxWidth && settings.maxWidth < 100) {
                    errors.push('Largeur minimum: 100px');
                }
                if (settings.maxHeight && settings.maxHeight < 100) {
                    errors.push('Hauteur minimum: 100px');
                }
                break;
            
            case 'video':
                if (settings.crf && (settings.crf < 18 || settings.crf > 51)) {
                    errors.push('CRF doit être entre 18 et 51');
                }
                break;
                
            case 'audio':
                if (settings.sampleRate && ![22050, 44100, 48000].includes(settings.sampleRate)) {
                    errors.push('Fréquence d\'échantillonnage non supportée');
                }
                break;
        }

        return errors;
    }

    /**
     * Obtenir les paramètres par défaut selon le type de fichier
     */
    static getDefaultSettings(fileType) {
        const defaults = {
            image: {
                quality: 80,
                maxWidth: 1920,
                maxHeight: 1080,
                format: 'auto',
                removeMetadata: true
            },
            video: {
                codec: 'h264',
                crf: 23,
                preset: 'medium',
                maxBitrate: '2M'
            },
            audio: {
                codec: 'aac',
                bitrate: '128k',
                sampleRate: 44100
            },
            document: {
                compress: true,
                removeMetadata: true
            }
        };

        return defaults[fileType] || {};
    }

    /**
     * Estimer la durée de traitement
     */
    static estimateProcessingTime(fileType, fileSize) {
        // Estimation basique en secondes
        const sizeInMB = fileSize / (1024 * 1024);
        
        const estimates = {
            image: Math.max(2, sizeInMB * 0.5),      // ~0.5s par MB
            video: Math.max(10, sizeInMB * 2),       // ~2s par MB
            audio: Math.max(5, sizeInMB * 1),        // ~1s par MB
            document: Math.max(3, sizeInMB * 0.8)    // ~0.8s par MB
        };

        return Math.round(estimates[fileType] || 10);
    }
}

module.exports = ProcessingService;


================================================
File: backend/src/services/queueService.js
================================================
// backend/src/services/queueService.js
const Queue = require('bull');
const logger = require('../utils/logger');

/**
 * Service de gestion de la queue de traitement
 */
class QueueService {
    constructor() {
        this.processingQueue = null;
        this.initialized = false;
    }

    /**
     * Initialiser la queue
     */
    init() {
        if (this.initialized) return;

        try {
            // Configuration de la queue Bull
            this.processingQueue = new Queue('file processing', {
                redis: {
                    port: process.env.REDIS_PORT || 6379,
                    host: process.env.REDIS_HOST || 'localhost',
                    password: process.env.REDIS_PASSWORD || undefined
                },
                defaultJobOptions: {
                    removeOnComplete: 10,   // Garder 10 jobs complétés
                    removeOnFail: 50,       // Garder 50 jobs échoués
                    attempts: 3,            // 3 tentatives max
                    backoff: {
                        type: 'exponential',
                        delay: 2000
                    }
                }
            });

            // Événements de la queue
            this.setupEventListeners();
            
            this.initialized = true;
            logger.info('Queue service initialisé');
        } catch (error) {
            logger.error('Erreur initialisation queue:', error);
            throw error;
        }
    }

    /**
     * Configurer les événements de la queue
     */
    setupEventListeners() {
        this.processingQueue.on('completed', (job, result) => {
            logger.info(`Job complété: ${result.jobId}`);
        });

        this.processingQueue.on('failed', (job, err) => {
            logger.error(`Job échoué: ${job.data.jobData.id}`, err);
        });

        this.processingQueue.on('stalled', (job) => {
            logger.warn(`Job bloqué: ${job.data.jobData.id}`);
        });

        this.processingQueue.on('progress', (job, progress) => {
            logger.debug(`Job progrès: ${job.data.jobData.id} - ${progress}%`);
        });

        this.processingQueue.on('active', (job) => {
            logger.info(`Job démarré: ${job.data.jobData.id}`);
        });
    }

    /**
     * Ajouter un job à la queue
     */
    async addJob(jobData, options = {}) {
        try {
            if (!this.initialized) {
                this.init();
            }

            const job = await this.processingQueue.add('optimize-file', 
                { jobData }, 
                {
                    priority: this.getJobPriority(jobData),
                    delay: options.delay || 0,
                    ...options
                }
            );
            
            logger.info(`Job ajouté à la queue: ${jobData.id} (Bull ID: ${job.id})`);
            return job;
        } catch (error) {
            logger.error('Erreur ajout job à la queue:', error);
            throw error;
        }
    }

    /**
     * Calculer la priorité d'un job basée sur la taille du fichier
     */
    getJobPriority(jobData) {
        const sizeInMB = jobData.size / (1024 * 1024);
        
        // Plus le fichier est petit, plus la priorité est haute
        if (sizeInMB < 10) return 10;      // Très haute priorité
        if (sizeInMB < 100) return 5;      // Priorité normale
        return 1;                          // Basse priorité
    }

    /**
     * Obtenir les statistiques de la queue
     */
    async getQueueStats() {
        try {
            if (!this.initialized) {
                return null;
            }

            const waiting = await this.processingQueue.getWaiting();
            const active = await this.processingQueue.getActive();
            const completed = await this.processingQueue.getCompleted();
            const failed = await this.processingQueue.getFailed();
            const delayed = await this.processingQueue.getDelayed();
            
            return {
                waiting: waiting.length,
                active: active.length,
                completed: completed.length,
                failed: failed.length,
                delayed: delayed.length,
                total: waiting.length + active.length + completed.length + failed.length + delayed.length
            };
        } catch (error) {
            logger.error('Erreur stats queue:', error);
            return null;
        }
    }

    /**
     * Obtenir les jobs actifs
     */
    async getActiveJobs() {
        try {
            if (!this.initialized) {
                return [];
            }

            const activeJobs = await this.processingQueue.getActive();
            return activeJobs.map(job => ({
                id: job.id,
                jobId: job.data.jobData.id,
                progress: job.progress(),
                timestamp: job.timestamp,
                processedOn: job.processedOn
            }));
        } catch (error) {
            logger.error('Erreur récupération jobs actifs:', error);
            return [];
        }
    }

    /**
     * Nettoyer la queue
     */
    async cleanQueue() {
        try {
            if (!this.initialized) {
                return;
            }

            await this.processingQueue.clean(24 * 60 * 60 * 1000, 'completed'); // 24h
            await this.processingQueue.clean(7 * 24 * 60 * 60 * 1000, 'failed'); // 7 jours
            
            logger.info('Queue nettoyée');
        } catch (error) {
            logger.error('Erreur nettoyage queue:', error);
        }
    }

    /**
     * Fermer la queue
     */
    async close() {
        try {
            if (this.processingQueue) {
                await this.processingQueue.close();
                logger.info('Queue fermée');
            }
        } catch (error) {
            logger.error('Erreur fermeture queue:', error);
        }
    }

    /**
     * Obtenir la queue (pour le worker)
     */
    getQueue() {
        if (!this.initialized) {
            this.init();
        }
        return this.processingQueue;
    }
}

// Singleton
const queueService = new QueueService();

module.exports = {
    addJobToQueue: (jobData, options) => queueService.addJob(jobData, options),
    getQueueStats: () => queueService.getQueueStats(),
    getActiveJobs: () => queueService.getActiveJobs(),
    cleanQueue: () => queueService.cleanQueue(),
    closeQueue: () => queueService.close(),
    processingQueue: queueService.getQueue()
};


================================================
File: backend/src/utils/logger.js
================================================
// backend/src/utils/logger.js
const winston = require('winston');
const path = require('path');

/**
 * Configuration du système de logging avec Winston
 */
class Logger {
    constructor() {
        this.logger = null;
        this.init();
    }

    /**
     * Initialiser le logger Winston
     */
    init() {
        // Configuration des niveaux de log
        const levels = {
            error: 0,
            warn: 1,
            info: 2,
            http: 3,
            debug: 4
        };

        const colors = {
            error: 'red',
            warn: 'yellow',
            info: 'green',
            http: 'magenta',
            debug: 'cyan'
        };

        winston.addColors(colors);

        // Format personnalisé pour les logs
        const format = winston.format.combine(
            winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
            winston.format.errors({ stack: true }),
            winston.format.colorize({ all: true }),
            winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
                let log = `[${timestamp}] ${level}: ${message}`;
                
                // Ajouter la stack trace pour les erreurs
                if (stack) {
                    log += `\n${stack}`;
                }
                
                // Ajouter les métadonnées si présentes
                if (Object.keys(meta).length > 0) {
                    log += `\n${JSON.stringify(meta, null, 2)}`;
                }
                
                return log;
            })
        );

        // Configuration des transports
        const transports = [
            // Console pour le développement
            new winston.transports.Console({
                level: process.env.LOG_LEVEL || 'info',
                format
            })
        ];

        // Fichier de logs pour la production
        if (process.env.NODE_ENV === 'production') {
            const logDir = process.env.LOG_DIR || './logs';
            
            transports.push(
                // Logs généraux
                new winston.transports.File({
                    filename: path.join(logDir, 'app.log'),
                    level: 'info',
                    format: winston.format.combine(
                        winston.format.timestamp(),
                        winston.format.errors({ stack: true }),
                        winston.format.json()
                    ),
                    maxsize: 50 * 1024 * 1024, // 50MB
                    maxFiles: 5,
                    tailable: true
                }),
                
                // Logs d'erreurs séparés
                new winston.transports.File({
                    filename: path.join(logDir, 'error.log'),
                    level: 'error',
                    format: winston.format.combine(
                        winston.format.timestamp(),
                        winston.format.errors({ stack: true }),
                        winston.format.json()
                    ),
                    maxsize: 20 * 1024 * 1024, // 20MB
                    maxFiles: 5,
                    tailable: true
                })
            );
        }

        // Créer l'instance Winston
        this.logger = winston.createLogger({
            levels,
            level: process.env.LOG_LEVEL || 'info',
            transports,
            // Ne pas sortir sur les rejections non gérées
            exitOnError: false
        });

        // Gérer les exceptions non capturées
        this.logger.exceptions.handle(
            new winston.transports.Console({
                format
            })
        );

        // Gérer les rejections de promesses non gérées
        this.logger.rejections.handle(
            new winston.transports.Console({
                format
            })
        );
    }

    /**
     * Log de niveau info
     */
    info(message, meta = {}) {
        this.logger.info(message, meta);
    }

    /**
     * Log de niveau debug
     */
    debug(message, meta = {}) {
        this.logger.debug(message, meta);
    }

    /**
     * Log de niveau warn
     */
    warn(message, meta = {}) {
        this.logger.warn(message, meta);
    }

    /**
     * Log de niveau error
     */
    error(message, error = null, meta = {}) {
        if (error instanceof Error) {
            this.logger.error(message, { 
                error: error.message, 
                stack: error.stack,
                ...meta 
            });
        } else if (error) {
            this.logger.error(message, { error, ...meta });
        } else {
            this.logger.error(message, meta);
        }
    }

    /**
     * Log de niveau http pour les requêtes
     */
    http(message, meta = {}) {
        this.logger.http(message, meta);
    }

    /**
     * Logger spécialisé pour les jobs
     */
    job(jobId, message, meta = {}) {
        this.logger.info(`[JOB:${jobId}] ${message}`, meta);
    }

    /**
     * Logger spécialisé pour la queue
     */
    queue(message, meta = {}) {
        this.logger.info(`[QUEUE] ${message}`, meta);
    }

    /**
     * Logger spécialisé pour les fichiers
     */
    file(message, meta = {}) {
        this.logger.info(`[FILE] ${message}`, meta);
    }

    /**
     * Logger spécialisé pour le traitement
     */
    processing(message, meta = {}) {
        this.logger.info(`[PROCESSING] ${message}`, meta);
    }

    /**
     * Logger pour les performances
     */
    performance(operation, duration, meta = {}) {
        this.logger.info(`[PERF] ${operation} completed in ${duration}ms`, meta);
    }

    /**
     * Logger pour les métriques
     */
    metric(name, value, unit = '', meta = {}) {
        this.logger.info(`[METRIC] ${name}: ${value}${unit}`, meta);
    }

    /**
     * Logger pour la sécurité
     */
    security(message, meta = {}) {
        this.logger.warn(`[SECURITY] ${message}`, meta);
    }

    /**
     * Créer un timer pour mesurer les performances
     */
    timer(label) {
        const start = Date.now();
        return {
            end: (meta = {}) => {
                const duration = Date.now() - start;
                this.performance(label, duration, meta);
                return duration;
            }
        };
    }

    /**
     * Logger avec contexte (pour suivre une requête)
     */
    withContext(context) {
        return {
            info: (message, meta = {}) => this.info(message, { ...context, ...meta }),
            debug: (message, meta = {}) => this.debug(message, { ...context, ...meta }),
            warn: (message, meta = {}) => this.warn(message, { ...context, ...meta }),
            error: (message, error = null, meta = {}) => this.error(message, error, { ...context, ...meta }),
            http: (message, meta = {}) => this.http(message, { ...context, ...meta })
        };
    }

    /**
     * Obtenir l'instance Winston native si nécessaire
     */
    getInstance() {
        return this.logger;
    }

    /**
     * Créer un stream pour intégration avec Express Morgan
     */
    stream() {
        return {
            write: (message) => {
                this.http(message.trim());
            }
        };
    }

    /**
     * Changer le niveau de log à chaud
     */
    setLevel(level) {
        this.logger.level = level;
        this.logger.transports.forEach(transport => {
            if (transport.level !== 'error') { // Garder error.log sur error
                transport.level = level;
            }
        });
        this.info(`Log level changed to: ${level}`);
    }

    /**
     * Ajouter un transport personnalisé
     */
    addTransport(transport) {
        this.logger.add(transport);
    }

    /**
     * Supprimer un transport
     */
    removeTransport(transport) {
        this.logger.remove(transport);
    }

    /**
     * Vider les logs (pour les tests)
     */
    clear() {
        this.logger.clear();
    }

    /**
     * Fermer le logger proprement
     */
    close() {
        return new Promise((resolve) => {
            this.logger.on('finish', resolve);
            this.logger.end();
        });
    }
}

// Singleton
const logger = new Logger();

// Export des méthodes principales pour faciliter l'usage
module.exports = {
    info: logger.info.bind(logger),
    debug: logger.debug.bind(logger),
    warn: logger.warn.bind(logger),
    error: logger.error.bind(logger),
    http: logger.http.bind(logger),
    job: logger.job.bind(logger),
    queue: logger.queue.bind(logger),
    file: logger.file.bind(logger),
    processing: logger.processing.bind(logger),
    performance: logger.performance.bind(logger),
    metric: logger.metric.bind(logger),
    security: logger.security.bind(logger),
    timer: logger.timer.bind(logger),
    withContext: logger.withContext.bind(logger),
    stream: logger.stream.bind(logger),
    setLevel: logger.setLevel.bind(logger),
    getInstance: logger.getInstance.bind(logger),
    close: logger.close.bind(logger)
};


================================================
File: backend/src/utils/redis.js
================================================
// backend/src/utils/redis.js
const { createClient } = require('redis');
const logger = require('./logger');

/**
 * Client Redis singleton avec gestion de connexion robuste
 */
class RedisClient {
    constructor() {
        this.client = null;
        this.isConnected = false;
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.reconnectDelay = 1000; // 1 seconde
    }

    /**
     * Initialiser la connexion Redis
     */
    async init() {
        if (this.client && this.isConnected) {
            return this.client;
        }

        if (this.isConnecting) {
            // Attendre que la connexion en cours se termine
            return new Promise((resolve, reject) => {
                const checkConnection = () => {
                    if (this.isConnected && this.client) {
                        resolve(this.client);
                    } else if (!this.isConnecting) {
                        reject(new Error('Connection failed'));
                    } else {
                        setTimeout(checkConnection, 100);
                    }
                };
                checkConnection();
            });
        }

        this.isConnecting = true;

        try {
            // Configuration de la connexion
            const config = this.getRedisConfig();
            
            logger.info('Initialisation de la connexion Redis', { 
                host: config.socket?.host || config.host,
                port: config.socket?.port || config.port,
                database: config.database
            });

            this.client = createClient(config);

            // Gestionnaires d'événements
            this.setupEventHandlers();

            // Connexion
            await this.client.connect();
            
            this.isConnected = true;
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            
            logger.info('Redis connecté avec succès');
            
            // Test de la connexion
            await this.client.ping();
            
            return this.client;
        } catch (error) {
            this.isConnecting = false;
            this.isConnected = false;
            logger.error('Erreur connexion Redis:', error);
            throw error;
        }
    }

    /**
     * Obtenir la configuration Redis depuis les variables d'environnement
     */
    getRedisConfig() {
        const redisUrl = process.env.REDIS_URL;
        
        if (redisUrl) {
            // Parse de l'URL Redis
            return {
                url: redisUrl,
                retry_unfulfilled_commands: true,
                socket: {
                    reconnectStrategy: (retries) => {
                        if (retries >= this.maxReconnectAttempts) {
                            logger.error(`Redis: Trop de tentatives de reconnexion (${retries})`);
                            return false;
                        }
                        const delay = Math.min(retries * this.reconnectDelay, 30000);
                        logger.warn(`Redis: Tentative de reconnexion ${retries} dans ${delay}ms`);
                        return delay;
                    }
                }
            };
        }

        // Configuration par défaut
        return {
            socket: {
                host: process.env.REDIS_HOST || 'localhost',
                port: parseInt(process.env.REDIS_PORT) || 6379,
                reconnectStrategy: (retries) => {
                    if (retries >= this.maxReconnectAttempts) {
                        logger.error(`Redis: Trop de tentatives de reconnexion (${retries})`);
                        return false;
                    }
                    const delay = Math.min(retries * this.reconnectDelay, 30000);
                    logger.warn(`Redis: Tentative de reconnexion ${retries} dans ${delay}ms`);
                    return delay;
                }
            },
            password: process.env.REDIS_PASSWORD || undefined,
            database: parseInt(process.env.REDIS_DATABASE) || 0,
            retry_unfulfilled_commands: true
        };
    }

    /**
     * Configurer les gestionnaires d'événements Redis
     */
    setupEventHandlers() {
        this.client.on('ready', () => {
            logger.info('Redis client ready');
            this.isConnected = true;
            this.reconnectAttempts = 0;
        });

        this.client.on('connect', () => {
            logger.info('Redis client connected');
        });

        this.client.on('reconnecting', () => {
            this.reconnectAttempts++;
            logger.warn(`Redis reconnecting (attempt ${this.reconnectAttempts})`);
            this.isConnected = false;
        });

        this.client.on('error', (error) => {
            logger.error('Redis client error:', error);
            this.isConnected = false;
        });

        this.client.on('end', () => {
            logger.warn('Redis client disconnected');
            this.isConnected = false;
        });

        // Gestion gracieuse de l'arrêt
        process.on('SIGINT', () => this.gracefulShutdown('SIGINT'));
        process.on('SIGTERM', () => this.gracefulShutdown('SIGTERM'));
    }

    /**
     * Arrêt gracieux de Redis
     */
    async gracefulShutdown(signal) {
        logger.info(`Redis: Arrêt gracieux reçu (${signal})`);
        if (this.client && this.isConnected) {
            try {
                await this.client.quit();
                logger.info('Redis: Connexion fermée proprement');
            } catch (error) {
                logger.error('Redis: Erreur lors de la fermeture:', error);
            }
        }
    }

    /**
     * Obtenir le client Redis (avec auto-connexion)
     */
    async getClient() {
        if (!this.client || !this.isConnected) {
            await this.init();
        }
        return this.client;
    }

    /**
     * Vérifier si Redis est connecté
     */
    isHealthy() {
        return this.isConnected && this.client;
    }

    /**
     * Test de santé Redis
     */
    async healthCheck() {
        try {
            if (!this.isConnected || !this.client) {
                return { status: 'error', message: 'Not connected' };
            }

            const start = Date.now();
            await this.client.ping();
            const latency = Date.now() - start;

            return {
                status: 'ok',
                latency: `${latency}ms`,
                connected: this.isConnected,
                reconnectAttempts: this.reconnectAttempts
            };
        } catch (error) {
            return {
                status: 'error',
                message: error.message,
                connected: false
            };
        }
    }

    /**
     * Obtenir les informations de Redis
     */
    async getInfo() {
        try {
            const client = await this.getClient();
            const info = await client.info();
            const memory = await client.info('memory');
            
            return {
                info: this.parseRedisInfo(info),
                memory: this.parseRedisInfo(memory)
            };
        } catch (error) {
            logger.error('Erreur récupération info Redis:', error);
            return null;
        }
    }

    /**
     * Parser les informations Redis
     */
    parseRedisInfo(infoString) {
        const info = {};
        const lines = infoString.split('\r\n');
        
        lines.forEach(line => {
            if (line.includes(':') && !line.startsWith('#')) {
                const [key, value] = line.split(':');
                info[key] = isNaN(value) ? value : parseFloat(value);
            }
        });
        
        return info;
    }

    /**
     * Obtenir les métriques Redis
     */
    async getMetrics() {
        try {
            const client = await this.getClient();
            const info = await this.getInfo();
            
            if (!info) return null;

            const dbSize = await client.dbSize();
            const lastSave = await client.lastSave();
            
            return {
                connected_clients: info.info.connected_clients || 0,
                used_memory: info.memory.used_memory || 0,
                used_memory_human: info.memory.used_memory_human || '0B',
                total_commands_processed: info.info.total_commands_processed || 0,
                keyspace_hits: info.info.keyspace_hits || 0,
                keyspace_misses: info.info.keyspace_misses || 0,
                db_size: dbSize,
                last_save_time: lastSave,
                uptime_in_seconds: info.info.uptime_in_seconds || 0
            };
        } catch (error) {
            logger.error('Erreur récupération métriques Redis:', error);
            return null;
        }
    }

    /**
     * Nettoyer Redis (pour les tests)
     */
    async flush() {
        try {
            const client = await this.getClient();
            await client.flushDb();
            logger.info('Redis database flushed');
        } catch (error) {
            logger.error('Erreur flush Redis:', error);
            throw error;
        }
    }

    /**
     * Fermer la connexion Redis
     */
    async close() {
        if (this.client) {
            try {
                if (this.isConnected) {
                    await this.client.quit();
                }
                this.isConnected = false;
                this.client = null;
                logger.info('Redis client closed');
            } catch (error) {
                logger.error('Erreur fermeture Redis:', error);
            }
        }
    }

    /**
     * Wrapper pour les opérations Redis avec retry automatique
     */
    async withRetry(operation, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const client = await this.getClient();
                return await operation(client);
            } catch (error) {
                lastError = error;
                logger.warn(`Redis operation failed (attempt ${attempt}/${maxRetries}):`, error.message);
                
                if (attempt < maxRetries) {
                    // Attendre avant de retry
                    await new Promise(resolve => setTimeout(resolve, attempt * 1000));
                    // Réinitialiser la connexion si nécessaire
                    if (!this.isConnected) {
                        this.client = null;
                    }
                }
            }
        }
        
        throw lastError;
    }
}

// Singleton
const redisClient = new RedisClient();

/**
 * Obtenir le client Redis (fonction principale)
 */
async function getRedisClient() {
    return await redisClient.getClient();
}

/**
 * Wrapper simplifié pour les opérations courantes
 */
const redisOperations = {
    // GET
    get: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.get(key);
        });
    },

    // SET
    set: async (key, value, options = {}) => {
        return await redisClient.withRetry(async (client) => {
            return await client.set(key, value, options);
        });
    },

    // HGET ALL
    hGetAll: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.hGetAll(key);
        });
    },

    // HSET
    hSet: async (key, field, value) => {
        return await redisClient.withRetry(async (client) => {
            return await client.hSet(key, field, value);
        });
    },

    // DEL
    del: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.del(key);
        });
    },

    // EXISTS
    exists: async (key) => {
        return await redisClient.withRetry(async (client) => {
            return await client.exists(key);
        });
    },

    // EXPIRE
    expire: async (key, seconds) => {
        return await redisClient.withRetry(async (client) => {
            return await client.expire(key, seconds);
        });
    }
};

module.exports = {
    getRedisClient,
    redisClient,
    redisOperations,
    healthCheck: () => redisClient.healthCheck(),
    getInfo: () => redisClient.getInfo(),
    getMetrics: () => redisClient.getMetrics(),
    close: () => redisClient.close(),
    flush: () => redisClient.flush()
};


================================================
File: backend/src/utils/validation.js
================================================
// backend/src/utils/validation.js
const Joi = require('joi');
const FileService = require('../services/fileService');
const logger = require('./logger');

/**
 * Schémas de validation avec Joi
 */
class ValidationSchemas {
    /**
     * Validation des paramètres d'upload
     */
    static uploadSchema = Joi.object({
        file: Joi.object({
            originalname: Joi.string().required(),
            mimetype: Joi.string().required(),
            size: Joi.number().min(1).max(5 * 1024 * 1024 * 1024).required(), // 5GB max
            buffer: Joi.binary().required()
        }).required(),
        settings: Joi.object().optional()
    });

    /**
     * Validation des paramètres d'image
     */
    static imageSettingsSchema = Joi.object({
        quality: Joi.number().min(1).max(100).default(80),
        maxWidth: Joi.number().min(100).max(8000).default(1920),
        maxHeight: Joi.number().min(100).max(8000).default(1080),
        format: Joi.string().valid('auto', 'jpeg', 'jpg', 'png', 'webp', 'avif', 'tiff').default('auto'),
        removeMetadata: Joi.boolean().default(true),
        progressive: Joi.boolean().default(true)
    });

    /**
     * Validation des paramètres de vidéo
     */
    static videoSettingsSchema = Joi.object({
        codec: Joi.string().valid('h264', 'h265', 'vp9', 'av1').default('h264'),
        crf: Joi.number().min(18).max(51).default(23),
        preset: Joi.string().valid('ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow').default('medium'),
        maxBitrate: Joi.string().regex(/^\d+[KMG]?$/).default('2M'),
        fps: Joi.number().min(1).max(60).optional(),
        resolution: Joi.string().valid('480p', '720p', '1080p', '1440p', '4K').optional()
    });

    /**
     * Validation des paramètres d'audio
     */
    static audioSettingsSchema = Joi.object({
        codec: Joi.string().valid('aac', 'mp3', 'ogg', 'flac').default('aac'),
        bitrate: Joi.string().regex(/^\d+[k]?$/).default('128k'),
        sampleRate: Joi.number().valid(22050, 44100, 48000, 96000).default(44100),
        channels: Joi.number().valid(1, 2).default(2),
        normalize: Joi.boolean().default(false)
    });

    /**
     * Validation des paramètres de document
     */
    static documentSettingsSchema = Joi.object({
        compress: Joi.boolean().default(true),
        removeMetadata: Joi.boolean().default(true),
        quality: Joi.number().min(1).max(100).default(80),
        optimizeImages: Joi.boolean().default(true)
    });

    /**
     * Validation d'un job
     */
    static jobSchema = Joi.object({
        id: Joi.string().uuid().required(),
        originalName: Joi.string().min(1).max(255).required(),
        filePath: Joi.string().required(),
        size: Joi.number().min(1).required(),
        type: Joi.string().valid('image', 'video', 'audio', 'document').required(),
        settings: Joi.object().required(),
        status: Joi.string().valid('uploaded', 'queued', 'processing', 'completed', 'error').default('uploaded'),
        progress: Joi.number().min(0).max(100).default(0),
        createdAt: Joi.date().iso().default(() => new Date()),
        updatedAt: Joi.date().iso().default(() => new Date())
    });

    /**
     * Validation des paramètres de pagination
     */
    static paginationSchema = Joi.object({
        page: Joi.number().min(1).default(1),
        limit: Joi.number().min(1).max(100).default(20),
        sortBy: Joi.string().valid('createdAt', 'updatedAt', 'size', 'status').default('createdAt'),
        sortOrder: Joi.string().valid('asc', 'desc').default('desc')
    });

    /**
     * Validation des filtres de jobs
     */
    static jobFiltersSchema = Joi.object({
        status: Joi.string().valid('uploaded', 'queued', 'processing', 'completed', 'error').optional(),
        type: Joi.string().valid('image', 'video', 'audio', 'document').optional(),
        dateFrom: Joi.date().iso().optional(),
        dateTo: Joi.date().iso().optional(),
        minSize: Joi.number().min(0).optional(),
        maxSize: Joi.number().min(0).optional()
    });

    /**
     * Validation d'un ID de job
     */
    static jobIdSchema = Joi.string().uuid().required();

    /**
     * Validation des paramètres de health check
     */
    static healthCheckSchema = Joi.object({
        includeMetrics: Joi.boolean().default(false),
        includeRedis: Joi.boolean().default(true),
        includeQueue: Joi.boolean().default(true)
    });
}

/**
 * Service de validation
 */
class ValidationService {
    /**
     * Valider un fichier uploadé
     */
    static async validateUpload(file, settings = {}) {
        try {
            // Validation de base
            const { error: baseError, value: validatedData } = ValidationSchemas.uploadSchema.validate({
                file,
                settings
            });

            if (baseError) {
                return {
                    isValid: false,
                    errors: baseError.details.map(detail => detail.message)
                };
            }

            const errors = [];

            // Vérification du type de fichier
            const fileType = FileService.getFileType(file.originalname);
            if (fileType === 'unknown') {
                errors.push('Type de fichier non supporté');
            }

            // Vérification de l'extension vs MIME type
            if (!this.validateMimeType(file.originalname, file.mimetype)) {
                errors.push('Extension de fichier et type MIME incompatibles');
            }

            // Validation des paramètres selon le type
            if (fileType !== 'unknown') {
                const settingsValidation = this.validateSettings(fileType, settings);
                if (!settingsValidation.isValid) {
                    errors.push(...settingsValidation.errors);
                }
            }

            // Vérification de la taille selon le type
            const maxSizeValidation = this.validateFileSize(fileType, file.size);
            if (!maxSizeValidation.isValid) {
                errors.push(maxSizeValidation.error);
            }

            return {
                isValid: errors.length === 0,
                errors,
                validatedData: errors.length === 0 ? validatedData : null,
                fileType
            };

        } catch (error) {
            logger.error('Erreur validation upload:', error);
            return {
                isValid: false,
                errors: ['Erreur interne de validation']
            };
        }
    }

    /**
     * Valider les paramètres selon le type de fichier
     */
    static validateSettings(fileType, settings) {
        try {
            let schema;
            
            switch (fileType) {
                case 'image':
                    schema = ValidationSchemas.imageSettingsSchema;
                    break;
                case 'video':
                    schema = ValidationSchemas.videoSettingsSchema;
                    break;
                case 'audio':
                    schema = ValidationSchemas.audioSettingsSchema;
                    break;
                case 'document':
                    schema = ValidationSchemas.documentSettingsSchema;
                    break;
                default:
                    return { isValid: true, validatedSettings: settings };
            }

            const { error, value } = schema.validate(settings, { allowUnknown: false });
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedSettings: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedSettings: value
            };

        } catch (error) {
            logger.error('Erreur validation settings:', error);
            return {
                isValid: false,
                errors: ['Erreur validation des paramètres']
            };
        }
    }

    /**
     * Valider la correspondance entre extension et MIME type
     */
    static validateMimeType(filename, mimetype) {
        const mimeTypeMap = {
            // Images
            '.jpg': ['image/jpeg'],
            '.jpeg': ['image/jpeg'],
            '.png': ['image/png'],
            '.webp': ['image/webp'],
            '.avif': ['image/avif'],
            '.heic': ['image/heic', 'image/heif'],
            '.tiff': ['image/tiff'],
            '.bmp': ['image/bmp'],
            
            // Vidéos
            '.mp4': ['video/mp4'],
            '.avi': ['video/x-msvideo'],
            '.mkv': ['video/x-matroska'],
            '.webm': ['video/webm'],
            '.mov': ['video/quicktime'],
            '.flv': ['video/x-flv'],
            '.m4v': ['video/x-m4v'],
            
            // Audio
            '.mp3': ['audio/mpeg'],
            '.flac': ['audio/flac'],
            '.wav': ['audio/wav', 'audio/wave'],
            '.aac': ['audio/aac'],
            '.ogg': ['audio/ogg'],
            '.m4a': ['audio/mp4', 'audio/x-m4a'],
            '.wma': ['audio/x-ms-wma'],
            
            // Documents
            '.pdf': ['application/pdf']
        };

        const ext = require('path').extname(filename).toLowerCase();
        const allowedMimeTypes = mimeTypeMap[ext];

        if (!allowedMimeTypes) {
            return false; // Extension non supportée
        }

        return allowedMimeTypes.includes(mimetype);
    }

    /**
     * Valider la taille de fichier selon le type
     */
    static validateFileSize(fileType, size) {
        const maxSizes = {
            image: 100 * 1024 * 1024,    // 100MB
            video: 5 * 1024 * 1024 * 1024, // 5GB
            audio: 500 * 1024 * 1024,    // 500MB
            document: 100 * 1024 * 1024  // 100MB
        };

        const maxSize = maxSizes[fileType] || 100 * 1024 * 1024; // 100MB par défaut

        if (size > maxSize) {
            return {
                isValid: false,
                error: `Taille de fichier trop importante (max: ${this.formatFileSize(maxSize)})`
            };
        }

        return { isValid: true };
    }

    /**
     * Valider un job complet
     */
    static validateJob(jobData) {
        try {
            const { error, value } = ValidationSchemas.jobSchema.validate(jobData);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedJob: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedJob: value
            };

        } catch (error) {
            logger.error('Erreur validation job:', error);
            return {
                isValid: false,
                errors: ['Erreur validation du job']
            };
        }
    }

    /**
     * Valider les paramètres de pagination
     */
    static validatePagination(params) {
        try {
            const { error, value } = ValidationSchemas.paginationSchema.validate(params);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedParams: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedParams: value
            };

        } catch (error) {
            logger.error('Erreur validation pagination:', error);
            return {
                isValid: false,
                errors: ['Erreur validation pagination']
            };
        }
    }

    /**
     * Valider les filtres de jobs
     */
    static validateJobFilters(filters) {
        try {
            const { error, value } = ValidationSchemas.jobFiltersSchema.validate(filters);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedFilters: null
                };
            }

            // Validation additionnelle pour les dates
            if (value.dateFrom && value.dateTo && value.dateFrom > value.dateTo) {
                return {
                    isValid: false,
                    errors: ['La date de début doit être antérieure à la date de fin'],
                    validatedFilters: null
                };
            }

            // Validation additionnelle pour les tailles
            if (value.minSize && value.maxSize && value.minSize > value.maxSize) {
                return {
                    isValid: false,
                    errors: ['La taille minimum doit être inférieure à la taille maximum'],
                    validatedFilters: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedFilters: value
            };

        } catch (error) {
            logger.error('Erreur validation filtres:', error);
            return {
                isValid: false,
                errors: ['Erreur validation des filtres']
            };
        }
    }

    /**
     * Valider un ID de job
     */
    static validateJobId(jobId) {
        try {
            const { error, value } = ValidationSchemas.jobIdSchema.validate(jobId);
            
            if (error) {
                return {
                    isValid: false,
                    errors: ['ID de job invalide (UUID requis)'],
                    validatedId: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedId: value
            };

        } catch (error) {
            logger.error('Erreur validation ID job:', error);
            return {
                isValid: false,
                errors: ['Erreur validation ID']
            };
        }
    }

    /**
     * Valider les paramètres de health check
     */
    static validateHealthCheck(params) {
        try {
            const { error, value } = ValidationSchemas.healthCheckSchema.validate(params);
            
            if (error) {
                return {
                    isValid: false,
                    errors: error.details.map(detail => detail.message),
                    validatedParams: null
                };
            }

            return {
                isValid: true,
                errors: [],
                validatedParams: value
            };

        } catch (error) {
            logger.error('Erreur validation health check:', error);
            return {
                isValid: false,
                errors: ['Erreur validation health check']
            };
        }
    }

    /**
     * Nettoyer et valider un nom de fichier
     */
    static sanitizeFilename(filename) {
        if (!filename || typeof filename !== 'string') {
            return null;
        }

        // Supprimer les caractères dangereux
        let cleaned = filename
            .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_') // Caractères interdits
            .replace(/^\.+/, '_') // Points au début
            .replace(/\.+$/, '') // Points à la fin
            .replace(/\s+/g, '_') // Espaces multiples
            .trim();

        // Limiter la longueur
        if (cleaned.length > 255) {
            const ext = require('path').extname(cleaned);
            const name = require('path').basename(cleaned, ext);
            cleaned = name.substring(0, 255 - ext.length) + ext;
        }

        // Vérifier qu'il reste quelque chose
        if (!cleaned || cleaned === '_') {
            return null;
        }

        return cleaned;
    }

    /**
     * Valider et nettoyer les en-têtes HTTP
     */
    static validateHeaders(headers) {
        const allowedHeaders = [
            'content-type',
            'content-length',
            'authorization',
            'x-requested-with',
            'user-agent'
        ];

        const cleanHeaders = {};
        
        for (const [key, value] of Object.entries(headers)) {
            const lowerKey = key.toLowerCase();
            if (allowedHeaders.includes(lowerKey)) {
                cleanHeaders[lowerKey] = value;
            }
        }

        return cleanHeaders;
    }

    /**
     * Formater la taille d'un fichier
     */
    static formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Middleware Express pour validation automatique
     */
    static createValidationMiddleware(schema, property = 'body') {
        return (req, res, next) => {
            const { error, value } = schema.validate(req[property]);
            
            if (error) {
                const errors = error.details.map(detail => detail.message);
                logger.security(`Validation failed: ${errors.join(', ')}`, {
                    ip: req.ip,
                    userAgent: req.get('User-Agent'),
                    path: req.path
                });
                
                return res.status(400).json({
                    success: false,
                    error: 'Données invalides',
                    details: errors
                });
            }

            req[property] = value;
            next();
        };
    }

    /**
     * Validation de sécurité pour les uploads
     */
    static validateUploadSecurity(file, req) {
        const errors = [];

        // Vérifier les magic bytes (signatures de fichier)
        if (!this.validateMagicBytes(file.buffer, file.originalname)) {
            errors.push('Signature de fichier invalide');
        }

        // Vérifier la taille réelle vs déclarée
        if (file.buffer.length !== file.size) {
            errors.push('Taille de fichier incohérente');
        }

        // Vérifier les métadonnées suspectes
        if (this.containsSuspiciousContent(file.originalname)) {
            errors.push('Nom de fichier suspect');
        }

        // Rate limiting par IP
        const userAgent = req.get('User-Agent') || '';
        if (this.isSuspiciousUserAgent(userAgent)) {
            errors.push('User-Agent suspect');
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Valider les magic bytes d'un fichier
     */
    static validateMagicBytes(buffer, filename) {
        if (!buffer || buffer.length < 4) return false;

        const magicBytes = {
            // Images
            'jpg': [0xFF, 0xD8, 0xFF],
            'png': [0x89, 0x50, 0x4E, 0x47],
            'webp': [0x52, 0x49, 0x46, 0x46], // + WEBP à l'offset 8
            'pdf': [0x25, 0x50, 0x44, 0x46],
            // Ajouter d'autres signatures selon les besoins
        };

        const ext = require('path').extname(filename).toLowerCase().substring(1);
        const expectedSignature = magicBytes[ext];

        if (!expectedSignature) {
            return true; // Pas de signature connue, on laisse passer
        }

        for (let i = 0; i < expectedSignature.length; i++) {
            if (buffer[i] !== expectedSignature[i]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Détecter du contenu suspect dans un nom de fichier
     */
    static containsSuspiciousContent(filename) {
        const suspiciousPatterns = [
            /\.(exe|bat|cmd|scr|pif|com)$/i,
            /\.(php|asp|jsp|cgi)$/i,
            /<script/i,
            /javascript:/i,
            /\.\./,
            /^(con|prn|aux|nul|com[1-9]|lpt[1-9])$/i
        ];

        return suspiciousPatterns.some(pattern => pattern.test(filename));
    }

    /**
     * Détecter un User-Agent suspect
     */
    static isSuspiciousUserAgent(userAgent) {
        if (!userAgent || userAgent.length < 10) return true;
        
        const suspiciousPatterns = [
            /bot|crawler|spider|scraper/i,
            /^curl/i,
            /^wget/i,
            /python-requests/i
        ];

        return suspiciousPatterns.some(pattern => pattern.test(userAgent));
    }
}

/**
 * Middleware de validation rapide pour les routes Express
 */
const validateRequest = {
    upload: ValidationService.createValidationMiddleware(ValidationSchemas.uploadSchema),
    jobId: ValidationService.createValidationMiddleware(ValidationSchemas.jobIdSchema, 'params'),
    pagination: ValidationService.createValidationMiddleware(ValidationSchemas.paginationSchema, 'query'),
    jobFilters: ValidationService.createValidationMiddleware(ValidationSchemas.jobFiltersSchema, 'query'),
    healthCheck: ValidationService.createValidationMiddleware(ValidationSchemas.healthCheckSchema, 'query')
};

module.exports = {
    ValidationSchemas,
    ValidationService,
    validateRequest
};


================================================
File: backend/src/workers/processor.js
================================================
// backend/src/workers/processor.js
require('dotenv').config();

const { processingQueue } = require('../services/queueService');
const ProcessingService = require('../services/processingService');
const JobService = require('../services/jobService');
const FileService = require('../services/fileService');
const logger = require('../utils/logger');
const { getRedisClient } = require('../utils/redis');

/**
 * Worker de traitement des fichiers multimédia
 */
class FileProcessor {
    constructor() {
        this.isShuttingDown = false;
        this.activeJobs = new Map();
        this.stats = {
            processed: 0,
            failed: 0,
            startTime: Date.now(),
            totalProcessingTime: 0
        };
    }

    /**
     * Initialiser le worker
     */
    async init() {
        try {
            logger.info('🔧 Initialisation du worker de traitement');

            // Vérifier les prérequis
            await this.checkPrerequisites();

            // Configuration du worker
            this.setupWorker();

            // Gestion gracieuse de l'arrêt
            this.setupGracefulShutdown();

            // Monitoring périodique
            this.setupMonitoring();

            logger.info('✅ Worker de traitement initialisé');
        } catch (error) {
            logger.error('❌ Erreur initialisation worker:', error);
            throw error;
        }
    }

    /**
     * Vérifier les prérequis
     */
    async checkPrerequisites() {
        try {
            // Vérifier Redis
            const redis = await getRedisClient();
            await redis.ping();
            logger.info('✅ Redis connecté');

            // Vérifier Sharp
            const sharp = require('sharp');
            logger.info(`✅ Sharp v${sharp.versions.sharp} disponible`);

            // Vérifier les répertoires
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            await FileService.ensureDirectoryExists(tempDir);
            await FileService.ensureDirectoryExists(`${tempDir}/output`);
            logger.info('✅ Répertoires vérifiés');

        } catch (error) {
            throw new Error(`Prérequis worker non satisfaits: ${error.message}`);
        }
    }

    /**
     * Configuration du worker Bull
     */
    setupWorker() {
        logger.info('⚙️ Configuration du worker Bull...');

        const concurrency = parseInt(process.env.WORKER_CONCURRENCY) || 2;
        const jobTimeout = parseInt(process.env.JOB_TIMEOUT) || 1800; // 30 minutes

        // Configuration du processeur principal
        processingQueue.process('optimize-file', concurrency, async (job) => {
            return await this.processJob(job);
        });

        // Événements du worker
        processingQueue.on('active', (job) => {
            const jobData = job.data.jobData;
            this.activeJobs.set(job.id, {
                jobId: jobData.id,
                startTime: Date.now(),
                fileName: jobData.originalName,
                type: jobData.type
            });

            logger.processing(`Job démarré: ${jobData.id} (${jobData.originalName})`);
        });

        processingQueue.on('completed', (job, result) => {
            const activeJob = this.activeJobs.get(job.id);
            if (activeJob) {
                const processingTime = Date.now() - activeJob.startTime;
                this.stats.processed++;
                this.stats.totalProcessingTime += processingTime;
                
                logger.processing(`Job terminé: ${result.jobId} en ${processingTime}ms`);
                this.activeJobs.delete(job.id);
            }
        });

        processingQueue.on('failed', (job, error) => {
            const activeJob = this.activeJobs.get(job.id);
            if (activeJob) {
                this.stats.failed++;
                logger.error(`Job échoué: ${activeJob.jobId}`, error);
                this.activeJobs.delete(job.id);
            }
        });

        processingQueue.on('stalled', (job) => {
            const jobData = job.data.jobData;
            logger.warn(`Job bloqué: ${jobData.id} (${jobData.originalName})`);
        });

        processingQueue.on('progress', (job, progress) => {
            const jobData = job.data.jobData;
            logger.debug(`Progression ${jobData.id}: ${progress}%`);
        });

        logger.info(`✅ Worker configuré (concurrence: ${concurrency}, timeout: ${jobTimeout}s)`);
    }

    /**
     * Traiter un job
     */
    async processJob(bullJob) {
        const { jobData } = bullJob.data;
        const startTime = Date.now();
        
        const jobLogger = logger.withContext({
            jobId: jobData.id,
            worker: 'processor',
            fileName: jobData.originalName
        });

        try {
            jobLogger.info('🔄 Démarrage du traitement');

            // Validation préalable
            const validation = await ProcessingService.validateJob(jobData);
            if (!validation.isValid) {
                throw new Error(`Validation échouée: ${validation.errors.join(', ')}`);
            }

            // Callback de progression pour Bull et WebSocket
            const progressCallback = async (progress) => {
                // Mettre à jour Bull
                bullJob.progress(progress);
                
                // Mettre à jour Redis
                await JobService.updateJob(jobData.id, { progress });
                
                // Notifier via WebSocket (si serveur disponible)
                if (global.io) {
                    global.io.emitJobProgress(jobData.id, progress);
                }
                
                jobLogger.debug(`Progression: ${progress}%`);
            };

            // Traitement principal
            jobLogger.info('🚀 Début du traitement du fichier');
            const result = await ProcessingService.processFile(jobData, progressCallback);

            const processingTime = Date.now() - startTime;
            jobLogger.info(`✅ Traitement terminé en ${processingTime}ms`);

            // Notifier la completion via WebSocket
            if (global.io) {
                global.io.emitJobCompleted(jobData.id, {
                    status: 'completed',
                    ...result,
                    processingTime
                });
            }

            // Métriques
            this.recordMetrics(jobData, processingTime, result);

            return {
                jobId: jobData.id,
                success: true,
                ...result,
                processingTime
            };

        } catch (error) {
            const processingTime = Date.now() - startTime;
            
            jobLogger.error('❌ Erreur traitement:', error, { processingTime });

            // Mettre à jour le job en erreur
            await JobService.updateJob(jobData.id, {
                status: 'error',
                error: error.message,
                progress: 0
            });

            // Notifier l'erreur via WebSocket
            if (global.io) {
                global.io.emitJobError(jobData.id, error);
            }

            // Nettoyer les fichiers en cas d'erreur
            await this.cleanupJobFiles(jobData);

            throw error;
        }
    }

    /**
     * Nettoyer les fichiers d'un job en erreur
     */
    async cleanupJobFiles(jobData) {
        try {
            // Supprimer le fichier source si il existe
            if (jobData.filePath) {
                await FileService.deleteFile(jobData.filePath);
            }

            // Supprimer le fichier de sortie partiel si il existe
            const outputDir = `${process.env.TEMP_DIR || '/tmp/uploads'}/output`;
            const possibleOutputs = [
                `${outputDir}/${jobData.id}.jpg`,
                `${outputDir}/${jobData.id}.png`,
                `${outputDir}/${jobData.id}.webp`,
                `${outputDir}/${jobData.id}_processed.mp4`,
                `${outputDir}/${jobData.id}_processed.mp3`,
                `${outputDir}/${jobData.id}_processed.pdf`
            ];

            for (const file of possibleOutputs) {
                await FileService.deleteFile(file).catch(() => {}); // Ignore les erreurs
            }

            logger.debug(`Fichiers nettoyés pour job ${jobData.id}`);
        } catch (error) {
            logger.warn(`Erreur nettoyage fichiers job ${jobData.id}:`, error);
        }
    }

    /**
     * Enregistrer les métriques de traitement
     */
    recordMetrics(jobData, processingTime, result) {
        try {
            const metrics = {
                type: jobData.type,
                originalSize: jobData.size,
                compressedSize: result.compressedSize,
                compressionRatio: result.compressionRatio,
                processingTime,
                timestamp: new Date().toISOString()
            };

            // Log métrique
            logger.metric('file_processed', 1, 'count', metrics);
            logger.metric('processing_time', processingTime, 'ms', {
                type: jobData.type,
                size: jobData.size
            });

            if (result.compressionRatio > 0) {
                logger.metric('compression_ratio', result.compressionRatio, '%', {
                    type: jobData.type
                });
                logger.metric('bytes_saved', jobData.size - result.compressedSize, 'bytes', {
                    type: jobData.type
                });
            }

        } catch (error) {
            logger.warn('Erreur enregistrement métriques:', error);
        }
    }

    /**
     * Configuration de l'arrêt gracieux
     */
    setupGracefulShutdown() {
        logger.info('🛡️ Configuration arrêt gracieux worker...');

        const shutdown = async (signal) => {
            if (this.isShuttingDown) return;
            this.isShuttingDown = true;

            logger.info(`🛑 Arrêt gracieux worker démarré (${signal})`);

            try {
                // 1. Arrêter d'accepter de nouveaux jobs
                await processingQueue.pause();
                logger.info('Queue mise en pause');

                // 2. Attendre la fin des jobs en cours (max 5 minutes)
                const timeout = 5 * 60 * 1000; // 5 minutes
                const startTime = Date.now();

                while (this.activeJobs.size > 0 && (Date.now() - startTime) < timeout) {
                    logger.info(`Attente fin des jobs en cours (${this.activeJobs.size} restants)`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                if (this.activeJobs.size > 0) {
                    logger.warn(`Timeout atteint, arrêt forcé (${this.activeJobs.size} jobs interrompus)`);
                }

                // 3. Fermer la queue
                await processingQueue.close();
                logger.info('Queue fermée');

                // 4. Afficher les statistiques finales
                this.logFinalStats();

                logger.info('✅ Arrêt gracieux worker terminé');
                process.exit(0);

            } catch (error) {
                logger.error('❌ Erreur arrêt gracieux worker:', error);
                process.exit(1);
            }
        };

        // Signaux d'arrêt
        process.on('SIGTERM', () => shutdown('SIGTERM'));
        process.on('SIGINT', () => shutdown('SIGINT'));
        process.on('SIGUSR2', () => shutdown('SIGUSR2')); // Nodemon

        // Erreurs non gérées
        process.on('uncaughtException', (error) => {
            logger.error('Exception non gérée worker:', error);
            shutdown('uncaughtException');
        });

        process.on('unhandledRejection', (reason, promise) => {
            logger.error('Rejection non gérée worker:', reason, { promise });
            shutdown('unhandledRejection');
        });

        logger.info('✅ Arrêt gracieux worker configuré');
    }

    /**
     * Configuration du monitoring périodique
     */
    setupMonitoring() {
        logger.info('📊 Configuration monitoring worker...');

        // Stats périodiques toutes les 5 minutes
        setInterval(() => {
            this.logWorkerStats();
        }, 5 * 60 * 1000);

        // Health check toutes les minutes
        setInterval(async () => {
            await this.healthCheck();
        }, 60 * 1000);

        logger.info('✅ Monitoring worker configuré');
    }

    /**
     * Afficher les statistiques du worker
     */
    logWorkerStats() {
        const uptime = Date.now() - this.stats.startTime;
        const avgProcessingTime = this.stats.processed > 0 
            ? Math.round(this.stats.totalProcessingTime / this.stats.processed)
            : 0;

        const memUsage = process.memoryUsage();

        logger.info('📊 Statistiques worker', {
            uptime: Math.round(uptime / 1000),
            uptimeFormatted: this.formatDuration(uptime),
            activeJobs: this.activeJobs.size,
            processed: this.stats.processed,
            failed: this.stats.failed,
            avgProcessingTime: `${avgProcessingTime}ms`,
            memory: {
                rss: FileService.formatFileSize(memUsage.rss),
                heapUsed: FileService.formatFileSize(memUsage.heapUsed),
                heapTotal: FileService.formatFileSize(memUsage.heapTotal)
            }
        });

        // Métriques détaillées des jobs actifs
        if (this.activeJobs.size > 0) {
            const activeJobsInfo = Array.from(this.activeJobs.values()).map(job => ({
                jobId: job.jobId,
                fileName: job.fileName,
                type: job.type,
                duration: Date.now() - job.startTime
            }));

            logger.info('🔄 Jobs actifs', { jobs: activeJobsInfo });
        }
    }

    /**
     * Health check du worker
     */
    async healthCheck() {
        try {
            // Vérifier Redis
            const redis = await getRedisClient();
            await redis.ping();

            // Vérifier l'espace disque
            const tempDir = process.env.TEMP_DIR || '/tmp/uploads';
            const dirStats = await FileService.getDirectorySize(tempDir);

            // Vérifier la mémoire
            const memUsage = process.memoryUsage();
            const memLimit = 1 * 1024 * 1024 * 1024; // 1GB limite
            
            if (memUsage.heapUsed > memLimit) {
                logger.warn('⚠️ Utilisation mémoire élevée', {
                    heapUsed: FileService.formatFileSize(memUsage.heapUsed),
                    limit: FileService.formatFileSize(memLimit)
                });
            }

            // Vérifier les jobs bloqués
            const now = Date.now();
            const maxJobDuration = 30 * 60 * 1000; // 30 minutes
            
            for (const [bullJobId, activeJob] of this.activeJobs) {
                if (now - activeJob.startTime > maxJobDuration) {
                    logger.warn('⚠️ Job potentiellement bloqué', {
                        jobId: activeJob.jobId,
                        duration: now - activeJob.startTime,
                        fileName: activeJob.fileName
                    });
                }
            }

        } catch (error) {
            logger.error('❌ Health check worker échoué:', error);
        }
    }

    /**
     * Afficher les statistiques finales
     */
    logFinalStats() {
        const uptime = Date.now() - this.stats.startTime;
        const successRate = this.stats.processed + this.stats.failed > 0
            ? Math.round((this.stats.processed / (this.stats.processed + this.stats.failed)) * 100)
            : 0;

        logger.info('📈 Statistiques finales worker', {
            uptime: this.formatDuration(uptime),
            processed: this.stats.processed,
            failed: this.stats.failed,
            successRate: `${successRate}%`,
            totalProcessingTime: this.formatDuration(this.stats.totalProcessingTime),
            avgProcessingTime: this.stats.processed > 0 
                ? Math.round(this.stats.totalProcessingTime / this.stats.processed)
                : 0
        });
    }

    /**
     * Formater une durée en millisecondes
     */
    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
            return `${days}j ${hours % 24}h ${minutes % 60}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        } else {
            return `${seconds}s`;
        }
    }

    /**
     * Obtenir les statistiques actuelles
     */
    getStats() {
        const uptime = Date.now() - this.stats.startTime;
        
        return {
            uptime,
            uptimeFormatted: this.formatDuration(uptime),
            activeJobs: this.activeJobs.size,
            processed: this.stats.processed,
            failed: this.stats.failed,
            successRate: this.stats.processed + this.stats.failed > 0
                ? Math.round((this.stats.processed / (this.stats.processed + this.stats.failed)) * 100)
                : 100,
            avgProcessingTime: this.stats.processed > 0 
                ? Math.round(this.stats.totalProcessingTime / this.stats.processed)
                : 0,
            memory: process.memoryUsage()
        };
    }
}

/**
 * Fonction principale de démarrage du worker
 */
async function main() {
    try {
        logger.info('🎯 File Optimizer Worker v2.0.0');
        logger.info(`📍 Environnement: ${process.env.NODE_ENV || 'development'}`);
        logger.info(`🔧 Node.js: ${process.version}`);
        logger.info(`👷 PID: ${process.pid}`);

        const processor = new FileProcessor();
        await processor.init();

        // Exposer les stats du worker
        global.getWorkerStats = () => processor.getStats();

        logger.info('🎉 Worker de traitement démarré avec succès !');
        logger.info('⏳ En attente de jobs à traiter...');

    } catch (error) {
        logger.error('💥 Échec démarrage worker:', error);
        process.exit(1);
    }
}

// Démarrer le worker si ce fichier est exécuté directement
if (require.main === module) {
    main();
}

module.exports = { FileProcessor, main };



================================================
File: frontend/index.html
================================================
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>File Optimizer - Compresseur de Fichiers</title>
    
    <!-- Styles CSS -->
    <link rel="stylesheet" href="css/styles.css">
    
    <!-- Socket.IO CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.js"></script>
    
    <!-- Favicon et métadonnées -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🗜️</text></svg>" type="image/svg+xml">
    <meta name="description" content="Compressez et optimisez vos fichiers multimédia sans changer leur format">
    <meta name="keywords" content="compression fichiers, optimisation images, compresseur vidéo">
    <meta name="author" content="File Optimizer Team">
    
    <!-- Open Graph pour partage social -->
    <meta property="og:title" content="File Optimizer - Compresseur de Fichiers">
    <meta property="og:description" content="Compressez et optimisez vos fichiers multimédia sans changer leur format">
    <meta property="og:type" content="website">
    <meta property="og:image" content="assets/og-image.png">
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com;
        style-src 'self' 'unsafe-inline';
        connect-src 'self' ws: wss:;
        img-src 'self' data: blob:;
        font-src 'self' data:;
    ">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>
                <span class="logo">🗜️</span>
                <span class="title-text">File Optimizer</span>
            </h1>
            <p>Compressez et optimisez vos fichiers multimédia sans changer leur format</p>
        </header>

        <!-- Upload Section -->
        <section class="upload-section">
            <div class="upload-zone" id="uploadZone">
                <div class="upload-icon">
                    📤
                </div>
                <div class="upload-text">Glissez vos fichiers ici ou cliquez pour sélectionner</div>
                <div class="upload-subtext">
                    Images, vidéos, audio et documents • Maximum 5GB
                </div>
                <input type="file" id="fileInput" class="file-input" multiple 
                       accept="image/*,video/*,audio/*,.pdf">
            </div>
        </section>

        <!-- Settings Panel -->
        <section class="settings-panel" id="settingsPanel">
            <h2 class="settings-title">
                <span class="section-icon">⚙️</span>
                <span>Paramètres de compression</span>
            </h2>
            <div class="settings-grid" id="settingsGrid">
                <!-- Les paramètres seront générés dynamiquement selon le type de fichier -->
            </div>
        </section>

        <!-- Jobs Section -->
        <section class="jobs-section">
            <h2 class="jobs-title">
                <span class="section-icon">📋</span>
                <span>Fichiers en traitement</span>
            </h2>
            <div class="jobs-controls">
                <button class="btn btn-secondary" id="refreshJobs">
                    <span>🔄</span>
                    <span>Actualiser</span>
                </button>
                <button class="btn btn-secondary" id="clearCompleted">
                    <span>🧹</span>
                    <span>Nettoyer terminés</span>
                </button>
            </div>
            <div id="jobsList">
                <div class="empty-state">
                    <div class="empty-state-icon">
                        📁
                    </div>
                    <div>Aucun fichier en cours de traitement</div>
                    <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                        Uploadez un fichier pour commencer
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Status Indicator -->
    <div class="status-indicator" id="statusIndicator">
        <div class="status-icon" id="statusIcon"></div>
        <div id="statusMessage"></div>
        <button class="status-close" id="statusClose">&times;</button>
    </div>

    <!-- Connection Status -->
    <div class="connection-status disconnected" id="connectionStatus">
        <div class="connection-dot"></div>
        <span>Déconnecté</span>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <div class="loading-text">Chargement...</div>
        </div>
    </div>

    <!-- JavaScript Files - ORDRE CRITIQUE -->
    <script src="js/utils.js"></script>
    <script src="js/api.js"></script>
    <script src="js/websocket.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/app.js"></script>
    
    <!-- Error Handler Global -->
    <script>
        // Gestionnaire d'erreurs global
        window.addEventListener('error', (event) => {
            console.error('Erreur JavaScript:', event.error);
            if (window.fileOptimizer && window.fileOptimizer.ui) {
                window.fileOptimizer.ui.showStatus('Erreur inattendue détectée', 'error');
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Promise rejetée:', event.reason);
            if (window.fileOptimizer && window.fileOptimizer.ui) {
                window.fileOptimizer.ui.showStatus('Erreur async non gérée', 'error');
            }
        });

        // Vérification des modules requis
        document.addEventListener('DOMContentLoaded', () => {
            const requiredModules = ['Utils', 'ApiClient', 'WebSocketManager', 'UIManager'];
            const missingModules = requiredModules.filter(module => !window[module]);
            
            if (missingModules.length > 0) {
                console.error('Modules manquants:', missingModules);
                document.body.innerHTML = `
                    <div style="
                        position: fixed; 
                        top: 50%; 
                        left: 50%; 
                        transform: translate(-50%, -50%);
                        background: #1e293b; 
                        color: #f8fafc; 
                        padding: 2rem; 
                        border-radius: 12px; 
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
                        text-align: center;
                        max-width: 400px;
                        border: 1px solid #334155;
                    ">
                        <h2 style="color: #ef4444; margin-bottom: 1rem;">❌ Erreur de Chargement</h2>
                        <p style="margin-bottom: 1rem;">Modules JavaScript manquants:</p>
                        <ul style="list-style: none; padding: 0; margin-bottom: 1.5rem;">
                            ${missingModules.map(m => `<li style="color: #fbbf24;">• ${m}</li>`).join('')}
                        </ul>
                        <p style="font-size: 0.9rem; color: #cbd5e1;">
                            Vérifiez que tous les fichiers .js sont présents et se chargent correctement.
                        </p>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>


================================================
File: frontend/css/styles.css
================================================
/* ===========================================
   🗜️ File Optimizer - Styles CSS CORRIGÉS
   Frontend moderne et responsive
   =========================================== */

/* Variables CSS */
:root {
    /* Couleurs principales */
    --primary: #2563eb;
    --primary-dark: #1d4ed8;
    --primary-light: #3b82f6;
    --secondary: #64748b;
    --success: #10b981;
    --warning: #f59e0b;
    --error: #ef4444;
    --info: #06b6d4;

    /* Couleurs interface */
    --background: #0f172a;
    --background-alt: #1e293b;
    --surface: #1e293b;
    --surface-alt: #334155;
    --border: #334155;
    --border-light: #475569;
    
    /* Couleurs texte */
    --text: #f8fafc;
    --text-light: #cbd5e1;
    --text-muted: #64748b;
    
    /* Ombres */
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
    --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    
    /* Rayons de courbure */
    --radius-sm: 6px;
    --radius: 8px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    --radius-full: 9999px;
    
    /* Espacements */
    --space-xs: 0.25rem;
    --space-sm: 0.5rem;
    --space: 1rem;
    --space-lg: 1.5rem;
    --space-xl: 2rem;
    --space-2xl: 3rem;
    
    /* Transitions */
    --transition: all 0.2s ease;
    --transition-slow: all 0.3s ease;
}

/* Réinitialisation et base */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    scroll-behavior: smooth;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--background);
    color: var(--text);
    line-height: 1.6;
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    min-height: 100vh;
}

/* Container principal */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--space-xl);
    width: 100%;
}

/* ===========================================
   HEADER - CORRIGÉ
   =========================================== */
.header {
    text-align: center;
    margin-bottom: var(--space-2xl);
    width: 100%;
}

.header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--text);
    margin-bottom: var(--space-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space);
    /* FIX: Éviter chevauchement */
    white-space: nowrap;
    flex-wrap: nowrap;
    width: 100%;
    overflow: visible;
}

.logo {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    object-fit: contain;
}

.header p {
    font-size: 1.1rem;
    color: var(--text-light);
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.5;
    padding: 0 var(--space);
}

/* ===========================================
   SECTIONS - CORRIGÉES
   =========================================== */
.upload-section,
.settings-panel,
.jobs-section {
    background: var(--surface);
    border-radius: var(--radius-xl);
    padding: var(--space-xl);
    box-shadow: var(--shadow);
    margin-bottom: var(--space-xl);
    border: 1px solid var(--border);
    width: 100%;
    overflow: hidden;
}

.section-icon {
    width: 20px;
    height: 20px;
    margin-right: var(--space-sm);
    flex-shrink: 0;
}

/* ===========================================
   UPLOAD ZONE - CORRIGÉE
   =========================================== */
.upload-zone {
    border: 3px dashed var(--border);
    border-radius: var(--radius-lg);
    padding: var(--space-2xl);
    text-align: center;
    transition: var(--transition-slow);
    cursor: pointer;
    position: relative;
    overflow: hidden;
    background: var(--surface-alt);
    width: 100%;
    min-height: 200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.upload-zone:hover {
    border-color: var(--primary);
    background: rgba(37, 99, 235, 0.1);
    transform: translateY(-2px);
}

.upload-zone.dragover {
    border-color: var(--primary);
    background: rgba(37, 99, 235, 0.2);
    transform: scale(1.02);
    box-shadow: var(--shadow-lg);
}

.upload-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto var(--space);
    background: var(--primary);
    border-radius: var(--radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 24px;
    flex-shrink: 0;
}

.upload-icon img {
    width: 32px;
    height: 32px;
    filter: invert(1);
}

.upload-text {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: var(--space-sm);
    text-align: center;
    line-height: 1.4;
}

.upload-subtext {
    color: var(--text-light);
    font-size: 0.9rem;
    text-align: center;
    line-height: 1.4;
}

.file-input {
    display: none;
}

/* ===========================================
   SETTINGS PANEL - CORRIGÉE
   =========================================== */
.settings-panel {
    display: none;
    animation: slideDown 0.3s ease;
}

.settings-panel.active {
    display: block;
}

.settings-title {
    font-size: 1.3rem;
    font-weight: 600;
    margin-bottom: var(--space-lg);
    color: var(--text);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    white-space: nowrap;
    overflow: visible;
}

.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-lg);
    width: 100%;
}

.setting-group {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
}

.setting-label {
    font-weight: 500;
    color: var(--text);
    font-size: 0.9rem;
    line-height: 1.4;
}

.setting-input,
.setting-select {
    padding: 0.75rem;
    border: 2px solid var(--border);
    border-radius: var(--radius);
    font-size: 0.9rem;
    transition: var(--transition);
    background: var(--surface-alt);
    color: var(--text);
    width: 100%;
}

.setting-input:focus,
.setting-select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
}

.setting-description {
    font-size: 0.8rem;
    color: var(--text-muted);
    line-height: 1.3;
}

/* ===========================================
   JOBS SECTION - CORRIGÉE
   =========================================== */
.jobs-title {
    font-size: 1.3rem;
    font-weight: 600;
    color: var(--text);
    display: flex;
    align-items: center;
    margin-bottom: var(--space);
    gap: var(--space-sm);
    white-space: nowrap;
    overflow: visible;
}

.jobs-controls {
    display: flex;
    gap: var(--space);
    margin-bottom: var(--space-lg);
    flex-wrap: wrap;
    align-items: center;
}

.job-item {
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    margin-bottom: var(--space);
    transition: var(--transition);
    background: var(--surface-alt);
    width: 100%;
    overflow: hidden;
}

.job-item:hover {
    box-shadow: var(--shadow);
    transform: translateY(-1px);
}

.job-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space);
    gap: var(--space);
    flex-wrap: wrap;
}

.job-name {
    font-weight: 600;
    color: var(--text);
    font-size: 1rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 300px;
    flex: 1;
    min-width: 0;
}

.job-status {
    padding: var(--space-xs) var(--space);
    border-radius: var(--radius-full);
    font-size: 0.8rem;
    font-weight: 500;
    white-space: nowrap;
    flex-shrink: 0;
}

/* Status colors */
.status-uploaded {
    background: rgba(124, 58, 237, 0.2);
    color: #a78bfa;
    border: 1px solid rgba(124, 58, 237, 0.3);
}

.status-queued {
    background: rgba(217, 119, 6, 0.2);
    color: #fbbf24;
    border: 1px solid rgba(217, 119, 6, 0.3);
}

.status-processing {
    background: rgba(37, 99, 235, 0.2);
    color: var(--primary-light);
    border: 1px solid rgba(37, 99, 235, 0.3);
}

.status-completed {
    background: rgba(16, 185, 129, 0.2);
    color: #34d399;
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.status-error {
    background: rgba(239, 68, 68, 0.2);
    color: #f87171;
    border: 1px solid rgba(239, 68, 68, 0.3);
}

/* Progress bar */
.job-progress {
    margin-bottom: var(--space);
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: var(--border);
    border-radius: var(--radius-sm);
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--primary-light));
    transition: width 0.3s ease;
    border-radius: var(--radius-sm);
}

.progress-text {
    font-size: 0.8rem;
    color: var(--text-light);
    margin-top: var(--space-xs);
}

.job-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: var(--space);
    font-size: 0.9rem;
    color: var(--text-light);
    margin-bottom: var(--space);
}

.job-actions {
    display: flex;
    gap: var(--space-sm);
    margin-top: var(--space);
    flex-wrap: wrap;
    align-items: center;
}

/* ===========================================
   BOUTONS - CORRIGÉS
   =========================================== */
.btn {
    padding: var(--space-sm) var(--space);
    border: none;
    border-radius: var(--radius);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: var(--space-sm);
    white-space: nowrap;
    border: 1px solid transparent;
    line-height: 1.2;
    min-height: 40px;
    justify-content: center;
}

.btn img {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
}

.btn-primary {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
}

.btn-primary:hover {
    background: var(--primary-dark);
    transform: translateY(-1px);
    box-shadow: var(--shadow);
}

.btn-secondary {
    background: var(--surface-alt);
    color: var(--text);
    border-color: var(--border);
}

.btn-secondary:hover {
    background: var(--secondary);
    color: white;
    border-color: var(--secondary);
}

.btn-success {
    background: var(--success);
    color: white;
    border-color: var(--success);
}

.btn-success:hover {
    background: #059669;
    transform: translateY(-1px);
    box-shadow: var(--shadow);
}

.btn-danger {
    background: var(--error);
    color: white;
    border-color: var(--error);
}

.btn-danger:hover {
    background: #dc2626;
}

/* ===========================================
   STATUS INDICATOR - CORRIGÉ
   =========================================== */
.status-indicator {
    position: fixed;
    top: var(--space-xl);
    right: var(--space-xl);
    background: var(--surface);
    padding: var(--space);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg);
    border-left: 4px solid var(--success);
    display: none;
    z-index: 1000;
    max-width: 400px;
    min-width: 300px;
    border: 1px solid var(--border);
}

.status-indicator.show {
    display: flex;
    align-items: flex-start;
    gap: var(--space);
    animation: slideInRight 0.3s ease;
}

.status-indicator.error {
    border-left-color: var(--error);
}

.status-indicator.warning {
    border-left-color: var(--warning);
}

.status-indicator.info {
    border-left-color: var(--info);
}

.status-icon {
    font-size: 1.2rem;
    margin-top: 2px;
    flex-shrink: 0;
}

.status-close {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    color: var(--text-muted);
    margin-left: auto;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.status-close:hover {
    color: var(--text);
}

/* ===========================================
   CONNECTION STATUS - CORRIGÉ
   =========================================== */
.connection-status {
    position: fixed;
    bottom: var(--space-xl);
    right: var(--space-xl);
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius-full);
    font-size: 0.8rem;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    z-index: 1000;
    transition: var(--transition);
    white-space: nowrap;
    border: 1px solid transparent;
}

.connection-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: pulse 2s infinite;
    flex-shrink: 0;
}

.connection-status.connected {
    background: rgba(16, 185, 129, 0.2);
    color: #34d399;
    border-color: rgba(16, 185, 129, 0.3);
}

.connection-status.connected .connection-dot {
    background: #34d399;
}

.connection-status.disconnected {
    background: rgba(239, 68, 68, 0.2);
    color: #f87171;
    border-color: rgba(239, 68, 68, 0.3);
}

.connection-status.disconnected .connection-dot {
    background: #f87171;
}

/* ===========================================
   LOADING & ANIMATIONS - CORRIGÉES
   =========================================== */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 23, 42, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.loading-overlay.show {
    display: flex;
}

.loading-spinner {
    text-align: center;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top: 3px solid var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto var(--space);
}

.loading-text {
    color: var(--text-light);
    font-weight: 500;
}

/* Empty state */
.empty-state {
    text-align: center;
    padding: var(--space-2xl);
    color: var(--text-light);
}

.empty-state-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto var(--space);
    background: var(--border);
    border-radius: var(--radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
}

.empty-state-icon img {
    width: 32px;
    height: 32px;
    opacity: 0.5;
}

/* ===========================================
   ANIMATIONS
   =========================================== */
@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideDown {
    from {
        transform: translateY(-20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

/* ===========================================
   RESPONSIVE DESIGN - CORRIGÉ
   =========================================== */
@media (max-width: 768px) {
    .container {
        padding: var(--space);
    }

    .header h1 {
        font-size: 2rem;
        flex-direction: row;
        gap: var(--space-sm);
        /* Permettre wrap seulement si absolument nécessaire */
        flex-wrap: wrap;
        justify-content: center;
    }

    .upload-section,
    .settings-panel,
    .jobs-section {
        padding: var(--space-lg);
        margin-bottom: var(--space-lg);
    }

    .upload-zone {
        padding: var(--space-lg);
        min-height: 160px;
    }

    .settings-grid {
        grid-template-columns: 1fr;
    }

    .job-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-sm);
    }

    .job-name {
        max-width: 100%;
    }

    .job-actions {
        width: 100%;
        justify-content: flex-start;
    }

    .jobs-controls {
        flex-direction: column;
        align-items: stretch;
    }

    .jobs-controls .btn {
        width: 100%;
        justify-content: center;
    }

    .status-indicator {
        top: var(--space);
        right: var(--space);
        left: var(--space);
        max-width: none;
        min-width: 0;
    }

    .connection-status {
        bottom: var(--space);
        right: var(--space);
    }
}

@media (max-width: 480px) {
    .container {
        padding: var(--space-sm);
    }

    .header h1 {
        font-size: 1.75rem;
        flex-direction: column;
        gap: var(--space-sm);
    }

    .upload-section,
    .settings-panel,
    .jobs-section {
        padding: var(--space);
    }

    .job-info {
        grid-template-columns: 1fr;
    }

    .btn {
        font-size: 0.8rem;
        padding: var(--space-xs) var(--space-sm);
    }
}

/* ===========================================
   PRINT STYLES
   =========================================== */
@media print {
    .status-indicator,
    .connection-status,
    .loading-overlay {
        display: none !important;
    }
}

/* Fix pour le titre avec emojis */
.header h1 .title-text {
    display: inline-block;
    white-space: nowrap;
    margin-left: var(--space-sm);
    vertical-align: middle;
}

.header h1 .logo {
    display: inline-block;
    vertical-align: middle;
    line-height: 1;
}

/* Fix pour les boutons avec icônes et texte */
.btn {
    /* Forcer layout inline-flex stable */
    display: inline-flex !important;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    vertical-align: top;
    box-sizing: border-box;
}

.btn span {
    display: inline-block;
    line-height: 1.2;
    vertical-align: middle;
}

/* Fix spécifique pour jobs-controls */
.jobs-controls {
    display: flex;
    gap: var(--space);
    margin-bottom: var(--space-lg);
    flex-wrap: wrap;
    align-items: flex-start; /* Évite alignement center qui cause chevauchements */
}

.jobs-controls .btn {
    min-width: 140px; /* Largeur minimum pour éviter compression */
    flex-shrink: 0;
}

/* Fix pour les titres de section */
.jobs-title,
.settings-title {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    margin-bottom: var(--space);
    line-height: 1.3;
    overflow: visible;
}

.jobs-title span,
.settings-title span {
    display: inline-block;
    vertical-align: middle;
}

/* Fix pour job-item layout */
.job-item {
    position: relative;
    isolation: isolate; /* Créer un nouveau contexte de stacking */
}

.job-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; /* Alignement en haut pour éviter chevauchements */
    margin-bottom: var(--space);
    gap: var(--space);
    flex-wrap: wrap;
}

.job-name {
    flex: 1 1 auto;
    min-width: 0; /* Permet shrinking */
    word-break: break-word;
    overflow-wrap: break-word;
    max-width: none; /* Retire limitation précédente */
}

.job-status {
    flex: 0 0 auto;
    margin-left: auto;
}

/* Fix pour upload zone */
.upload-zone {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    position: relative;
    isolation: isolate;
}

.upload-icon,
.upload-text,
.upload-subtext {
    z-index: 1;
    position: relative;
}

/* Fix pour empty state */
.empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    gap: var(--space);
}

/* Fix général pour éviter text overflow */
* {
    word-wrap: break-word;
    overflow-wrap: break-word;
}

/* Fix pour éléments flex qui débordent */
.flex-container {
    min-width: 0; /* Permet aux flex items de shrink */
}

/* Fix pour status indicator */
.status-indicator {
    max-width: calc(100vw - 2 * var(--space-xl));
    word-break: break-word;
}

/* Fix responsive supplémentaire */
@media (max-width: 600px) {
    .job-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-sm);
    }
    
    .job-status {
        align-self: flex-start;
        margin-left: 0;
    }
    
    .jobs-controls {
        flex-direction: column;
        align-items: stretch;
    }
    
    .jobs-controls .btn {
        width: 100%;
        min-width: auto;
    }
    
    .header h1 {
        flex-direction: column;
        gap: var(--space-sm);
        align-items: center;
    }
    
    .header h1 .title-text {
        margin-left: 0;
    }
}


================================================
File: frontend/js/api.js
================================================
// js/api.js
// Client API REST pour File Optimizer

/**
 * Client API REST avec retry automatique et cache intelligent
 */
class ApiClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
        this.logger = Utils.createLogger('ApiClient');
        this.defaultTimeout = 30000; // 30 secondes
    }

    /**
     * Requête HTTP générique avec retry automatique
     */
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const config = {
            timeout: this.defaultTimeout,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        };

        // Vérifier le cache pour GET
        if (options.method === 'GET' || !options.method) {
            const cached = this.getFromCache(url);
            if (cached) {
                return cached;
            }
        }

        return Utils.retry(async () => {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), config.timeout);

            try {
                const response = await fetch(url, {
                    ...config,
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                
                // Mettre en cache les GET réussis
                if (!options.method || options.method === 'GET') {
                    this.setCache(url, data);
                }

                return data;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Timeout de requête');
                }
                throw error;
            }
        }, 3, 1000);
    }

    /**
     * Upload de fichier avec progression
     */
    async uploadFile(file, settings = {}) {
        try {
            this.logger.info(`Upload fichier: ${file.name} (${Utils.formatFileSize(file.size)})`);
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('settings', JSON.stringify(settings));

            const response = await fetch(`${this.baseUrl}/upload`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}`);
            }

            const result = await response.json();
            this.logger.info(`Upload réussi: ${result.jobId}`);
            
            return result;
        } catch (error) {
            this.logger.error('Erreur upload:', error);
            throw error;
        }
    }

    /**
     * Récupérer les jobs avec pagination
     */
    async getJobs(params = {}) {
        const query = new URLSearchParams({
            page: 1,
            limit: 20,
            sortBy: 'createdAt',
            sortOrder: 'desc',
            ...params
        });

        return this.request(`/status?${query}`);
    }

    /**
     * Récupérer un job spécifique
     */
    async getJob(jobId) {
        return this.request(`/status/${jobId}`);
    }

    /**
     * Supprimer un job
     */
    async deleteJob(jobId) {
        return this.request(`/status/${jobId}`, { method: 'DELETE' });
    }

    /**
     * Relancer un job en erreur
     */
    async retryJob(jobId) {
        return this.request(`/status/${jobId}/retry`, { method: 'POST' });
    }

    /**
     * Annuler un job
     */
    async cancelJob(jobId) {
        return this.request(`/process/${jobId}/cancel`, { method: 'POST' });
    }

    /**
     * Démarrer le traitement d'un job
     */
    async startProcessing(jobId, settings = {}) {
        return this.request(`/process/${jobId}`, {
            method: 'POST',
            body: JSON.stringify({ settings })
        });
    }

    /**
     * Récupérer les informations d'upload
     */
    async getUploadInfo() {
        return this.request('/upload/info');
    }

    /**
     * Récupérer les statistiques
     */
    async getStats() {
        return this.request('/status/stats/global');
    }

    /**
     * Health check
     */
    async healthCheck() {
        return this.request('/health');
    }

    /**
     * Gestion du cache
     */
    getFromCache(key) {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            this.logger.debug(`Cache hit: ${key}`);
            return cached.data;
        }
        if (cached) {
            this.cache.delete(key);
        }
        return null;
    }

    setCache(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }

    clearCache() {
        this.cache.clear();
        this.logger.info('Cache vidé');
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ApiClient;
} else {
    window.ApiClient = ApiClient;
}


================================================
File: frontend/js/app.js
================================================
// js/app.js
// Application principale File Optimizer

/**
 * Classe principale de l'application File Optimizer
 */
class FileOptimizer {
    constructor() {
        this.jobs = new Map();
        this.socket = null;
        this.api = null;
        this.ui = null;
        this.websocket = null;
        
        this.config = {
            maxFileSize: 5 * 1024 * 1024 * 1024, // 5GB
            supportedTypes: ['image', 'video', 'audio', 'document'],
            apiEndpoint: window.location.origin + '/api'
        };
        
        this.init();
    }

    /**
     * Initialiser l'application
     */
    async init() {
        try {
            console.log('🚀 Initialisation File Optimizer');
            
            // Initialiser les modules
            this.api = new ApiClient(this.config.apiEndpoint);
            this.ui = new UIManager();
            this.websocket = new WebSocketManager(this.config.apiEndpoint);
            
            // Configuration des événements
            this.setupEventListeners();
            this.setupWebSocketEvents();
            
            // Charger les données existantes
            await this.loadExistingJobs();
            await this.loadUploadInfo();
            
            // Marquer comme prêt
            this.ui.setLoadingState(false);
            this.ui.showStatus('Application prête', 'success');
            
            console.log('✅ File Optimizer initialisé');
            
        } catch (error) {
            console.error('❌ Erreur initialisation:', error);
            this.ui.showStatus('Erreur initialisation: ' + error.message, 'error');
        }
    }

    /**
     * Configuration des événements DOM
     */
    setupEventListeners() {
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const refreshJobs = document.getElementById('refreshJobs');
        const clearCompleted = document.getElementById('clearCompleted');

        // Upload zone drag & drop
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', this.handleDragOver.bind(this));
        uploadZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
        uploadZone.addEventListener('drop', this.handleDrop.bind(this));

        // File input change
        fileInput.addEventListener('change', (e) => {
            this.handleFiles(Array.from(e.target.files));
        });

        // Boutons de contrôle
        if (refreshJobs) {
            refreshJobs.addEventListener('click', () => this.loadExistingJobs());
        }
        
        if (clearCompleted) {
            clearCompleted.addEventListener('click', () => this.clearCompletedJobs());
        }

        // Fermeture notifications
        document.addEventListener('click', (e) => {
            if (e.target.id === 'statusClose') {
                this.ui.hideStatus();
            }
        });

        // Raccourcis clavier
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'u': // Ctrl+U pour upload
                        e.preventDefault();
                        fileInput.click();
                        break;
                    case 'r': // Ctrl+R pour refresh
                        if (e.shiftKey) {
                            e.preventDefault();
                            this.loadExistingJobs();
                        }
                        break;
                }
            }
        });
    }

    /**
     * Configuration des événements WebSocket
     */
    setupWebSocketEvents() {
        this.websocket.on('connect', () => {
            this.ui.setConnectionStatus(true);
            console.log('🔌 WebSocket connecté');
        });

        this.websocket.on('disconnect', () => {
            this.ui.setConnectionStatus(false);
            console.log('🔌 WebSocket déconnecté');
        });

        this.websocket.on('job-progress', (data) => {
            this.updateJobProgress(data.jobId, data.progress);
        });

        this.websocket.on('job-completed', (data) => {
            this.updateJobStatus(data.jobId, 'completed', data);
        });

        this.websocket.on('job-error', (data) => {
            this.updateJobStatus(data.jobId, 'error', { error: data.error });
        });

        this.websocket.on('job-queued', (data) => {
            this.updateJobStatus(data.jobId, 'queued');
        });
    }

    /**
     * Gestion drag & drop
     */
    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        this.ui.setUploadZoneState('dragover');
    }

    handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        this.ui.setUploadZoneState('normal');
    }

    handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.ui.setUploadZoneState('normal');
        
        const files = Array.from(e.dataTransfer.files);
        this.handleFiles(files);
    }

    /**
     * Traitement des fichiers sélectionnés
     */
    async handleFiles(files) {
        if (files.length === 0) return;

        console.log(`📁 ${files.length} fichier(s) sélectionné(s)`);
        
        // Valider les fichiers
        const validFiles = files.filter(file => this.validateFile(file));
        
        if (validFiles.length !== files.length) {
            this.ui.showStatus(
                `${files.length - validFiles.length} fichier(s) rejeté(s) (type non supporté ou trop volumineux)`,
                'warning'
            );
        }

        // Traiter les fichiers valides
        for (const file of validFiles) {
            try {
                await this.uploadFile(file);
            } catch (error) {
                console.error(`Erreur upload ${file.name}:`, error);
            }
        }
    }

    /**
     * Validation d'un fichier
     */
    validateFile(file) {
        // Vérifier la taille
        if (file.size > this.config.maxFileSize) {
            console.warn(`Fichier trop volumineux: ${file.name} (${Utils.formatFileSize(file.size)})`);
            return false;
        }

        // Vérifier le type
        const fileType = Utils.getFileType(file.name);
        if (!this.config.supportedTypes.includes(fileType)) {
            console.warn(`Type non supporté: ${file.name} (${fileType})`);
            return false;
        }

        return true;
    }

    /**
     * Upload d'un fichier
     */
    async uploadFile(file) {
        try {
            this.ui.showStatus(`Upload de ${file.name}...`, 'info');

            // Déterminer les paramètres par défaut
            const fileType = Utils.getFileType(file.name);
            const settings = this.getDefaultSettings(fileType);

            // Créer le job temporaire
            const tempJob = {
                id: 'temp-' + Date.now(),
                name: file.name,
                size: file.size,
                type: fileType,
                status: 'uploading',
                progress: 0,
                createdAt: new Date().toISOString()
            };

            this.addJob(tempJob);

            // Upload via API
            const result = await this.api.uploadFile(file, settings);

            if (result.success) {
                // Remplacer le job temporaire par le vrai
                this.jobs.delete(tempJob.id);
                
                const job = {
                    id: result.jobId,
                    name: file.name,
                    size: file.size,
                    type: fileType,
                    status: 'uploaded',
                    progress: 0,
                    settings: settings,
                    createdAt: new Date().toISOString(),
                    estimatedTime: result.estimatedTime
                };

                this.addJob(job);
                this.websocket.joinJobRoom(result.jobId);
                
                this.ui.showStatus(`${file.name} uploadé avec succès!`, 'success');
                
            } else {
                this.jobs.delete(tempJob.id);
                throw new Error(result.error || 'Erreur upload');
            }

        } catch (error) {
            console.error('Erreur upload:', error);
            this.ui.showStatus(`Erreur upload ${file.name}: ${error.message}`, 'error');
        }
    }

    /**
     * Obtenir les paramètres par défaut selon le type
     */
    getDefaultSettings(type) {
        const defaultSettings = {
            image: {
                quality: 80,
                maxWidth: 1920,
                maxHeight: 1080,
                format: 'auto',
                removeMetadata: true
            },
            video: {
                codec: 'h264',
                crf: 23,
                preset: 'medium',
                maxBitrate: '2M'
            },
            audio: {
                codec: 'aac',
                bitrate: '128k',
                sampleRate: 44100
            },
            document: {
                compress: true,
                removeMetadata: true
            }
        };

        return defaultSettings[type] || {};
    }

    /**
     * Ajouter un job à la liste
     */
    addJob(job) {
        this.jobs.set(job.id, job);
        this.ui.renderJobs(Array.from(this.jobs.values()));
    }

    /**
     * Mettre à jour la progression d'un job
     */
    updateJobProgress(jobId, progress) {
        const job = this.jobs.get(jobId);
        if (job) {
            job.progress = progress;
            job.status = 'processing';
            this.ui.renderJobs(Array.from(this.jobs.values()));
            
            console.log(`📊 Job ${jobId}: ${progress}%`);
        }
    }

    /**
     * Mettre à jour le statut d'un job
     */
    updateJobStatus(jobId, status, data = {}) {
        const job = this.jobs.get(jobId);
        if (job) {
            job.status = status;
            Object.assign(job, data);
            this.ui.renderJobs(Array.from(this.jobs.values()));

            if (status === 'completed') {
                this.ui.showStatus(`${job.name} traité avec succès!`, 'success');
                console.log(`✅ Job ${jobId} terminé`);
            } else if (status === 'error') {
                this.ui.showStatus(`Erreur traitement ${job.name}: ${data.error}`, 'error');
                console.error(`❌ Job ${jobId} échoué:`, data.error);
            }
        }
    }

    /**
     * Supprimer un job
     */
    async deleteJob(jobId) {
        try {
            const job = this.jobs.get(jobId);
            if (!job) return;

            const confirmed = confirm(`Supprimer ${job.name} ?`);
            if (!confirmed) return;

            this.ui.setLoadingState(true);
            
            const result = await this.api.deleteJob(jobId);
            
            if (result.success) {
                this.jobs.delete(jobId);
                this.ui.renderJobs(Array.from(this.jobs.values()));
                this.ui.showStatus('Fichier supprimé', 'success');
            } else {
                throw new Error(result.error || 'Erreur suppression');
            }
        } catch (error) {
            console.error('Erreur suppression:', error);
            this.ui.showStatus('Erreur suppression: ' + error.message, 'error');
        } finally {
            this.ui.setLoadingState(false);
        }
    }

    /**
     * Retenter un job en erreur
     */
    async retryJob(jobId) {
        try {
            this.ui.setLoadingState(true);
            
            const result = await this.api.retryJob(jobId);
            
            if (result.success) {
                this.updateJobStatus(jobId, 'queued');
                this.websocket.joinJobRoom(jobId);
                this.ui.showStatus('Job relancé', 'success');
            } else {
                throw new Error(result.error || 'Erreur retry');
            }
        } catch (error) {
            console.error('Erreur retry:', error);
            this.ui.showStatus('Erreur retry: ' + error.message, 'error');
        } finally {
            this.ui.setLoadingState(false);
        }
    }

    /**
     * Charger les jobs existants
     */
    async loadExistingJobs() {
        try {
            console.log('🔄 Chargement des jobs existants...');
            
            const result = await this.api.getJobs({ limit: 50 });
            
            if (result.success && result.jobs) {
                this.jobs.clear();
                
                result.jobs.forEach(apiJob => {
                    const job = {
                        id: apiJob.id,
                        name: apiJob.originalName,
                        size: apiJob.size,
                        type: apiJob.type,
                        status: apiJob.status,
                        progress: apiJob.progress || 0,
                        createdAt: apiJob.createdAt,
                        compressedSize: apiJob.compressedSize,
                        compressionRatio: apiJob.compressionRatio,
                        error: apiJob.error
                    };
                    
                    this.jobs.set(job.id, job);
                    
                    // Rejoindre les rooms pour les jobs actifs
                    if (['queued', 'processing'].includes(job.status)) {
                        this.websocket.joinJobRoom(job.id);
                    }
                });
                
                this.ui.renderJobs(Array.from(this.jobs.values()));
                console.log(`📋 ${this.jobs.size} job(s) chargé(s)`);
            }
        } catch (error) {
            console.error('Erreur chargement jobs:', error);
            this.ui.showStatus('Erreur chargement jobs', 'error');
        }
    }

    /**
     * Charger les informations d'upload
     */
    async loadUploadInfo() {
        try {
            const info = await this.api.getUploadInfo();
            if (info.success) {
                this.config.maxFileSize = info.limits.maxFileSize;
                console.log('📊 Limites upload:', info.limits);
            }
        } catch (error) {
            console.warn('Impossible de charger les infos upload:', error);
        }
    }

    /**
     * Nettoyer les jobs terminés
     */
    async clearCompletedJobs() {
        try {
            const completedJobs = Array.from(this.jobs.values())
                .filter(job => job.status === 'completed');
            
            if (completedJobs.length === 0) {
                this.ui.showStatus('Aucun job terminé à nettoyer', 'info');
                return;
            }
            
            const confirmed = confirm(`Supprimer ${completedJobs.length} job(s) terminé(s) ?`);
            if (!confirmed) return;
            
            this.ui.setLoadingState(true);
            
            let successCount = 0;
            for (const job of completedJobs) {
                try {
                    const result = await this.api.deleteJob(job.id);
                    if (result.success) {
                        this.jobs.delete(job.id);
                        successCount++;
                    }
                } catch (error) {
                    console.error(`Erreur suppression ${job.id}:`, error);
                }
            }
            
            this.ui.renderJobs(Array.from(this.jobs.values()));
            this.ui.showStatus(`${successCount} job(s) supprimé(s)`, 'success');
            
        } catch (error) {
            console.error('Erreur nettoyage:', error);
            this.ui.showStatus('Erreur nettoyage: ' + error.message, 'error');
        } finally {
            this.ui.setLoadingState(false);
        }
    }

    /**
     * Télécharger un fichier traité
     */
    downloadFile(jobId) {
        const job = this.jobs.get(jobId);
        if (!job || job.status !== 'completed') {
            this.ui.showStatus('Fichier non disponible pour téléchargement', 'warning');
            return;
        }

        // Créer un lien de téléchargement
        const downloadUrl = `${this.config.apiEndpoint}/download/${jobId}`;
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = job.name;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.ui.showStatus(`Téléchargement de ${job.name} démarré`, 'success');
    }

    /**
     * Obtenir les statistiques
     */
    getStats() {
        const jobs = Array.from(this.jobs.values());
        
        return {
            total: jobs.length,
            completed: jobs.filter(j => j.status === 'completed').length,
            processing: jobs.filter(j => j.status === 'processing').length,
            error: jobs.filter(j => j.status === 'error').length,
            totalSize: jobs.reduce((sum, j) => sum + j.size, 0),
            totalSaved: jobs
                .filter(j => j.compressedSize)
                .reduce((sum, j) => sum + (j.size - j.compressedSize), 0)
        };
    }

    /**
     * Nettoyer les ressources
     */
    destroy() {
        if (this.websocket) {
            this.websocket.disconnect();
        }
        this.jobs.clear();
        console.log('🧹 File Optimizer nettoyé');
    }
}

// Fonctions globales pour l'interface
window.fileOptimizer = null;

window.deleteJob = (jobId) => {
    if (window.fileOptimizer) {
        window.fileOptimizer.deleteJob(jobId);
    }
};

window.retryJob = (jobId) => {
    if (window.fileOptimizer) {
        window.fileOptimizer.retryJob(jobId);
    }
};

window.downloadFile = (jobId) => {
    if (window.fileOptimizer) {
        window.fileOptimizer.downloadFile(jobId);
    }
};

// Initialisation au chargement de la page
document.addEventListener('DOMContentLoaded', () => {
    console.log('🎯 File Optimizer Frontend v2.0.0');
    window.fileOptimizer = new FileOptimizer();
});

// Nettoyage à la fermeture
window.addEventListener('beforeunload', () => {
    if (window.fileOptimizer) {
        window.fileOptimizer.destroy();
    }
});


================================================
File: frontend/js/ui.js
================================================
// js/ui.js
// Gestionnaire de l'interface utilisateur

/**
 * Gestionnaire de l'interface utilisateur
 */
class UIManager {
    constructor() {
        this.elements = this.getElements();
        this.logger = Utils.createLogger('UIManager');
        this.setupUI();
    }

    /**
     * Récupérer les éléments DOM
     */
    getElements() {
        return {
            uploadZone: document.getElementById('uploadZone'),
            fileInput: document.getElementById('fileInput'),
            settingsPanel: document.getElementById('settingsPanel'),
            settingsGrid: document.getElementById('settingsGrid'),
            jobsList: document.getElementById('jobsList'),
            statusIndicator: document.getElementById('statusIndicator'),
            statusMessage: document.getElementById('statusMessage'),
            statusIcon: document.getElementById('statusIcon'),
            statusClose: document.getElementById('statusClose'),
            connectionStatus: document.getElementById('connectionStatus'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            refreshJobs: document.getElementById('refreshJobs'),
            clearCompleted: document.getElementById('clearCompleted')
        };
    }

    /**
     * Configuration initiale de l'UI
     */
    setupUI() {
        this.logger.info('Initialisation UI Manager');
        
        // Configuration des tooltips
        this.setupTooltips();
        
        // Configuration des animations
        this.setupAnimations();
        
        // Configuration des raccourcis
        this.setupKeyboardShortcuts();
        
        // État initial
        this.setLoadingState(false);
        this.setConnectionStatus(false);
    }

    /**
     * Afficher un message de statut
     */
    showStatus(message, type = 'info', duration = 3000) {
        const { statusIndicator, statusMessage, statusIcon } = this.elements;
        
        if (!statusIndicator || !statusMessage || !statusIcon) {
            console.warn('Éléments de statut non trouvés');
            return;
        }

        // Icônes selon le type
        const icons = {
            success: '✅',
            error: '❌',
            warning: '⚠️',
            info: 'ℹ️'
        };

        statusIcon.textContent = icons[type] || icons.info;
        statusMessage.textContent = message;
        
        // Classes CSS
        statusIndicator.className = `status-indicator show ${type}`;
        
        // Animation d'entrée
        statusIndicator.style.transform = 'translateX(100%)';
        statusIndicator.style.opacity = '0';
        
        requestAnimationFrame(() => {
            statusIndicator.style.transform = 'translateX(0)';
            statusIndicator.style.opacity = '1';
        });

        // Auto-masquage
        if (duration > 0) {
            setTimeout(() => {
                this.hideStatus();
            }, duration);
        }

        this.logger.debug(`Status affiché: ${type} - ${message}`);
    }

    /**
     * Masquer le message de statut
     */
    hideStatus() {
        const { statusIndicator } = this.elements;
        
        if (statusIndicator) {
            statusIndicator.style.transform = 'translateX(100%)';
            statusIndicator.style.opacity = '0';
            
            setTimeout(() => {
                statusIndicator.classList.remove('show');
            }, 300);
        }
    }

    /**
     * Définir l'état de connexion
     */
    setConnectionStatus(connected) {
        const { connectionStatus } = this.elements;
        
        if (!connectionStatus) return;

        if (connected) {
            connectionStatus.className = 'connection-status connected';
            connectionStatus.innerHTML = '<div class="connection-dot"></div><span>Connecté</span>';
        } else {
            connectionStatus.className = 'connection-status disconnected';
            connectionStatus.innerHTML = '<div class="connection-dot"></div><span>Déconnecté</span>';
        }
    }

    /**
     * Définir l'état de chargement global
     */
    setLoadingState(loading) {
        const { loadingOverlay } = this.elements;
        
        if (!loadingOverlay) return;

        if (loading) {
            loadingOverlay.classList.add('show');
        } else {
            loadingOverlay.classList.remove('show');
        }
    }

    /**
     * Définir l'état de la zone d'upload
     */
    setUploadZoneState(state) {
        const { uploadZone } = this.elements;
        
        if (!uploadZone) return;

        uploadZone.classList.remove('dragover', 'uploading');
        
        if (state === 'dragover') {
            uploadZone.classList.add('dragover');
        } else if (state === 'uploading') {
            uploadZone.classList.add('uploading');
        }
    }

    /**
     * Rendre la liste des jobs
     */
    renderJobs(jobs) {
        const { jobsList } = this.elements;
        
        if (!jobsList) {
            this.logger.error('Element jobsList non trouvé');
            return;
        }

        if (!jobs || jobs.length === 0) {
            jobsList.innerHTML = this.renderEmptyState();
            return;
        }

        // Trier par date de création (plus récent en premier)
        const sortedJobs = jobs.sort((a, b) => 
            new Date(b.createdAt) - new Date(a.createdAt)
        );

        jobsList.innerHTML = sortedJobs.map(job => this.renderJob(job)).join('');
        
        // Animer les nouveaux éléments
        this.animateJobItems();
    }

    /**
     * Rendre un job individuel
     */
    renderJob(job) {
        const statusClass = `status-${job.status}`;
        const statusText = this.getStatusText(job.status);
        const progressPercent = Math.max(0, Math.min(100, job.progress || 0));
        const showProgress = ['processing', 'queued'].includes(job.status);
        
        // Informations de taille et compression
        const sizeInfo = this.renderSizeInfo(job);
        
        // Actions disponibles
        const actions = this.renderJobActions(job);
        
        // Temps relatif
        const timeAgo = Utils.formatRelativeTime(job.createdAt);
        
        // Icône du type de fichier
        const fileIcon = Utils.getFileIcon(job.type);

        return `
            <div class="job-item" data-job-id="${job.id}" data-status="${job.status}">
                <div class="job-header">
                    <div class="job-name" title="${Utils.escapeHtml(job.name)}">
                        ${fileIcon} ${Utils.escapeHtml(job.name)}
                    </div>
                    <div class="job-status ${statusClass}">${statusText}</div>
                </div>
                
                ${showProgress ? `
                    <div class="job-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progressPercent}%"></div>
                        </div>
                        <div class="progress-text">
                            ${progressPercent}% complété
                            ${job.estimatedTime && job.status === 'processing' ? 
                                `• ETA: ${Utils.formatDuration(job.estimatedTime * 1000)}` : ''}
                        </div>
                    </div>
                ` : ''}

                <div class="job-info">
                    <div><strong>Type:</strong> ${job.type}</div>
                    <div><strong>Créé:</strong> ${timeAgo}</div>
                    ${sizeInfo}
                    ${job.error ? `<div class="job-error"><strong>Erreur:</strong> ${Utils.escapeHtml(job.error)}</div>` : ''}
                </div>

                ${actions ? `<div class="job-actions">${actions}</div>` : ''}
            </div>
        `;
    }

    /**
     * Rendre les informations de taille
     */
    renderSizeInfo(job) {
        let sizeInfo = `<div><strong>Taille:</strong> ${Utils.formatFileSize(job.size)}</div>`;
        
        if (job.compressedSize && job.status === 'completed') {
            const ratio = Utils.calculateCompressionRatio(job.size, job.compressedSize);
            const saved = job.size - job.compressedSize;
            
            sizeInfo += `
                <div><strong>Compressé:</strong> ${Utils.formatFileSize(job.compressedSize)}</div>
                <div><strong>Économisé:</strong> ${Utils.formatFileSize(saved)} (${ratio}%)</div>
            `;
        }
        
        return sizeInfo;
    }

    /**
     * Rendre les actions disponibles pour un job
     */
    renderJobActions(job) {
        const actions = [];

        switch (job.status) {
            case 'completed':
                actions.push(`
                    <button class="btn btn-success" onclick="downloadFile('${job.id}')" title="Télécharger le fichier optimisé">
                        📥 Télécharger
                    </button>
                `);
                actions.push(`
                    <button class="btn btn-secondary" onclick="deleteJob('${job.id}')" title="Supprimer ce job">
                        🗑️ Supprimer
                    </button>
                `);
                break;

            case 'error':
                actions.push(`
                    <button class="btn btn-primary" onclick="retryJob('${job.id}')" title="Relancer le traitement">
                        🔄 Relancer
                    </button>
                `);
                actions.push(`
                    <button class="btn btn-secondary" onclick="deleteJob('${job.id}')" title="Supprimer ce job">
                        🗑️ Supprimer
                    </button>
                `);
                break;

            case 'processing':
            case 'queued':
                actions.push(`
                    <button class="btn btn-secondary" onclick="cancelJob('${job.id}')" title="Annuler le traitement">
                        ⏹️ Annuler
                    </button>
                `);
                break;

            case 'uploaded':
                actions.push(`
                    <button class="btn btn-primary" onclick="startProcessing('${job.id}')" title="Démarrer le traitement">
                        ▶️ Traiter
                    </button>
                `);
                actions.push(`
                    <button class="btn btn-secondary" onclick="deleteJob('${job.id}')" title="Supprimer ce job">
                        🗑️ Supprimer
                    </button>
                `);
                break;
        }

        return actions.join('');
    }

    /**
     * Rendre l'état vide
     */
    renderEmptyState() {
        return `
            <div class="empty-state">
                <div class="empty-state-icon">
                    📁
                </div>
                <div>Aucun fichier en cours de traitement</div>
                <div style="font-size: 0.9rem; margin-top: 0.5rem; color: var(--text-muted);">
                    Glissez des fichiers dans la zone d'upload pour commencer
                </div>
            </div>
        `;
    }

    /**
     * Obtenir le texte de statut
     */
    getStatusText(status) {
        const statusTexts = {
            uploaded: 'Uploadé',
            queued: 'En attente',
            processing: 'Traitement',
            completed: 'Terminé',
            error: 'Erreur',
            cancelled: 'Annulé',
            paused: 'En pause'
        };
        
        return statusTexts[status] || status;
    }

    /**
     * Animer les éléments de job
     */
    animateJobItems() {
        const jobItems = document.querySelectorAll('.job-item');
        
        jobItems.forEach((item, index) => {
            item.style.opacity = '0';
            item.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                item.style.transition = 'all 0.3s ease';
                item.style.opacity = '1';
                item.style.transform = 'translateY(0)';
            }, index * 50);
        });
    }

    /**
     * Mettre à jour un job spécifique dans la liste
     */
    updateJobInList(jobId, updates) {
        const jobElement = document.querySelector(`[data-job-id="${jobId}"]`);
        
        if (!jobElement) return;

        // Mettre à jour le statut
        if (updates.status) {
            jobElement.dataset.status = updates.status;
            const statusElement = jobElement.querySelector('.job-status');
            if (statusElement) {
                statusElement.textContent = this.getStatusText(updates.status);
                statusElement.className = `job-status status-${updates.status}`;
            }
        }

        // Mettre à jour la progression
        if (updates.progress !== undefined) {
            const progressFill = jobElement.querySelector('.progress-fill');
            const progressText = jobElement.querySelector('.progress-text');
            
            if (progressFill) {
                progressFill.style.width = `${updates.progress}%`;
            }
            if (progressText) {
                progressText.textContent = `${updates.progress}% complété`;
            }
        }

        // Animation de mise à jour
        jobElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
            jobElement.style.transform = 'scale(1)';
        }, 200);
    }

    /**
     * Configuration des tooltips
     */
    setupTooltips() {
        // Implémentation simple de tooltips
        document.addEventListener('mouseover', (e) => {
            if (e.target.hasAttribute('title')) {
                this.showTooltip(e.target, e.target.getAttribute('title'));
            }
        });

        document.addEventListener('mouseout', (e) => {
            if (e.target.hasAttribute('title')) {
                this.hideTooltip();
            }
        });
    }

    /**
     * Afficher un tooltip
     */
    showTooltip(element, text) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.textContent = text;
        tooltip.style.cssText = `
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
        `;
        document.body.appendChild(tooltip);

        const rect = element.getBoundingClientRect();
        tooltip.style.left = rect.left + rect.width / 2 - tooltip.offsetWidth / 2 + 'px';
        tooltip.style.top = rect.bottom + 8 + 'px';
    }

    /**
     * Masquer le tooltip
     */
    hideTooltip() {
        const tooltip = document.querySelector('.tooltip');
        if (tooltip) {
            tooltip.remove();
        }
    }

    /**
     * Configuration des animations
     */
    setupAnimations() {
        // Observer pour les animations d'apparition
        if ('IntersectionObserver' in window) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                    }
                });
            });

            // Observer les éléments avec classe animate-on-scroll
            document.querySelectorAll('.animate-on-scroll').forEach(el => {
                observer.observe(el);
            });
        }
    }

    /**
     * Configuration des raccourcis clavier
     */
    setupKeyboardShortcuts() {
        // Les raccourcis sont déjà gérés dans app.js
        // Ici on peut ajouter des indicateurs visuels
    }

    /**
     * Nettoyer les ressources UI
     */
    destroy() {
        // Nettoyer les événements et timers
        this.hideStatus();
        this.hideTooltip();
        this.logger.info('UIManager détruit');
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = UIManager;
} else {
    window.UIManager = UIManager;
}


================================================
File: frontend/js/utils.js
================================================
// js/utils.js
// Utilitaires généraux pour File Optimizer

/**
 * Classe d'utilitaires généraux
 */
class Utils {
    /**
     * Formater la taille d'un fichier
     */
    static formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    /**
     * Déterminer le type d'un fichier basé sur son extension
     */
    static getFileType(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        
        const typeMap = {
            // Images
            jpg: 'image', jpeg: 'image', png: 'image', webp: 'image',
            avif: 'image', heic: 'image', tiff: 'image', bmp: 'image',
            
            // Vidéos
            mp4: 'video', avi: 'video', mkv: 'video', webm: 'video',
            mov: 'video', flv: 'video', m4v: 'video',
            
            // Audio
            mp3: 'audio', flac: 'audio', wav: 'audio', aac: 'audio',
            ogg: 'audio', m4a: 'audio', wma: 'audio',
            
            // Documents
            pdf: 'document'
        };

        return typeMap[ext] || 'unknown';
    }

    /**
     * Obtenir l'icône pour un type de fichier
     */
    static getFileIcon(type) {
        const icons = {
            image: '🖼️',
            video: '🎬',
            audio: '🎵',
            document: '📄',
            unknown: '📎'
        };
        
        return icons[type] || icons.unknown;
    }

    /**
     * Formater une durée en millisecondes
     */
    static formatDuration(ms) {
        if (ms < 1000) return '< 1s';
        
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
            return `${days}j ${hours % 24}h ${minutes % 60}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        } else {
            return `${seconds}s`;
        }
    }

    /**
     * Formater une date relative (il y a X temps)
     */
    static formatRelativeTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);

        if (diffSeconds < 60) {
            return 'À l\'instant';
        } else if (diffMinutes < 60) {
            return `Il y a ${diffMinutes}min`;
        } else if (diffHours < 24) {
            return `Il y a ${diffHours}h`;
        } else if (diffDays < 7) {
            return `Il y a ${diffDays}j`;
        } else {
            return date.toLocaleDateString('fr-FR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            });
        }
    }

    /**
     * Debounce une fonction
     */
    static debounce(func, wait, immediate = false) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                timeout = null;
                if (!immediate) func(...args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func(...args);
        };
    }

    /**
     * Throttle une fonction
     */
    static throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    /**
     * Générer un ID unique
     */
    static generateId() {
        return 'id-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
    }

    /**
     * Nettoyer une chaîne pour l'HTML
     */
    static escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Copier du texte dans le presse-papier
     */
    static async copyToClipboard(text) {
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (error) {
            // Fallback pour les navigateurs plus anciens
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            return successful;
        }
    }

    /**
     * Valider une URL
     */
    static isValidUrl(string) {
        try {
            new URL(string);
            return true;
        } catch (_) {
            return false;
        }
    }

    /**
     * Obtenir les informations sur le navigateur
     */
    static getBrowserInfo() {
        const ua = navigator.userAgent;
        let browser = 'Unknown';
        
        if (ua.includes('Chrome')) browser = 'Chrome';
        else if (ua.includes('Firefox')) browser = 'Firefox';
        else if (ua.includes('Safari')) browser = 'Safari';
        else if (ua.includes('Edge')) browser = 'Edge';
        
        return {
            browser,
            userAgent: ua,
            language: navigator.language,
            platform: navigator.platform,
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine
        };
    }

    /**
     * Détecter le support de certaines fonctionnalités
     */
    static getFeatureSupport() {
        return {
            websocket: 'WebSocket' in window,
            webworker: 'Worker' in window,
            clipboard: 'clipboard' in navigator,
            notification: 'Notification' in window,
            geolocation: 'geolocation' in navigator,
            localStorage: 'localStorage' in window,
            sessionStorage: 'sessionStorage' in window,
            dragDrop: 'draggable' in document.createElement('div'),
            fileApi: 'FileReader' in window,
            canvas: 'getContext' in document.createElement('canvas')
        };
    }

    /**
     * Calculer le pourcentage de compression
     */
    static calculateCompressionRatio(originalSize, compressedSize) {
        if (originalSize === 0) return 0;
        return Math.round(((originalSize - compressedSize) / originalSize) * 100);
    }

    /**
     * Formater un ratio de compression
     */
    static formatCompressionRatio(ratio) {
        if (ratio <= 0) return 'Aucune compression';
        if (ratio < 10) return `${ratio}% (faible)`;
        if (ratio < 30) return `${ratio}% (modérée)`;
        if (ratio < 50) return `${ratio}% (bonne)`;
        if (ratio < 70) return `${ratio}% (très bonne)`;
        return `${ratio}% (excellente)`;
    }

    /**
     * Obtenir la couleur pour un statut
     */
    static getStatusColor(status) {
        const colors = {
            uploaded: '#7c3aed',
            queued: '#d97706',
            processing: '#2563eb',
            completed: '#10b981',
            error: '#ef4444',
            cancelled: '#6b7280'
        };
        
        return colors[status] || colors.uploaded;
    }

    /**
     * Créer un élément DOM avec des attributs
     */
    static createElement(tag, attributes = {}, children = []) {
        const element = document.createElement(tag);
        
        // Ajouter les attributs
        Object.entries(attributes).forEach(([key, value]) => {
            if (key === 'className') {
                element.className = value;
            } else if (key === 'innerHTML') {
                element.innerHTML = value;
            } else if (key === 'textContent') {
                element.textContent = value;
            } else if (key.startsWith('data-')) {
                element.setAttribute(key, value);
            } else {
                element[key] = value;
            }
        });
        
        // Ajouter les enfants
        children.forEach(child => {
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            } else if (child instanceof Node) {
                element.appendChild(child);
            }
        });
        
        return element;
    }

    /**
     * Animer un élément avec CSS
     */
    static animate(element, animation, duration = 300) {
        return new Promise(resolve => {
            element.style.animation = `${animation} ${duration}ms ease`;
            
            const handleAnimationEnd = () => {
                element.style.animation = '';
                element.removeEventListener('animationend', handleAnimationEnd);
                resolve();
            };
            
            element.addEventListener('animationend', handleAnimationEnd);
        });
    }

    /**
     * Faire défiler vers un élément
     */
    static scrollToElement(element, behavior = 'smooth') {
        element.scrollIntoView({
            behavior,
            block: 'nearest',
            inline: 'nearest'
        });
    }

    /**
     * Vérifier si un élément est visible dans le viewport
     */
    static isElementVisible(element) {
        const rect = element.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
    }

    /**
     * Obtenir les dimensions de l'écran
     */
    static getScreenInfo() {
        return {
            width: window.innerWidth,
            height: window.innerHeight,
            devicePixelRatio: window.devicePixelRatio || 1,
            orientation: window.orientation || 0,
            isMobile: window.innerWidth <= 768,
            isTablet: window.innerWidth > 768 && window.innerWidth <= 1024,
            isDesktop: window.innerWidth > 1024
        };
    }

    /**
     * Logger personnalisé avec niveaux
     */
    static createLogger(prefix = 'FileOptimizer') {
        const logLevels = {
            error: 0,
            warn: 1,
            info: 2,
            debug: 3
        };
        
        const currentLevel = logLevels[localStorage.getItem('logLevel')] ?? logLevels.info;
        
        return {
            error: (...args) => {
                if (currentLevel >= logLevels.error) {
                    console.error(`[${prefix}]`, ...args);
                }
            },
            warn: (...args) => {
                if (currentLevel >= logLevels.warn) {
                    console.warn(`[${prefix}]`, ...args);
                }
            },
            info: (...args) => {
                if (currentLevel >= logLevels.info) {
                    console.info(`[${prefix}]`, ...args);
                }
            },
            debug: (...args) => {
                if (currentLevel >= logLevels.debug) {
                    console.debug(`[${prefix}]`, ...args);
                }
            }
        };
    }

    /**
     * Gestionnaire d'erreurs global
     */
    static handleError(error, context = 'Unknown') {
        const logger = this.createLogger('ErrorHandler');
        
        logger.error(`Erreur dans ${context}:`, {
            message: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href
        });

        // Optionnel : envoyer à un service de monitoring
        if (window.Sentry) {
            window.Sentry.captureException(error, {
                tags: { context },
                extra: { timestamp: new Date().toISOString() }
            });
        }
    }

    /**
     * Retry automatique avec backoff exponentiel
     */
    static async retry(fn, maxAttempts = 3, baseDelay = 1000) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                return await fn(attempt);
            } catch (error) {
                lastError = error;
                
                if (attempt === maxAttempts) {
                    throw error;
                }
                
                const delay = baseDelay * Math.pow(2, attempt - 1);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        throw lastError;
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Utils;
} else {
    window.Utils = Utils;
}


================================================
File: frontend/js/websocket.js
================================================
// js/websocket.js
// Client WebSocket pour la communication temps réel

/**
 * Gestionnaire WebSocket pour les communications temps réel
 */
class WebSocketManager {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.socket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.reconnectDelay = 1000; // 1 seconde
        this.isConnecting = false;
        this.isConnected = false;
        this.eventHandlers = new Map();
        this.joinedRooms = new Set();
        this.logger = Utils.createLogger('WebSocket');
        
        this.connect();
    }

    /**
     * Établir la connexion WebSocket
     */
    connect() {
        if (this.isConnecting || this.isConnected) {
            return;
        }

        try {
            this.isConnecting = true;
            this.logger.info('Connexion WebSocket...');

            // Initialiser Socket.IO
            this.socket = io(this.baseUrl, {
                transports: ['websocket', 'polling'],
                timeout: 20000,
                reconnection: false, // Gestion manuelle
                forceNew: true
            });

            this.setupEventHandlers();

        } catch (error) {
            this.logger.error('Erreur création WebSocket:', error);
            this.isConnecting = false;
            this.scheduleReconnect();
        }
    }

    /**
     * Configuration des gestionnaires d'événements Socket.IO
     */
    setupEventHandlers() {
        // Connexion établie
        this.socket.on('connect', () => {
            this.isConnected = true;
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            
            this.logger.info('WebSocket connecté', { id: this.socket.id });
            this.emit('connect');

            // Rejoindre les rooms précédemment jointes
            this.rejoinRooms();
        });

        // Déconnexion
        this.socket.on('disconnect', (reason) => {
            this.isConnected = false;
            this.logger.warn('WebSocket déconnecté:', reason);
            this.emit('disconnect', reason);

            // Reconnexion automatique sauf si déconnexion volontaire
            if (reason !== 'io client disconnect') {
                this.scheduleReconnect();
            }
        });

        // Erreur de connexion
        this.socket.on('connect_error', (error) => {
            this.isConnecting = false;
            this.logger.error('Erreur connexion WebSocket:', error);
            this.emit('error', error);
            this.scheduleReconnect();
        });

        // Événements métier
        this.socket.on('job-progress', (data) => {
            this.logger.debug('Progression job:', data);
            this.emit('job-progress', data);
        });

        this.socket.on('job-completed', (data) => {
            this.logger.info('Job terminé:', data.jobId);
            this.emit('job-completed', data);
        });

        this.socket.on('job-error', (data) => {
            this.logger.error('Erreur job:', data);
            this.emit('job-error', data);
        });

        this.socket.on('job-queued', (data) => {
            this.logger.info('Job en queue:', data.jobId);
            this.emit('job-queued', data);
        });

        this.socket.on('job-started', (data) => {
            this.logger.info('Job démarré:', data.jobId);
            this.emit('job-started', data);
        });

        // Événements système
        this.socket.on('server-shutdown', (data) => {
            this.logger.warn('Serveur en arrêt:', data);
            this.emit('server-shutdown', data);
        });

        this.socket.on('server-maintenance', (data) => {
            this.logger.info('Maintenance serveur:', data);
            this.emit('server-maintenance', data);
        });

        // Événements de notification
        this.socket.on('notification', (data) => {
            this.logger.info('Notification:', data);
            this.emit('notification', data);
        });

        // Réponses aux requêtes
        this.socket.on('joined-job', (data) => {
            this.joinedRooms.add(`job-${data.jobId}`);
            this.logger.debug('Rejoint room job:', data.jobId);
        });

        this.socket.on('left-job', (data) => {
            this.joinedRooms.delete(`job-${data.jobId}`);
            this.logger.debug('Quitté room job:', data.jobId);
        });

        this.socket.on('job-status', (data) => {
            this.emit('job-status-response', data);
        });

        // Événements d'erreur spécifiques
        this.socket.on('error', (data) => {
            this.logger.error('Erreur WebSocket:', data);
            this.emit('websocket-error', data);
        });
    }

    /**
     * Programmer une reconnexion
     */
    scheduleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            this.logger.error('Nombre maximum de tentatives de reconnexion atteint');
            this.emit('max-reconnect-attempts');
            return;
        }

        this.reconnectAttempts++;
        const delay = Math.min(
            this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
            30000 // Maximum 30 secondes
        );

        this.logger.info(`Reconnexion dans ${delay}ms (tentative ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

        setTimeout(() => {
            if (!this.isConnected && !this.isConnecting) {
                this.connect();
            }
        }, delay);
    }

    /**
     * Rejoindre les rooms après reconnexion
     */
    rejoinRooms() {
        this.joinedRooms.forEach(room => {
            if (room.startsWith('job-')) {
                const jobId = room.replace('job-', '');
                this.joinJobRoom(jobId);
            }
        });
    }

    /**
     * Rejoindre la room d'un job pour recevoir les updates
     */
    joinJobRoom(jobId) {
        if (!this.isConnected) {
            this.logger.warn('Impossible de rejoindre room, WebSocket non connecté');
            return;
        }

        this.socket.emit('join-job', jobId);
        this.logger.debug('Demande rejoindre room job:', jobId);
    }

    /**
     * Quitter la room d'un job
     */
    leaveJobRoom(jobId) {
        if (!this.isConnected) {
            return;
        }

        this.socket.emit('leave-job', jobId);
        this.joinedRooms.delete(`job-${jobId}`);
        this.logger.debug('Quitté room job:', jobId);
    }

    /**
     * Demander le statut d'un job
     */
    requestJobStatus(jobId) {
        if (!this.isConnected) {
            this.logger.warn('Impossible de demander statut, WebSocket non connecté');
            return;
        }

        this.socket.emit('get-status', jobId);
        this.logger.debug('Demande statut job:', jobId);
    }

    /**
     * Envoyer un ping au serveur
     */
    ping() {
        if (!this.isConnected) {
            return Promise.reject(new Error('WebSocket non connecté'));
        }

        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            this.socket.emit('ping', startTime, (response) => {
                const latency = Date.now() - startTime;
                resolve({ latency, serverTime: response });
            });

            // Timeout après 5 secondes
            setTimeout(() => {
                reject(new Error('Ping timeout'));
            }, 5000);
        });
    }

    /**
     * S'abonner à un type d'événement
     */
    on(event, handler) {
        if (!this.eventHandlers.has(event)) {
            this.eventHandlers.set(event, new Set());
        }
        this.eventHandlers.get(event).add(handler);
    }

    /**
     * Se désabonner d'un événement
     */
    off(event, handler) {
        if (this.eventHandlers.has(event)) {
            this.eventHandlers.get(event).delete(handler);
        }
    }

    /**
     * Émettre un événement vers les handlers locaux
     */
    emit(event, data) {
        if (this.eventHandlers.has(event)) {
            this.eventHandlers.get(event).forEach(handler => {
                try {
                    handler(data);
                } catch (error) {
                    this.logger.error(`Erreur handler événement ${event}:`, error);
                }
            });
        }
    }

    /**
     * Envoyer un événement au serveur
     */
    send(event, data) {
        if (!this.isConnected) {
            this.logger.warn(`Impossible d'envoyer ${event}, WebSocket non connecté`);
            return;
        }

        this.socket.emit(event, data);
    }

    /**
     * Déconnexion manuelle
     */
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
        }
        
        this.isConnected = false;
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.joinedRooms.clear();
        
        this.logger.info('WebSocket déconnecté manuellement');
    }

    /**
     * Reconnexion manuelle
     */
    reconnect() {
        this.disconnect();
        setTimeout(() => {
            this.reconnectAttempts = 0;
            this.connect();
        }, 1000);
    }

    /**
     * Obtenir l'état de la connexion
     */
    getConnectionState() {
        return {
            isConnected: this.isConnected,
            isConnecting: this.isConnecting,
            reconnectAttempts: this.reconnectAttempts,
            socketId: this.socket?.id,
            joinedRooms: Array.from(this.joinedRooms),
            transport: this.socket?.io?.engine?.transport?.name
        };
    }

    /**
     * Obtenir les statistiques de connexion
     */
    getStats() {
        if (!this.socket) {
            return { connected: false };
        }

        return {
            connected: this.isConnected,
            socketId: this.socket.id,
            transport: this.socket.io.engine.transport.name,
            reconnectAttempts: this.reconnectAttempts,
            joinedRooms: this.joinedRooms.size,
            eventHandlers: this.eventHandlers.size
        };
    }

    /**
     * Activer/désactiver le mode debug
     */
    setDebugMode(enabled) {
        if (this.socket) {
            this.socket.debug(enabled);
        }
    }

    /**
     * Nettoyer les ressources
     */
    destroy() {
        this.eventHandlers.clear();
        this.joinedRooms.clear();
        
        if (this.socket) {
            this.socket.removeAllListeners();
            this.socket.disconnect();
        }
        
        this.logger.info('WebSocketManager détruit');
    }

    /**
     * Test de fonctionnalité WebSocket
     */
    async testConnection() {
        try {
            if (!this.isConnected) {
                throw new Error('WebSocket non connecté');
            }

            // Test ping
            const pingResult = await this.ping();
            
            // Test join/leave room
            this.joinJobRoom('test-job-id');
            await new Promise(resolve => setTimeout(resolve, 100));
            this.leaveJobRoom('test-job-id');

            return {
                success: true,
                latency: pingResult.latency,
                features: {
                    ping: true,
                    rooms: true,
                    events: true
                }
            };

        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Middleware pour retry automatique des événements critiques
     */
    sendWithRetry(event, data, maxRetries = 3) {
        return new Promise((resolve, reject) => {
            let attempts = 0;

            const attemptSend = () => {
                attempts++;

                if (!this.isConnected) {
                    if (attempts < maxRetries) {
                        setTimeout(attemptSend, 1000 * attempts);
                        return;
                    }
                    reject(new Error('WebSocket non connecté après plusieurs tentatives'));
                    return;
                }

                this.socket.emit(event, data, (response) => {
                    if (response && response.success) {
                        resolve(response);
                    } else if (attempts < maxRetries) {
                        setTimeout(attemptSend, 1000 * attempts);
                    } else {
                        reject(new Error(response?.error || 'Erreur envoi événement'));
                    }
                });
            };

            attemptSend();
        });
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = WebSocketManager;
} else {
    window.WebSocketManager = WebSocketManager;
}

